import React, { useState, useCallback, useEffect } from 'react';
import classNames from 'classnames';
import dataQa from '@platform-ui/dataQa';
import { Int16Close as IconClose, Int16SuccessFilled as IconSuccessFilled, Int16AttentionFilled as IconAttentionFilled, Int16CloseCircleFilled as IconCloseCircleFilled } from '@platform-ui/iconsPack';
import Loader from '@platform-ui/loader';
import CollapseBlock from '@platform-ui/collapseBlock';
import { useTimer } from '../utils';
import NotificationBaseButtons from './NotificationBaseButtons';
import styles from './NotificationBase.module.css';
export const TYPES = {
  INFO: 'info',
  SUCCESS: 'success',
  WARNING: 'warning',
  ERROR: 'error'
};
const ICON_TYPE = {
  info: /*#__PURE__*/React.createElement(IconAttentionFilled, {
    rotate: 180,
    verticalAlign: "middle"
  }),
  success: /*#__PURE__*/React.createElement(IconSuccessFilled, {
    verticalAlign: "middle"
  }),
  error: /*#__PURE__*/React.createElement(IconCloseCircleFilled, {
    verticalAlign: "middle"
  }),
  warning: /*#__PURE__*/React.createElement(IconAttentionFilled, {
    verticalAlign: "middle"
  })
};

const NotificationBase = props => {
  const {
    actionText,
    animateFirstRender,
    cancelText,
    children,
    dataQaType = 'uikit/NotificationBase',
    delayCollapse,
    durationCollapse = 0,
    hideOnAction = true,
    hideOnCancel = true,
    icon,
    modStyles = {},
    overflowHiddenCollapse,
    paddingBottom = 0,
    showClose = true,
    timer = 30000,
    title,
    type = TYPES.INFO,
    visibleCollapse = true,
    withIcon = true,
    onActionConfirm,
    onCancel,
    onHide,
    onClose
  } = props;
  const [loading, setLoading] = useState(false);
  const [mounted, setMounted] = useState(true);
  const [visible, setVisible] = useState(animateFirstRender);
  const shouldHideOnClose = useCallback(fromButton => Boolean(!fromButton || fromButton === 'action' && hideOnAction || fromButton === 'cancel' && hideOnCancel), [hideOnAction, hideOnCancel]);
  const handleClose = useCallback(fromButton => {
    setVisible(!shouldHideOnClose(fromButton));
    setLoading(false);
  }, [shouldHideOnClose]);
  const {
    setTimer,
    pauseTimer
  } = useTimer(handleClose, timer);
  const getHandler = useCallback((event, fromButton, callback) => {
    event.preventDefault();
    const result = callback && callback(event);

    if (result instanceof Promise) {
      setLoading(true);
      result.then(() => handleClose(fromButton)).catch(() => {
        setLoading(false);
      });
    } else {
      handleClose(fromButton);
    }
  }, [handleClose]);

  const handleActionClick = event => getHandler(event, 'action', onActionConfirm);

  const handleCancelClick = event => getHandler(event, 'cancel', onCancel);

  const handleIconClose = event => {
    handleClose();
    onClose && onClose(event);
  };

  const handleAnimationEnd = event => {
    setMounted(false);
    onHide && onHide(event);
  };

  const handleMouseEnter = () => {
    pauseTimer();
  };

  const handleMouseLeave = () => {
    setTimer();
  };

  const handleDocumentVisibilityChange = () => {
    if (document.visibilityState === 'visible') {
      setTimer();
    } else {
      pauseTimer();
    }
  };

  useEffect(() => {
    setTimer();
    setVisible(true);
    document.addEventListener('visibilitychange', handleDocumentVisibilityChange);
    return () => {
      document.removeEventListener('visibilitychange', handleDocumentVisibilityChange);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  return mounted ? /*#__PURE__*/React.createElement(CollapseBlock, {
    duration: durationCollapse,
    delay: !visibleCollapse ? 0 : delayCollapse,
    overflowHidden: overflowHiddenCollapse,
    collapsed: !visibleCollapse || !visible,
    onTransitionEnd: !visible ? handleAnimationEnd : undefined
  }, /*#__PURE__*/React.createElement("div", Object.assign({}, dataQa(props), {
    style: {
      paddingBottom
    },
    className: classNames({
      [styles.wrapper]: true,
      [styles.wrapper_visible]: visible,
      [styles.wrapper_hidden]: !visible,
      [modStyles.wrapper]: true,
      [modStyles.wrapper_visible]: visible,
      [modStyles.wrapper_hidden]: !visible
    }),
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave
  }), /*#__PURE__*/React.createElement("div", {
    className: classNames({
      [styles.alert]: true,
      [styles[`alert_${type}`]]: true,
      [modStyles.alert]: true
    })
  }, !!withIcon && /*#__PURE__*/React.createElement("div", {
    className: classNames({
      [styles.icon]: true,
      [styles.icon_title]: !!title
    })
  }, icon || ICON_TYPE[type]), /*#__PURE__*/React.createElement("div", Object.assign({}, dataQa({
    dataQaType: `${dataQaType}.contentWrapper`
  }), {
    className: styles.contentWrapper
  }), !!title && /*#__PURE__*/React.createElement("div", Object.assign({}, dataQa({
    dataQaType: `${dataQaType}.title`
  }), {
    className: styles.title
  }), title), !!children && /*#__PURE__*/React.createElement("div", Object.assign({}, dataQa({
    dataQaType: `${dataQaType}.content`
  }), {
    className: styles.content
  }), children), /*#__PURE__*/React.createElement(NotificationBaseButtons, {
    actionText: actionText,
    cancelText: cancelText,
    onActionConfirm: handleActionClick,
    onCancel: handleCancelClick
  })), !!showClose && /*#__PURE__*/React.createElement("span", {
    role: "button",
    className: styles.closeIcon,
    onClick: handleIconClose
  }, /*#__PURE__*/React.createElement(IconClose, null)), loading ? /*#__PURE__*/React.createElement(Loader, {
    size: "l",
    overlay: true
  }) : undefined))) : null;
}; // TODO: убрать в мажорном обновлении


NotificationBase.defaultProps = {
  dataQaType: 'uikit/NotificationBase',
  visibleCollapse: true,
  paddingBottom: 0,
  timer: 30000,
  type: TYPES.INFO,
  showClose: true,
  modStyles: {},
  animateFirstRender: false,
  withIcon: true,
  hideOnAction: true,
  hideOnCancel: true
};
export default NotificationBase;