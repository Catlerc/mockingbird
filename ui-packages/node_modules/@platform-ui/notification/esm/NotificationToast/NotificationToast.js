import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
const _excluded = ["dataQaType", "animateFirstRender", "delayCollapse", "modStyles", "overflowHiddenCollapse", "paddingBottom"];
import React, { useState, useRef, useCallback } from 'react';
import Draggable from '@platform-ui/draggable';
import NotificationBase from '../NotificationBase/NotificationBase';
import styles from './NotificationToast.module.css';
const HIDDEN_POINT = 50;
const OPACITY_POINT = 100;

const getOffsetLeft = drag => drag.offset.x - (drag.start ? drag.start.offset.x : 0);

const NotificationToast = props => {
  const {
    dataQaType = 'uikit/NotificationToast',
    animateFirstRender = false,
    delayCollapse = 250,
    modStyles = styles,
    overflowHiddenCollapse = false,
    paddingBottom = 0
  } = props,
        restProps = _objectWithoutPropertiesLoose(props, _excluded);

  const [visible, setVisible] = useState(true);
  const [mounted, setMounted] = useState(true);
  const containerRef = useRef(null);
  const setContainerStyles = useCallback((offsetLeft = 0, transition = '', opacity = 1) => {
    if (!containerRef.current) {
      return;
    }

    const trasnformVal = `translate3d(${offsetLeft}px, 0, 0)`;
    containerRef.current.style.webkitTransform = trasnformVal;
    containerRef.current.style.transform = trasnformVal;
    containerRef.current.style.webkitTransition = transition;
    containerRef.current.style.transition = transition;
    containerRef.current.style.opacity = `${opacity}`;
  }, []);
  const handleDrag = useCallback(drag => {
    if (!containerRef.current) {
      return;
    }

    const offsetLeft = Math.max(0, getOffsetLeft(drag));
    const opacity = 1 - offsetLeft / containerRef.current.offsetWidth * 100 / OPACITY_POINT;
    setContainerStyles(offsetLeft, '', opacity);
  }, [setContainerStyles]);
  const handleDragEnd = useCallback(drag => {
    const transition = 'transform .25s, opacity .25s';

    if (containerRef.current && HIDDEN_POINT <= getOffsetLeft(drag) / containerRef.current.offsetWidth * 100) {
      setVisible(false);
      setContainerStyles(containerRef.current.offsetWidth, transition, 0);
      return;
    }

    setContainerStyles(0, transition, 1);
  }, [setContainerStyles]);

  const handleHide = event => {
    const {
      onHide
    } = props;

    if (mounted) {
      setMounted(false);
      onHide && onHide(event);
    }
  };

  const handleTransitionEnd = event => {
    if (!visible) {
      handleHide(event);
    }
  };

  return mounted ? /*#__PURE__*/React.createElement(Draggable, {
    onDrag: handleDrag,
    onDragEnd: handleDragEnd,
    dragThreshold: 10,
    touchable: true,
    allowDefaultAction: true
  }, /*#__PURE__*/React.createElement("div", {
    ref: containerRef,
    onTransitionEnd: handleTransitionEnd,
    "data-qa-type": dataQaType
  }, /*#__PURE__*/React.createElement(NotificationBase, Object.assign({}, restProps, {
    animateFirstRender: animateFirstRender,
    delayCollapse: delayCollapse,
    modStyles: modStyles,
    onHide: handleHide,
    overflowHiddenCollapse: overflowHiddenCollapse,
    paddingBottom: paddingBottom,
    visibleCollapse: visible
  })))) : null;
}; // TODO: убрать в мажорном обновлении


NotificationToast.defaultProps = _extends({}, NotificationBase.defaultProps, {
  animateFirstRender: false,
  dataQaType: 'uikit/NotificationToast',
  modStyles: styles,
  overflowHiddenCollapse: false,
  delayCollapse: 250,
  paddingBottom: 0
});
export default NotificationToast;