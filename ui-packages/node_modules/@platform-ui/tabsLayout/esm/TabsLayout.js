import React from 'react';
import cn from 'classnames';
import styles from './TabsLayout.module.css';

class TabsLayout extends React.PureComponent {
  constructor(props) {
    super(props);
    this.rootRef = /*#__PURE__*/React.createRef();
    this.moreRef = /*#__PURE__*/React.createRef();
    this.itemNodes = [];
    this.itemsVisibility = [];
    this.itemRefCallbacks = [];
    this.itemsObserver = void 0;
    this.state = {
      moreButtonWidth: props.moreButtonWidth,
      tabs: []
    };
  }

  static getDerivedStateFromProps(props) {
    return {
      tabs: React.Children.toArray(props.children)
    };
  }

  componentDidMount() {
    // eslint-disable-next-line compat/compat
    this.itemsObserver = new IntersectionObserver(entries => {
      const {
        onItemsVisibilityChange
      } = this.props;
      const {
        tabs
      } = this.state;
      this.itemsVisibility.length = tabs.length;
      entries.forEach(entry => {
        const item = entry.target;
        const index = +item.dataset.index;
        const visible = entry.intersectionRatio > 0;
        this.itemsVisibility[index] = visible;
      });
      onItemsVisibilityChange(null, {
        itemsVisibility: [...this.itemsVisibility]
      });
    }, {
      root: this.rootRef.current,
      threshold: 1
    });
    this.itemNodes.forEach(itemNode => {
      if (itemNode) {
        this.itemsObserver.observe(itemNode);
      }
    });
    this.updateMoreWidth();
  }

  componentDidUpdate(prevProps) {
    const {
      moreButton,
      moreButtonWidth
    } = this.props;

    if (prevProps.moreButtonWidth !== moreButtonWidth || prevProps.moreButton !== moreButton) {
      this.updateMoreWidth();
    }
  }

  componentWillUnmount() {
    this.itemsObserver && this.itemsObserver.disconnect();
  }

  getItemRefCallback(index) {
    if (!this.itemRefCallbacks[index]) {
      this.itemRefCallbacks[index] = node => {
        if (this.itemsObserver) {
          const prevNode = this.itemNodes[index];

          if (node) {
            this.itemsObserver.observe(node);
          } else if (prevNode) {
            this.itemsObserver.unobserve(prevNode);
          }
        }

        this.itemNodes[index] = node;
      };
    }

    return this.itemRefCallbacks[index];
  } // eslint-disable-next-line max-statements


  getItemPosition(index) {
    const activeIndex = this.props.activeIndex;
    const {
      rearrangeActiveElem
    } = this.props;
    const {
      tabs: {
        length
      }
    } = this.state;

    if (length === 1) {
      return 'last';
    }

    if (!rearrangeActiveElem) {
      if (index === length - 1) {
        return 'last';
      }

      return 'base';
    }

    if (activeIndex === length - 1) {
      if (index === length - 2) {
        return 'beforeLastActive';
      }
    } else if (index === length - 1) {
      return 'last';
    }

    if (index === activeIndex) {
      return 'active';
    }

    if (index < activeIndex) {
      return 'beforeActive';
    }

    return 'base';
  }

  updateMoreWidth() {
    requestAnimationFrame(() => {
      if (this.moreRef.current) {
        this.setState({
          moreButtonWidth: this.moreRef.current.getBoundingClientRect().width
        });
      }
    });
  }

  renderMoreButton(index) {
    const {
      moreButton
    } = this.props;

    if (typeof moreButton === 'function') {
      return moreButton({
        index
      });
    }

    return moreButton;
  }

  renderItem(tab, index) {
    const gap = this.props.gap;
    const activeIndex = this.props.activeIndex;
    const {
      height,
      backgroundColor,
      moreButton
    } = this.props;
    const {
      moreButtonWidth,
      tabs
    } = this.state;
    const position = this.getItemPosition(index);
    const style = {
      height,
      backgroundColor,
      paddingRight: gap
    };
    let overflowContent;
    const overflowContentStyle = {}; // eslint-disable-next-line default-case

    switch (position) {
      case 'last':
        /**
         * Добавляем 1 пиксель ширины на тот случай, когда последний таб уже кнопки "Ещё":
         * Иначе последний таб занимает 0 пикселей по ширине и "вываливается" раньше времени
         * когда выбран предпоследний таб.
         * Также добавляем дополнительный паддинг в 100px на случай если moreButtonWidth подсчитан неправильно
         * (иногда случается после SSR)
         */
        style.minWidth = moreButtonWidth + 1;
        style.marginRight = -moreButtonWidth - 100;
        style.paddingRight = 100;
        break;

      case 'base':
      case 'active':
        overflowContent = this.renderMoreButton(index);
        break;

      case 'beforeLastActive':
        style.marginRight = -moreButtonWidth - gap;
        overflowContent = tabs[activeIndex];
        /**
         * Добавляем паддинг справа на случай, когда предпоследний таб уже кнопки "Ещё":
         * В этом случае кнопка Ещё выпирает из-под последнего таба
         */

        overflowContentStyle.paddingRight = moreButtonWidth;
        break;
    }

    return /*#__PURE__*/React.createElement("div", {
      key: index,
      ref: this.getItemRefCallback(index),
      "data-index": index,
      style: style,
      className: cn({
        [styles.item]: true,
        [styles[`item_position_${position}`]]: true
      })
    }, tab, overflowContent && /*#__PURE__*/React.createElement("div", {
      className: styles.overflowContent,
      style: overflowContentStyle
    }, overflowContent));
  }

  render() {
    const activeIndex = this.props.activeIndex;
    const {
      height,
      align,
      rearrangeActiveElem,
      moreButton
    } = this.props;
    const {
      tabs
    } = this.state;
    const items = tabs.map(this.renderItem, this);
    let itemsBeforeActive;

    if (rearrangeActiveElem && activeIndex >= 0 && activeIndex < tabs.length) {
      itemsBeforeActive = items.splice(0, activeIndex + 1);
      itemsBeforeActive.unshift(itemsBeforeActive.pop());
    }

    return /*#__PURE__*/React.createElement("div", {
      ref: this.rootRef,
      className: cn({
        [styles.root]: true,
        [styles[`root_align_${align}`]]: true
      }),
      style: {
        height
      }
    }, /*#__PURE__*/React.createElement("div", {
      className: styles.tabs
    }, itemsBeforeActive && /*#__PURE__*/React.createElement("div", {
      className: styles.itemsBeforeActive
    }, itemsBeforeActive), items), /*#__PURE__*/React.createElement("div", {
      className: styles.invisibleBlock,
      ref: this.moreRef
    }, this.renderMoreButton(null)));
  }

}

TabsLayout.defaultProps = {
  align: 'left',
  moreButtonWidth: 0,
  gap: 0,
  rearrangeActiveElem: true,
  activeIndex: -1
};
export default TabsLayout;