import _extends from "@babel/runtime/helpers/extends";
import React, { Fragment } from 'react';
import memoizeWeak from '@platform-ui/memoizeWeak';
import DropdownNoResults from './DropdownNoResults';
import DropdownLoader from './DropdownLoader';

/**
 * Проверяет выбрана ли опция
 *
 * @param {Array<String>|String} value Текущее значение поля
 * @param option Проверяемая опция
 * @returns {boolean}
 */
const isOptionSelected = (value, option) => {
  const optionValue = typeof option.value !== 'undefined' ? option.value : option;
  return Array.isArray(value) ? value.indexOf(optionValue) !== -1 : optionValue === value;
};
/**
 * Возвращает только выбранные элементы из массива опций
 *
 * @param {Array<Object>} options Массив опций
 * @param {Array<String>|String} value Текущее значение поля
 * @returns {Array<Object|String>|Object|String}
 */


const getSelectedOptions = (options, value) => {
  const single = !Array.isArray(value);
  const result = [];

  if (single ? typeof value !== 'undefined' : value.length) {
    for (let i = 0; options && i < options.length; i++) {
      if (isOptionSelected(value, options[i])) {
        result.push(options[i]);
      } else {
        const subOpt = options[i].options && getSelectedOptions(options[i].options, value);

        if (subOpt) {
          result.push(...(Array.isArray(subOpt) ? subOpt : [subOpt]));
        }
      }

      if (result.length && single) {
        return result[0];
      }
    }
  }

  return result;
};
/**
 * Делает массив вложенных опций плоским
 */


const flattenOptions = memoizeWeak(options => {
  return options.reduce((acc, option) => {
    return option.options ? acc.concat(option.options) : acc.concat(option);
  }, []);
});
/**
 * Нормализует строку для более правильного сравнения
 */

const normalise = value => {
  switch (typeof value) {
    case 'string':
      {
        return value.toLocaleLowerCase().replace('ё', 'е');
      }

    case 'number':
      {
        return value.toString();
      }

    default:
      {
        return '';
      }
  }
};
/**
 * Оборачивает указанный кусок строки тегом <em>
 */


const highlight = (value, startIndex, length) => {
  const string = value.toString();
  return /*#__PURE__*/React.createElement(Fragment, null, string.substr(0, startIndex), /*#__PURE__*/React.createElement("em", null, string.substr(startIndex, length)), string.substr(startIndex + length));
};
/**
 * Проверяет является ли значение строкой или числом
 */


const isSimpleValue = value => {
  return typeof value === 'string' || typeof value === 'number';
};

const isObject = option => {
  return typeof option === 'object';
};
/**
 * Проверяет подходит ли строка под указанную query-строку
 */


const filterOption = (option, normalisedQuery, query, isHighLighted) => {
  const fields = isObject(option) ? [option.value, option.title] : [option]; // TODO: why?

  if (!isObject(option) && query === option) {
    return false;
  }

  const result = fields.some(field => {
    if (isSimpleValue(field)) {
      return normalise(field).indexOf(normalisedQuery) > -1;
    }

    return false;
  });

  if (!result) {
    return false;
  }

  const title = isObject(option) ? option.title : option;
  const matchTitleIndex = isSimpleValue(title) ? normalise(title).indexOf(normalisedQuery) : -1;
  return _extends({}, isObject(option) ? option : {}, {
    title: isHighLighted && matchTitleIndex !== -1 ? highlight(title, matchTitleIndex, normalisedQuery.length) : title,
    value: isObject(option) ? option.value : option
  });
};
/**
 * Возвращает отфильтрованный список опций
 */


function withSubOptions(option) {
  return typeof option === 'object' && Boolean(option.options);
}

function filterOptions(options, query, filterFunc, highlightMatch) {
  if (!query) {
    return options;
  }

  const normalisedQuery = normalise(query).trim();
  const newOptions = [];

  if (normalisedQuery.length && Array.isArray(options)) {
    options.forEach(option => {
      if (withSubOptions(option)) {
        const newSubOptions = filterOptions(option.options, query, filterFunc);

        if (newSubOptions.length) {
          newOptions.push(_extends({}, option, {
            options: newSubOptions
          }));
        }
      } else {
        const newOption = filterFunc(option, normalisedQuery, query, highlightMatch);

        if (newOption) {
          newOptions.push(newOption === true ? option : newOption);
        }
      }
    });
  }

  return newOptions;
}
/**
 * Сравнивает 2 опции (по-хорошему к этому методу не нужно прибегать, если объекты данных нормально кешируются)
 */


const isSameOption = (opt1, opt2) => Boolean(opt1 === opt2 || opt1 && opt2 && opt1.value === opt2.value && opt1.value !== undefined); // eslint-disable-next-line @typescript-eslint/no-empty-function


const noop = () => {};

/**
 * Возвращает контент для отображения состояний DropdownList, пример:
 * `<DropdownList>{renderCustomContent({ loading, noResults, noResultsContent })}</DropdownList>`
 */
const renderCustomContent = ({
  loading,
  noResults,
  noResultsContent,
  customStyles: _customStyles = {}
}) => {
  if (loading) {
    return /*#__PURE__*/React.createElement(DropdownLoader, {
      className: _customStyles.loader
    });
  }

  if (noResults) {
    return /*#__PURE__*/React.createElement(DropdownNoResults, {
      className: _customStyles.noResults
    }, noResultsContent);
  }

  return null;
};

export { getSelectedOptions, isOptionSelected, flattenOptions, filterOption, filterOptions, highlight, normalise, isSameOption, isSimpleValue, noop, renderCustomContent };