import _extends from "@babel/runtime/helpers/extends";
import React, { PureComponent, createRef } from 'react';
import cn from 'classnames';
import generateId from '@platform-ui/generateId';
import Scroll, { SCROLLBAR_VISIBILITY } from '@platform-ui/scroll';
import overrideStyles from '@platform-ui/overrideStyles';
import { isSameOption, noop } from './utils';
import * as t from './types';
import DropdownItem from './DropdownItem';
import baseStyles from './Dropdown.module.css';

function getOptionProps(option) {
  if (typeof option === 'string' || typeof option === 'number') {
    return {
      key: option,
      title: option,
      value: option
    };
  }

  const {
    title,
    value,
    key
  } = option;

  if (title && key) {
    return option;
  }

  return _extends({}, option, {
    key: key || value,
    title: title || value
  });
}

class DropdownList extends PureComponent {
  constructor(props) {
    var _props$__overrideStyl;

    super(props);
    this.compId = void 0;
    this.blockHover = void 0;
    this.focusedOption = void 0;
    this.scrollContainer = void 0;
    this.listRef = void 0;

    this.refFocusedItem = node => {
      this.focusedOption = node;
    };

    this.refScrollContainer = node => {
      this.scrollContainer = node;
    };

    this.handleMouseDown = event => {
      const option = this.findTargetOption(event.target);

      if (option) {
        this.props.onOptionClick(event, {
          option
        });
      }

      event.preventDefault();
    };

    this.handleMouseOver = event => {
      if (this.blockHover) {
        return;
      }

      const option = this.findTargetOption(event.target);

      if (option && option !== this.props.highlightedOption) {
        this.props.onOptionMouseOver(event, {
          option
        });
      }
    };

    this.handleMouseMove = () => {
      this.blockHover = false;
    };

    this.handleAnimationEnd = e => {
      if (e.target !== e.currentTarget) {
        return;
      }

      !this.props.opened && this.setState({
        mounted: false
      });
    };

    this.compId = generateId(this);
    this.blockHover = false;
    this.focusedOption = null;
    this.scrollContainer = null;
    this.listRef = /*#__PURE__*/createRef();
    this.state = {
      mounted: props.opened,
      listHeight: null,
      styles: overrideStyles(baseStyles, props == null ? void 0 : (_props$__overrideStyl = props.__overrideStyles) == null ? void 0 : _props$__overrideStyl.Dropdown)
    };
  }

  static getDerivedStateFromProps(props, state) {
    var _props$__overrideStyl2;

    const styles = overrideStyles(baseStyles, props == null ? void 0 : (_props$__overrideStyl2 = props.__overrideStyles) == null ? void 0 : _props$__overrideStyl2.Dropdown);

    if (props.opened) {
      return {
        styles,
        mounted: true
      };
    }

    return {
      styles
    };
  }

  componentDidMount() {
    this.updateHeight();
    this.scrollToOption(this.focusedOption, true);
  }

  componentDidUpdate(prevProps, prevState) {
    const {
      options,
      highlightedOption,
      isScrollDisabled,
      opened
    } = this.props;
    const isJustOpened = !prevProps.opened && opened;

    if (prevProps.options !== options || prevState.mounted !== this.state.mounted) {
      this.updateHeight();
    }

    if (!isScrollDisabled && (!isSameOption(prevProps.highlightedOption, highlightedOption) || isJustOpened)) {
      this.blockHover = true;
      this.scrollToOption(this.focusedOption, isJustOpened);
    }
  }

  findTargetOption(el) {
    const list = this.listRef.current;

    if (!list) {
      return null;
    }

    while (el && el !== list) {
      var _el$dataset;

      const index = (_el$dataset = el.dataset) == null ? void 0 : _el$dataset.dropdownItemIndex;

      if (index) {
        const path = index.split('_').map(Number);
        const option = this.props.options[path.shift()];
        return path.reduce((opt, i) => opt.options[i], option);
      } // eslint-disable-next-line no-param-reassign


      el = el.parentElement;
    }

    return null;
  }

  getHeight() {
    const {
      maxHeight
    } = this.props;
    const {
      listHeight
    } = this.state;
    return listHeight && maxHeight && listHeight < maxHeight ? 'auto' : maxHeight;
  }

  scrollToOption(optionNode, centered = false) {
    if (!optionNode || !this.scrollContainer) {
      return;
    }

    const scrollRect = this.scrollContainer.getBoundingClientRect();
    const optionRect = optionNode.getBoundingClientRect();
    const isTopDirection = optionRect.top < scrollRect.top;
    const isBottomDirection = optionRect.bottom > scrollRect.bottom;

    if (isBottomDirection || isTopDirection) {
      let scrollPosition = optionNode.offsetTop;
      const heightDiff = scrollRect.height - optionRect.height;

      if (centered) {
        scrollPosition -= heightDiff / 2;
      } else if (isBottomDirection) {
        scrollPosition -= heightDiff;
      }

      this.scrollContainer.scrollTop = scrollPosition;
    }
  }

  updateHeight() {
    const listHeight = this.listRef && this.listRef.current && this.listRef.current.clientHeight;

    if (listHeight) {
      this.setState({
        listHeight
      });
    }
  }

  renderOptions(options, meta) {
    let index = 0;
    const {
      length
    } = options;
    const renderedOptions = [];
    let newMeta = meta;

    while (index < length) {
      const [nextOption, nextMeta] = this.renderOption(options[index], _extends({}, newMeta, {
        flatIndex: meta.flatIndex + 1,
        index: `${meta.index}${index}`
      }));
      renderedOptions[index] = nextOption;
      newMeta = nextMeta;
      index++;
    }

    return [renderedOptions, newMeta];
  }

  renderOption(option, meta) {
    const {
      highlightedOption,
      highlightMatch,
      dataQaType,
      size
    } = this.props;
    const {
      styles
    } = this.state;

    if (t.isGroupOption(option)) {
      const titleId = `${this.compId}-gr${meta.index}`;
      const [groupOptions, newMeta] = this.renderOptions(option.options, _extends({}, meta, {
        index: `${meta.index}_`
      }));
      const groupSize = option.size || size;
      return [/*#__PURE__*/React.createElement("div", {
        className: styles.group,
        key: option.key || meta.index,
        role: "group",
        "aria-labelledby": titleId
      }, option.title && /*#__PURE__*/React.createElement("div", {
        id: titleId,
        className: cn({
          [styles.groupTitle]: true,
          [styles[`groupTitle_size_${groupSize}`]]: styles[`groupTitle_size_${groupSize}`]
        })
      }, option.title), groupOptions), newMeta];
    }

    const highlighted = option === highlightedOption;
    const optionProps = getOptionProps(option);
    return [/*#__PURE__*/React.createElement(DropdownItem, Object.assign({
      key: `option-item-${optionProps.key}`,
      dataQaType: `${dataQaType}.item`
    }, optionProps, {
      lazy: meta.flatIndex > meta.lazyIndex,
      setRef: highlighted ? this.refFocusedItem : undefined,
      highlighted: highlighted,
      highlightMatch: highlightMatch,
      dropdownItemIndex: meta.index,
      __parentOverrideStyles: styles,
      size: typeof option === 'object' && option.size ? option.size : size
    })), _extends({}, meta, {
      lazyIndex: highlighted ? meta.flatIndex + 10 : meta.lazyIndex
    })];
  }

  render() {
    const {
      opened,
      children,
      options,
      onMouseLeave,
      minWidth,
      maxWidth,
      shadow,
      zIndex,
      cobrowsingSecure,
      highlightedOption,
      dataQaType
    } = this.props;
    const {
      mounted,
      styles
    } = this.state;

    if (!mounted) {
      return null;
    }

    return /*#__PURE__*/React.createElement("div", Object.assign({}, cobrowsingSecure ? {
      'data-cobrowsing-stub': ''
    } : {}, {
      "data-qa-type": `${dataQaType}.list`,
      onMouseMove: this.handleMouseMove,
      onAnimationEnd: this.handleAnimationEnd,
      onMouseLeave: onMouseLeave,
      className: cn({
        [styles.dropdownList]: true,
        [styles.dropdownList_open]: opened,
        [styles.dropdownList_close]: !opened,
        [styles.dropdownList_shadow]: shadow
      }),
      style: {
        height: this.getHeight(),
        zIndex,
        minWidth,
        maxWidth
      }
    }), children || /*#__PURE__*/React.createElement(Scroll, {
      scrollbarVisibility: SCROLLBAR_VISIBILITY.ALWAYS,
      setContainer: this.refScrollContainer
    }, /*#__PURE__*/React.createElement("div", {
      ref: this.listRef,
      onMouseDown: this.handleMouseDown,
      onMouseOver: this.handleMouseOver
    }, this.renderOptions(options, {
      index: '',
      flatIndex: 0,
      lazyIndex: highlightedOption ? Infinity : 10
    })[0])));
  }

}

DropdownList.defaultProps = {
  maxHeight: 254,
  zIndex: 100,
  shadow: true,
  options: [],
  onOptionClick: noop,
  onOptionMouseOver: noop,
  onMouseLeave: noop,
  cobrowsingSecure: false,
  dataQaType: 'uikit/dropdown'
};
export default DropdownList;