import _extends from "@babel/runtime/helpers/extends";
import React, { PureComponent } from 'react';
import keycode from 'keycode';
import cn from 'classnames';
import hoistStatics from 'hoist-non-react-statics';
import dataQa from '@platform-ui/dataQa';
import Popover from '@platform-ui/popover';
import overrideStyles from '@platform-ui/overrideStyles';
import DropdownList from './DropdownList';
import { flattenOptions, isSameOption, noop, renderCustomContent } from './utils';
import * as t from './types';
import baseStyles from './Dropdown.module.css';
const UP_DIRECTION = -1;
const DOWN_DIRECTION = 1;

const findInOptions = (conditionFn, options) => {
  if (!options || !options.length) {
    return;
  }

  for (let i = 0, len = options.length; i < len; i++) {
    const option = options[i];

    if (conditionFn(option)) {
      return option;
    }

    if (t.isGroupOption(option)) {
      const result = findInOptions(conditionFn, option.options);

      if (result) {
        return result;
      }
    }
  }
};

function getHighlightedOption(props) {
  return props.highlightedOption || findInOptions(option => typeof option === 'object' && option.selected, props.options);
}

export class Dropdown extends PureComponent {
  constructor(props) {
    var _props$__overrideStyl;

    super(props);

    this.handleOptionMouseOver = (event, {
      option
    }) => {
      const {
        opened,
        onOptionHighlight
      } = this.props;

      if (opened) {
        // защита от срабатывания mouseOver после handleOptionClick → залипания disabledScroll в true
        this.setState({
          highlightedOption: option,
          disabledScroll: true
        });
        onOptionHighlight && onOptionHighlight(event, {
          option
        });
      }
    };

    this.handleKeyDown = event => {
      const {
        highlightedOption
      } = this.state;
      const {
        onClose,
        onKeyDown
      } = this.props; // @ts-ignore

      switch (keycode(event)) {
        case 'esc':
          {
            onClose && onClose();
            break;
          }

        case 'up':
          {
            event.preventDefault();
            this.handleArrow(event, UP_DIRECTION);
            break;
          }

        case 'down':
          {
            event.preventDefault();
            this.handleArrow(event, DOWN_DIRECTION);
            break;
          }

        case 'enter':
          {
            if (highlightedOption) {
              event.preventDefault();
              this.selectOption(event, highlightedOption);
            }

            break;
          }
      }

      onKeyDown && onKeyDown(event);
    };

    this.handleListMouseLeave = event => {
      const {
        onOptionLeave
      } = this.props;
      this.setState({
        highlightedOption: undefined
      });
      onOptionLeave && onOptionLeave(event);
    };

    this.handleOptionClick = (e, {
      option
    }) => this.selectOption(e, option);

    this.state = {
      highlightedOption: getHighlightedOption(props),
      disabledScroll: false,
      prevOptions: props.options,
      prevOpened: props.opened,
      prevHighlightedOption: props.highlightedOption,
      styles: overrideStyles(baseStyles, props == null ? void 0 : (_props$__overrideStyl = props.__overrideStyles) == null ? void 0 : _props$__overrideStyl.Dropdown)
    };
  }

  static getDerivedStateFromProps(props, state) {
    var _props$__overrideStyl2;

    let newState = {
      styles: overrideStyles(baseStyles, props == null ? void 0 : (_props$__overrideStyl2 = props.__overrideStyles) == null ? void 0 : _props$__overrideStyl2.Dropdown)
    };

    if (!isSameOption(state.prevHighlightedOption, props.highlightedOption) || props.opened && !state.prevOpened) {
      newState = _extends({}, newState, {
        highlightedOption: getHighlightedOption(props),
        prevHighlightedOption: props.highlightedOption,
        prevOpened: props.opened
      });
    } else if (props.options !== state.prevOptions) {
      if (!findInOptions(option => option.selected && isSameOption(option, state.highlightedOption), props.options)) {
        newState = _extends({}, newState, {
          highlightedOption: undefined,
          prevOptions: props.options
        });
      }
    }

    if (state.prevOpened && !props.opened) {
      newState = _extends({}, newState, {
        highlightedOption: undefined,
        disabledScroll: false,
        prevOpened: props.opened
      });
    }

    return newState;
  }

  handleArrow(event, direction) {
    const {
      opened,
      onOptionHighlight
    } = this.props;
    const option = this.getNextOption(this.state.highlightedOption, direction);

    if (opened) {
      this.setState({
        highlightedOption: option,
        disabledScroll: false
      });
      onOptionHighlight && onOptionHighlight(event, {
        option
      });
    }
  }

  getNextOption(option, direction = DOWN_DIRECTION) {
    const options = flattenOptions(this.props.options).filter(opt => !opt.disabled);
    const isDownDirection = direction === DOWN_DIRECTION;
    const lastIndex = options.length - 1;
    const optionIndex = options.indexOf(option);

    if (optionIndex === 0 && !isDownDirection) {
      return options[lastIndex];
    }

    if (optionIndex === -1 || optionIndex === lastIndex && isDownDirection) {
      return options[0];
    }

    return options[optionIndex + direction];
  }

  selectOption(event, option) {
    const {
      closeOnSelect,
      onOptionSelect,
      onClose
    } = this.props;

    if (typeof option === 'object') {
      option.onOptionSelect && option.onOptionSelect(event, {
        value: option.value,
        option
      });
      option.selectable !== false && onOptionSelect && onOptionSelect(event, {
        value: option.value,
        option
      });

      if (closeOnSelect && option.closeOnSelect !== false) {
        onClose && onClose();
      }

      return;
    }

    onOptionSelect && onOptionSelect(null, {
      value: option,
      option
    });

    if (closeOnSelect) {
      onClose && onClose();
    }
  }

  renderCustomContent() {
    const {
      loading,
      noResults,
      noResultsContent
    } = this.props;
    const {
      styles
    } = this.state; // Стили могли быть перезаписаны через "__overrideStyles" prop, поэтому здесь они берутся из стейта

    const customStyles = {
      loader: cn(styles.customContent, styles.customContent_loader),
      noResults: cn(styles.customContent, styles.customContent_noResults)
    };
    return renderCustomContent({
      loading,
      noResults,
      noResultsContent,
      customStyles
    });
  }

  render() {
    const {
      children,
      listHeight,
      options,
      opened,
      forwardedRef,
      highlightMatch,
      id,
      loading,
      noResults,
      listMinWidth,
      listMaxWidth,
      listZIndex,
      shadow,
      cobrowsingSecure,
      dataQaType,
      smartDirection,
      align,
      onClose,
      hideOnClickOutside,
      size
    } = this.props;
    const {
      highlightedOption,
      disabledScroll,
      styles
    } = this.state;
    const customContent = this.renderCustomContent();
    return /*#__PURE__*/React.createElement(Popover, Object.assign({
      align: align,
      popoverBlock: !!(customContent || options && options.length) && /*#__PURE__*/React.createElement(DropdownList, {
        isScrollDisabled: disabledScroll,
        maxHeight: loading || noResults ? 'auto' : listHeight,
        options: options,
        highlightedOption: highlightedOption,
        highlightMatch: highlightMatch,
        opened: true,
        onMouseLeave: this.handleListMouseLeave,
        onOptionClick: this.handleOptionClick,
        onOptionMouseOver: this.handleOptionMouseOver,
        minWidth: listMinWidth,
        maxWidth: listMaxWidth,
        shadow: shadow,
        cobrowsingSecure: cobrowsingSecure,
        dataQaType: dataQaType,
        __overrideStyles: this.props.__overrideStyles,
        size: size
      }, customContent),
      smartDirection: smartDirection,
      wide: true,
      increasedTouchZone: false,
      isActive: opened,
      isInactive: !opened,
      zIndex: listZIndex
    }, hideOnClickOutside ? {
      onClose,
      disableToggleOnInsideEvents: true
    } : {}), /*#__PURE__*/React.createElement("div", Object.assign({
      className: styles.root,
      onKeyDownCapture: this.handleKeyDown,
      ref: forwardedRef,
      id: id,
      role: "listbox",
      "aria-expanded": opened
    }, dataQa(this.props)), children));
  }

}
Dropdown.defaultProps = {
  dataQaType: 'uikit/dropdown',
  listHeight: DropdownList.defaultProps.maxHeight,
  onOptionSelect: noop,
  onOptionHighlight: noop,
  onOptionLeave: noop,
  onClose: noop,
  onKeyDown: noop,
  closeOnSelect: true,
  shadow: true,
  cobrowsingSecure: false,
  smartDirection: false,
  align: 'stretch',
  noResultsContent: 'No results'
};
export default hoistStatics(Dropdown, /*#__PURE__*/React.forwardRef((props, ref) => {
  return /*#__PURE__*/React.createElement(Dropdown, Object.assign({
    forwardedRef: ref
  }, props));
}));