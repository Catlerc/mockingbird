import React from 'react';
import type * as t from './types';
/**
 * Проверяет выбрана ли опция
 *
 * @param {Array<String>|String} value Текущее значение поля
 * @param option Проверяемая опция
 * @returns {boolean}
 */
declare const isOptionSelected: (value: t.Value, option: t.Option) => boolean;
/**
 * Возвращает только выбранные элементы из массива опций
 *
 * @param {Array<Object>} options Массив опций
 * @param {Array<String>|String} value Текущее значение поля
 * @returns {Array<Object|String>|Object|String}
 */
declare const getSelectedOptions: (options: t.Options, value: t.Value) => t.Options | t.Option;
/**
 * Делает массив вложенных опций плоским
 */
declare const flattenOptions: (obj: t.Options) => any;
/**
 * Нормализует строку для более правильного сравнения
 */
declare const normalise: (value: any) => string;
/**
 * Оборачивает указанный кусок строки тегом <em>
 */
declare const highlight: (value: string, startIndex: number, length: number) => React.ReactFragment;
/**
 * Проверяет является ли значение строкой или числом
 */
declare const isSimpleValue: (value: unknown) => boolean;
/**
 * Проверяет подходит ли строка под указанную query-строку
 */
declare const filterOption: t.FilterFunction<string | t.ObjectOption>;
declare function filterOptions<T extends string | t.WithOptions<t.ObjectOption>>(options: T[], query: string, filterFunc: t.FilterFunction<T>, highlightMatch?: boolean): T[];
/**
 * Сравнивает 2 опции (по-хорошему к этому методу не нужно прибегать, если объекты данных нормально кешируются)
 */
declare const isSameOption: (opt1?: t.Option, opt2?: t.Option) => boolean;
declare const noop: () => void;
interface CustomContentProps {
    loading?: boolean;
    noResults?: boolean;
    noResultsContent: React.ReactNode;
    customStyles?: {
        loader?: string;
        noResults?: string;
    };
}
/**
 * Возвращает контент для отображения состояний DropdownList, пример:
 * `<DropdownList>{renderCustomContent({ loading, noResults, noResultsContent })}</DropdownList>`
 */
declare const renderCustomContent: ({ loading, noResults, noResultsContent, customStyles }: CustomContentProps) => JSX.Element | null;
export { getSelectedOptions, isOptionSelected, flattenOptions, filterOption, filterOptions, highlight, normalise, isSameOption, isSimpleValue, noop, renderCustomContent };
