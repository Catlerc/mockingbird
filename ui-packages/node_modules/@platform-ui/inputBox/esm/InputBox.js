import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
const _excluded = ["dataQaType", "dataQaData", "label", "children", "leftContent", "rightContent", "error", "expandable", "filled", "focused", "readOnly", "disabled", "required", "cleanable", "flatCorners", "cursor", "informationContent", "hintBlock", "onClean", "inputIcon", "labelId", "labelFor", "labelAria", "size", "valid", "counter", "scrollBar", "autofilled", "transparent", "cobrowsingSecure", "__overrideStyles", "variant"];
import React, { useCallback } from 'react';
import cn from 'classnames';
import * as corners from '@platform-ui/flatCorners';
import dataQa from '@platform-ui/dataQa';
import overrideStyles from '@platform-ui/overrideStyles';
import { Check as IconTip, Clear as IconClose } from './icons';
import baseStyles from './InputBox.module.css';

const useIsMounted = () => {
  const isMounted = React.useRef(false);
  React.useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
};

const stopEventPropagate = event => {
  event.stopPropagation();
};

const handleTooltipClick = event => {
  stopEventPropagate(event); // в некоторых случаях компонент обернут в label и нужно предотвратить поведение по умолчанию такое как изменение состояния чекбоксов

  event.preventDefault();
};

const InputBox = /*#__PURE__*/React.forwardRef((_ref, forwardedRef) => {
  let {
    dataQaType,
    dataQaData,
    label,
    children,
    leftContent,
    rightContent,
    error,
    expandable,
    filled,
    focused,
    readOnly,
    disabled,
    required,
    cleanable,
    flatCorners,
    cursor,
    informationContent,
    hintBlock,
    onClean,
    inputIcon,
    labelId,
    labelFor,
    labelAria,
    size,
    valid,
    counter,
    scrollBar,
    autofilled,
    transparent,
    cobrowsingSecure,
    __overrideStyles,
    variant = 'default'
  } = _ref,
      otherProps = _objectWithoutPropertiesLoose(_ref, _excluded);

  const showClean = !readOnly && cleanable && filled;
  const isValid = valid && !error;
  const [animated, setAnimated] = React.useState(false);
  const isMounted = useIsMounted();
  const styles = overrideStyles(baseStyles, __overrideStyles == null ? void 0 : __overrideStyles.InputBox);
  /**
   * Обходим бессмысленный ворнинг Реакта про useLayoutEffect и SSR
   * Вообще писать хуки в if - страшный грех, но конкретно в данном случае ничего страшного не произойдет,
   * т.к. на сервере он не отработает никогда, а на клиенте всегда.
   *
   * Использование useLayoutEffect в данном случае принципиально,
   * т.к. нам необходимо чтобы setAnimated отработал перед обновлением DOM
   *
   * Также выключаем правило линта, поскольку эффект должен срабатывать ТОЛЬКО при изменении focused,
   * и автофиксить зависимости ни в коем случае не нужно.
   */

  /* eslint-disable react-hooks/exhaustive-deps, react-hooks/rules-of-hooks */

  if (typeof window !== 'undefined') {
    React.useLayoutEffect(() => {
      if (isMounted.current && !filled) {
        setAnimated(true);
      }
    }, [focused]);
  }
  /* eslint-enable react-hooks/exhaustive-deps, react-hooks/rules-of-hooks */


  const handleAnimationEnd = React.useCallback(() => {
    setAnimated(false);
  }, []);
  const handleCleanerMouseDown = useCallback(event => {
    event.preventDefault();
    onClean && onClean(event);
  }, [onClean]);
  return /*#__PURE__*/React.createElement("div", Object.assign({}, otherProps, dataQa({
    dataQaType: cn(dataQaType, {
      [`${dataQaType}_required`]: required
    }),
    dataQaData
  }), {
    ref: forwardedRef,
    className: cn(styles.box, styles[variant], {
      [styles.box_error]: error,
      [styles.box_filled]: filled,
      [styles.box_focused]: focused,
      [styles.box_readOnly]: readOnly,
      [styles.box_disabled]: disabled,
      [styles.box_required]: required,
      [styles.box_expandable]: expandable,
      [styles.box_noLabel]: !label,
      [styles[`box_size_${size}`]]: size,
      [styles.box_valid]: isValid,
      [styles.box_animated]: animated,
      [styles.box_autofilled]: autofilled,
      [styles.box_transparent]: transparent
    }),
    style: _extends({}, corners.style(flatCorners), {
      cursor
    })
  }), leftContent && /*#__PURE__*/React.createElement("div", {
    className: styles.leftContent,
    "data-qa-type": `${dataQaType}.leftContent`
  }, leftContent), /*#__PURE__*/React.createElement("div", {
    className: styles.main,
    "data-qa-type": `${dataQaType}.main`
  }, label && /*#__PURE__*/React.createElement("div", {
    className: styles.labelContainer
  }, /*#__PURE__*/React.createElement("label", Object.assign({}, labelAria, {
    id: labelId,
    htmlFor: labelFor,
    className: styles.label,
    onAnimationEnd: handleAnimationEnd,
    "data-qa-type": `${dataQaType}.label`
  }), label)), /*#__PURE__*/React.createElement("div", {
    "data-qa-type": `${dataQaType}.inputContainer`,
    "data-cobrowsing-secure": cobrowsingSecure ? 'text' : undefined,
    className: styles.input
  }, children)), informationContent && /*#__PURE__*/React.createElement("div", {
    "data-qa-type": `${dataQaType}.informationContent`,
    className: styles.informationContent
  }, informationContent), (rightContent || showClean || hintBlock || inputIcon || isValid || counter) && /*#__PURE__*/React.createElement("div", {
    className: cn(styles.rightContainer, {
      [styles.rightContainer_expandable]: expandable
    }),
    "data-qa-type": `${dataQaType}.rightContainer`
  }, /*#__PURE__*/React.createElement("div", {
    className: styles.rightContent,
    "data-qa-type": `${dataQaType}.rightContent`
  }, rightContent, isValid && /*#__PURE__*/React.createElement("div", {
    className: styles.validIcon,
    "data-qa-type": `${dataQaType}.validIcon`
  }, /*#__PURE__*/React.createElement(IconTip, null)), showClean && /*#__PURE__*/React.createElement("div", {
    className: styles.liftingWrapper
  }, /*#__PURE__*/React.createElement("span", {
    className: styles.clean,
    onMouseDown: handleCleanerMouseDown,
    role: "button",
    "data-qa-type": `${dataQaType}.cleanButton`
  }, /*#__PURE__*/React.createElement(IconClose, null))), hintBlock && /*#__PURE__*/React.createElement("div", {
    tabIndex: -1,
    className: styles.liftingWrapper,
    "data-qa-type": `${dataQaType}.hintBlock`,
    onMouseDown: stopEventPropagate,
    onClick: handleTooltipClick,
    onFocus: stopEventPropagate,
    onBlur: stopEventPropagate
  }, hintBlock), inputIcon), /*#__PURE__*/React.createElement("div", {
    className: styles.counter,
    "data-qa-type": `${dataQaType}.counter`
  }, counter)), scrollBar && /*#__PURE__*/React.createElement("div", {
    className: styles.scrollBar,
    "data-qa-type": `${dataQaType}.scrollBar`
  }, scrollBar));
});
InputBox.defaultProps = {
  dataQaType: 'uikit/inputBox',
  size: 'l'
}; // TODO: разобраться как подружить сборку TS и displayName

InputBox.displayName = 'InputBox';
export default InputBox;