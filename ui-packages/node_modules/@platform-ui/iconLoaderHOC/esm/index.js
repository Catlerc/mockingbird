import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
const _excluded = ["iconPath", "fallbackBlock"];
import React, { useEffect, useRef, useState } from 'react';
import { registryIcon, getIcon, getFileName, beautify, loadIcon, isAbsoluteUrl, getLoaderForIconPath } from './registry';
const serverIconPlaceholder = '';

const cacheAndGetBack = (id, icon) => {
  registryIcon(id, icon);
  return icon;
};

const isBrowser = () => typeof window !== 'undefined' && 'document' in window;

const getFileInPath = (id, iconPathOrContent) => {
  if (process.env.SERVER) {
    // для сервера и браузера разные способы получения иконки
    if (isAbsoluteUrl(iconPathOrContent)) {
      loadIcon(iconPathOrContent);
      return serverIconPlaceholder;
    }

    const iconContent = beautify(iconPathOrContent);
    return cacheAndGetBack(id, iconContent);
  }

  if (isBrowser()) {
    const element = document.querySelector(`[data-svg-id="${id}"]`); // мы проверяем, что сервер отрендерил иконку и мы можем просто получить код иконки

    if (!element) {
      return false; // если нет иконки, то значит это не ssr и мы должны сами скачать
    }

    let children = element.innerHTML;

    if (children === undefined) {
      // -_- ie не умеет в innerHTML у svg
      children = beautify(new XMLSerializer().serializeToString(element));
    }

    return cacheAndGetBack(id, children);
  }
};

const getFileIcon = (id, iconPath) => {
  if (process.env.NODE_ENV === 'test') {
    // при юнит-тестировании должно быть все равно на иконки
    return false;
  }

  if (getIcon(id)) {
    // если есть в кэше, то отдаем сразу же
    return getIcon(id);
  }

  return getFileInPath(id, iconPath);
};

export default (Icon => function WithIconLoader(_ref) {
  let {
    iconPath,
    fallbackBlock
  } = _ref,
      otherProps = _objectWithoutPropertiesLoose(_ref, _excluded);

  const [id, setId] = useState(getFileName(iconPath));
  const [mounted, setMounted] = useState(false);
  const [icon, setIcon] = useState(getFileIcon(id, iconPath));
  const [notLoaded, setNotLoaded] = useState(false);
  const loader = getLoaderForIconPath(iconPath);
  const prevPath = useRef('');

  if (loader) {
    loader.then(i => i !== icon && setIcon(i)).catch(() => setIcon(''));
  }

  useEffect(() => {
    if (id && iconPath) {
      const i = getFileIcon(id, iconPath);
      i && setIcon(i);
    }

    setMounted(true);
    return () => {
      setMounted(false);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  useEffect(() => {
    if (prevPath.current !== iconPath) {
      setId(getFileName(iconPath));
      loadIcon(iconPath).then(i => {
        if (mounted) {
          setIcon(i);
        }
      }).catch(() => {
        setNotLoaded(true);
      });
    }

    prevPath.current = iconPath;
  }, [icon, iconPath, mounted]);

  if (notLoaded && fallbackBlock) {
    return fallbackBlock;
  }

  return icon ? /*#__PURE__*/React.createElement(Icon, Object.assign({}, otherProps, {
    svgCode: icon,
    dataSvgId: id
  })) : /*#__PURE__*/React.createElement("div", {
    style: {
      width: otherProps.width || otherProps.size || otherProps.containerSize || otherProps.iconSize,
      height: otherProps.height || otherProps.size || otherProps.containerSize || otherProps.iconSize
    }
  });
});