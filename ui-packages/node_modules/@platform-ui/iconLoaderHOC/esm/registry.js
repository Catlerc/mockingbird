// @ts-ignore
import fileLoader from '@platform-ui/utils/fileLoader';
import startsWith from '@tinkoff/utils/string/startsWith';
const icons = {};
const loaders = Object.create(null);

const isAbsoluteUrl = str => ['http://', 'https://', '//'].some(prefix => startsWith(prefix, str));

const registryIcon = (id, icon) => {
  icons[id] = icon;
};

const getIcon = id => icons[id];

const beautify = text => text.replace(/[\t\n\r]+/g, '');

const getFileName = iconPathOrContent => {
  const svgFileNameRE = /[\w-]+\.svg/;
  const matches = iconPathOrContent.match(svgFileNameRE);
  const svgFileName = matches ? matches[0] : undefined;

  if (isAbsoluteUrl(iconPathOrContent)) {
    return svgFileName;
  }

  if (process.env.SERVER) {
    /*
     * ATTENTION! Ожидаем, при сборке у пользователя иконок для браузера - имя файла === md5 hash от контента файла
     * (механизм по умолчанию у webpack file-loader)
     * За счет этого результирующее  имя файла одной икони будет одинаковым на клиенте и сервере
     * (используется далее в атрибуте data-svg-id)
     * - иначе это будет вест к лишним загрузкам и перерендерам.
     * Но таким образом создается неявная связь со сборщиком платформенным :(
     */
    const md5 = require('spark-md5').hash;

    return `${md5(iconPathOrContent)}.svg`;
  }

  return svgFileName;
};

const loadIcon = iconPathOrContent => {
  const id = getFileName(iconPathOrContent);

  if (id && icons[id]) {
    return Promise.resolve(icons[id]);
  }

  loaders[iconPathOrContent] = loaders[iconPathOrContent] || fileLoader(iconPathOrContent);
  return loaders[iconPathOrContent].then(payload => {
    const icon = beautify(payload);
    registryIcon(id, icon);
    return icon;
  });
};

const getLoaderForIconPath = iconPath => loaders[iconPath];

export { registryIcon, getIcon, loadIcon, beautify, getFileName, getLoaderForIconPath, isAbsoluteUrl };