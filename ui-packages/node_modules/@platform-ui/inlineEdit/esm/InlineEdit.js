import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
const _excluded = ["dataQaType", "dataQaData", "iconSize", "value", "hasIcon", "width", "maxLength", "onChange", "onBlur", "onFocus", "onKeyDown"];
import React, { useState, useRef, useLayoutEffect, useEffect } from 'react';
import cn from 'classnames';
import { Int16Edit, Int24Edit } from '@platform-ui/iconsPack';
import dataQa from '@platform-ui/dataQa';
import isString from '@tinkoff/utils/is/string';
import styles from './InlineEdit.module.css';
const ICONS = {
  m: Int16Edit,
  l: Int24Edit
};
export function getClipboardDataText(event) {
  return 'clipboardData' in event ? event.clipboardData && event.clipboardData.getData('text/plain').normalize() : event.target.ownerDocument.defaultView.clipboardData.getData('text');
}

const setSelection = node => {
  const selection = window.getSelection();
  const range = document.createRange();
  range.selectNodeContents(node);
  range.collapse(false);

  if (selection) {
    selection.removeAllRanges();
    selection.addRange(range);
  }

  node.focus();
};

const getContent = node => isString(node == null ? void 0 : node.textContent) ? node == null ? void 0 : node.textContent : node == null ? void 0 : node.innerText;

function InlineEdit(_ref) {
  let {
    dataQaType = 'uikit/inlineEdit',
    dataQaData,
    iconSize = 'm',
    value = '',
    hasIcon = true,
    width,
    maxLength,
    onChange,
    onBlur,
    onFocus,
    onKeyDown
  } = _ref,
      otherProps = _objectWithoutPropertiesLoose(_ref, _excluded);

  const [editable, setEditable] = useState(false);
  const controlRef = useRef(null);
  const Icon = ICONS[iconSize];

  const handleClick = () => {
    setEditable(true);
  };

  const handleBlur = event => {
    setEditable(false);
    onBlur && onBlur(event);
  };

  const handleFocus = event => {
    controlRef.current && setSelection(controlRef.current);
    onFocus && onFocus(event);
  };

  const handleChange = event => {
    const newValue = controlRef.current && getContent(controlRef.current) || value;
    let maxLengthError = false;

    if (maxLength) {
      maxLengthError = (newValue == null ? void 0 : newValue.length) > maxLength;
    }

    onChange && onChange(event, {
      value: newValue,
      errors: {
        maxLengthError
      }
    });
  };

  const handleKeyDown = event => {
    const enterKey = event.key === 'Enter';
    const escapeKey = event.key === 'Escape';

    if (enterKey || escapeKey) {
      var _controlRef$current;

      event.preventDefault();
      setEditable(false);
      (_controlRef$current = controlRef.current) == null ? void 0 : _controlRef$current.blur();
    }

    onKeyDown && onKeyDown(event);
  };

  const handlePaste = event => {
    event.preventDefault();
    const content = getClipboardDataText(event);
    document.execCommand('insertText', false, content);
    document.execCommand('paste', false, content);
  };

  const handleDrop = event => {
    event.preventDefault();
  };

  useEffect(() => {
    const control = controlRef.current;

    if (control) {
      control.addEventListener('paste', handlePaste);
      control.addEventListener('drop', handleDrop);
      return () => {
        control.removeEventListener('paste', handlePaste);
        control.removeEventListener('drop', handleDrop);
      };
    }
  });
  useEffect(() => {
    if (controlRef.current) {
      controlRef.current.innerText = value;
      setSelection(controlRef.current);
    }
  }, [value]);
  useLayoutEffect(() => {
    if (editable) {
      var _controlRef$current2;

      (_controlRef$current2 = controlRef.current) == null ? void 0 : _controlRef$current2.focus();
    }
  }, [editable]);
  return /*#__PURE__*/React.createElement("span", Object.assign({}, dataQa({
    dataQaType,
    dataQaData
  }), {
    className: cn({
      [styles.root]: true,
      [styles.root_editable]: editable,
      [styles[`root_iconSize_${iconSize}`]]: true
    }),
    style: {
      width
    },
    onClick: handleClick
  }), /*#__PURE__*/React.createElement("span", Object.assign({}, otherProps, dataQa({
    dataQaType: `${dataQaType}.input`
  }), {
    className: styles.input,
    ref: controlRef,
    contentEditable: editable,
    suppressContentEditableWarning: true,
    onBlur: handleBlur,
    onFocus: handleFocus,
    onInput: handleChange,
    onKeyDown: handleKeyDown
  })), hasIcon && /*#__PURE__*/React.createElement("span", Object.assign({}, dataQa({
    dataQaType: `${dataQaType}.icon`
  }), {
    className: cn(styles.iconWrapper, {
      [styles.iconSize_l]: iconSize === 'l'
    })
  }), /*#__PURE__*/React.createElement(Icon, {
    verticalAlign: "middle",
    cursor: "pointer"
  })));
}

export default InlineEdit;