import _extends from "@babel/runtime/helpers/extends";
// based on https://github.com/pawelgrzybek/siema
import React, { PureComponent } from 'react';
import dataQa from '@platform-ui/dataQa';
import noop from '@tinkoff/utils/function/noop';
import range from '@tinkoff/utils/array/range';
import maxBy from '@tinkoff/utils/array/maxBy';
import cn from 'classnames';
import styles from './Carousel.module.css';
let documentLocal;

try {
  documentLocal = document;
} catch (e) {
  documentLocal = {
    addEventListener: noop,
    removeEventListener: noop
  };
}

const TOUCH_EVENTS = {
  start: 'touchstart',
  move: 'touchmove',
  end: 'touchend'
};
const MOUSE_EVENTS = {
  start: 'mousedown',
  move: 'mousemove',
  end: 'mouseup'
};

function getMathSign(x) {
  // Math.sing crossbrowse
  const num = +x; // eslint-disable-next-line no-restricted-globals

  if (num === 0 || isNaN(num)) {
    return num;
  }

  return num > 0 ? 1 : -1;
}

function clamp(min, max, value) {
  return Math.max(min, Math.min(value, max));
}

function elasticClamp(min, max, value, coeff = 0.25) {
  const from = clamp(min, max, value);
  return from - (from - value) * coeff;
}

function getShorterDirection(fromIndex, toIndex, length) {
  const start = fromIndex || length;
  const end = toIndex % length;
  const clearDiff = end - start;
  const loopDiff = clearDiff + length;
  const diff = Math.abs(clearDiff) <= Math.abs(loopDiff) ? clearDiff : loopDiff;
  return getMathSign(diff);
}

function getChildrenLength(children) {
  if (!children) return 0;
  if (Array.isArray(children)) return children.length;
  return 1;
}

function childrenToArray(children) {
  if (!children) return [];
  if (Array.isArray(children)) return children;
  return [children];
}

function isTouchEvent(event) {
  return !!event.touches;
}

class Slider extends PureComponent {
  constructor(props) {
    super(props);
    this.container = /*#__PURE__*/React.createRef();
    this.sliderFrame = /*#__PURE__*/React.createRef();
    this.items = void 0;
    this.refMemo = void 0;
    this.currentIndex = void 0;
    this.elemWidth = void 0;
    this.moving = void 0;
    this.dragging = void 0;
    this.drag = void 0;

    this.setRef = refName => {
      if (!this.refMemo[refName]) {
        this.refMemo[refName] = element => {
          this.items[refName] = element;
        };
      }

      return this.refMemo[refName];
    };

    this.handleTransitionEnd = () => {
      this.moving = false;
    };

    this.handleResize = () => {
      if (!this.sliderFrame.current) {
        return;
      }

      const {
        perPage
      } = this.props;
      this.elemWidth = this.sliderFrame.current.getBoundingClientRect().width / perPage;
      this.setContainerHeight();
    };

    this.handleStart = e => {
      const coords = isTouchEvent(e) ? e.touches[0] : e;
      this.dragging = true;
      this.drag.start = coords.pageX;
      this.drag.startY = coords.pageY;
      this.updateAriaHiddenOfElems();
      /**
       * Делаем preventDefault на десктопе чтобы предотвратить изменение курсора в Safari
       * На мобилках этого делать нельзя, т.к. перестают работать ссылки и др. элементы внутри карусели
       */

      if (!isTouchEvent(e)) {
        e.preventDefault();
      }

      documentLocal.addEventListener(TOUCH_EVENTS.move, this.handleMove, {
        passive: false
      });
      documentLocal.addEventListener(TOUCH_EVENTS.end, this.handleEnd);
      documentLocal.addEventListener(MOUSE_EVENTS.move, this.handleMove);
      documentLocal.addEventListener(MOUSE_EVENTS.end, this.handleEnd);
    };

    this.handleMove = e => {
      const isTouch = isTouchEvent(e);
      const coords = isTouchEvent(e) ? e.touches[0] : e;
      const shift = this.drag.start - coords.pageX;

      if (!this.drag.direction) {
        this.drag.direction = Math.abs(this.drag.startY - coords.pageY) > Math.abs(shift) ? 'vertical' : 'horizontal';
      } // не меняем слайды при вертикальном перетаскивании на тачах


      if (isTouch && this.drag.direction === 'vertical') {
        this.handleEnd();
        return;
      } // блочим вертикальный скролл, если скроллим по горизонтали


      if (isTouch) {
        e.preventDefault();
      }

      this.drag.end = coords.pageX; // @ts-ignore

      this.sliderFrame.current.style.cursor = 'grabbing';
      this.toggleFrameTransition(false);
      this.setFramePosition(this.normalizePosition(this.currentIndex + shift / this.elemWidth));
    };

    this.handleEnd = () => {
      // @ts-ignore
      this.sliderFrame.current.style.cursor = null;

      if (this.drag.end && this.drag.start !== this.drag.end) {
        this.updateAfterDrag();
      }

      this.clearDrag();
      this.updateAriaHiddenOfElems();
      documentLocal.removeEventListener(TOUCH_EVENTS.end, this.handleEnd);
      documentLocal.removeEventListener(TOUCH_EVENTS.move, this.handleMove);
      documentLocal.removeEventListener(MOUSE_EVENTS.end, this.handleEnd);
      documentLocal.removeEventListener(MOUSE_EVENTS.move, this.handleMove);
    };

    this.refMemo = {};
    this.currentIndex = props.startIndex;
    this.drag = {};
    this.items = {};
    this.clearDrag();
    this.state = {
      preview: true
    };
  }

  componentDidMount() {
    // eslint-disable-next-line react/no-did-mount-set-state
    this.setState({
      preview: false
    });
  } // eslint-disable-next-line complexity, max-statements


  componentDidUpdate(prevProps, prevState) {
    const currentChildrenLength = getChildrenLength(prevProps.children);
    const prevChildrenLength = getChildrenLength(this.props.children);
    const changed = ['autoHeight', 'perPage', 'draggable', 'startIndex'].reduce((acc, propName) => _extends({}, acc, {
      [propName]: this.props[propName] !== prevProps[propName]
    }), {
      previewState: prevState.preview !== this.state.preview,
      childrenLength: prevChildrenLength !== currentChildrenLength
    });

    if (changed.previewState || changed.perPage || changed.autoHeight || changed.childrenLength) {
      this.handleResize();
      this.toggleFrameTransition(false);
      this.setFramePosition(this.normalizePosition(this.currentIndex));
    }

    if (changed.startIndex) {
      const dir = getShorterDirection(this.currentIndex, this.props.startIndex, currentChildrenLength);
      this.translate(this.currentIndex, this.props.startIndex, dir);
    }

    if (changed.previewState) {
      window.addEventListener('resize', this.handleResize);
    }

    if (changed.previewState || changed.perPage || changed.draggable || changed.childrenLength) {
      if (this.props.draggable && currentChildrenLength > this.props.perPage) {
        var _this$container$curre, _this$container$curre2;

        (_this$container$curre = this.container.current) == null ? void 0 : _this$container$curre.addEventListener(TOUCH_EVENTS.start, this.handleStart);
        (_this$container$curre2 = this.container.current) == null ? void 0 : _this$container$curre2.addEventListener(MOUSE_EVENTS.start, this.handleStart);
      } else {
        var _this$container$curre3, _this$container$curre4;

        (_this$container$curre3 = this.container.current) == null ? void 0 : _this$container$curre3.removeEventListener(TOUCH_EVENTS.start, this.handleStart);
        (_this$container$curre4 = this.container.current) == null ? void 0 : _this$container$curre4.removeEventListener(MOUSE_EVENTS.start, this.handleStart);
      }
    }
  }

  componentWillUnmount() {
    var _this$container$curre5, _this$container$curre6;

    window.removeEventListener('resize', this.handleResize);
    (_this$container$curre5 = this.container.current) == null ? void 0 : _this$container$curre5.removeEventListener(TOUCH_EVENTS.start, this.handleStart);
    documentLocal.removeEventListener(TOUCH_EVENTS.end, this.handleEnd);
    documentLocal.removeEventListener(TOUCH_EVENTS.move, this.handleMove);
    (_this$container$curre6 = this.container.current) == null ? void 0 : _this$container$curre6.removeEventListener(MOUSE_EVENTS.start, this.handleStart);
    documentLocal.removeEventListener(MOUSE_EVENTS.end, this.handleEnd);
    documentLocal.removeEventListener(MOUSE_EVENTS.move, this.handleMove);
  }

  // eslint-disable-next-line max-statements
  getChildren() {
    const {
      children,
      perPage,
      loop,
      stagePadding,
      startIndex,
      autoHeight
    } = this.props;
    const {
      preview
    } = this.state;

    if (getChildrenLength(children) <= perPage) {
      return children;
    }

    const childrenArray = childrenToArray(children);
    const ch = loop ? [...childrenArray.slice(-perPage - 1), ...childrenArray, ...childrenArray.slice(0, perPage + 1)] : childrenArray;

    if (preview && autoHeight) {
      let start = startIndex;
      let end = startIndex + perPage;

      if (loop) {
        start += perPage + 1;
        end += perPage + 1;
      }

      if (stagePadding) {
        start = Math.max(start - 1, 0);
        end += 1;
      }

      return ch.map((child, index) => index < start || index > end ? null : child);
    }

    return ch;
  }

  getCycledIndex(index) {
    const {
      children
    } = this.props;
    return index % getChildrenLength(children) + (index < 0 ? getChildrenLength(children) : 0);
  }

  getSlideStep() {
    return this.props.slideStep || this.props.perPage - 1 || 1;
  }

  getItemStyles(index) {
    const {
      animateHiding,
      hideInvisibleSlides,
      perPage,
      easing
    } = this.props;
    const {
      moving
    } = this;
    const hidden = this.isElemHidden(index);
    const visibility = hidden && !moving ? 'hidden' : 'visible';
    return hideInvisibleSlides ? {
      visibility,
      opacity: hideInvisibleSlides && hidden ? 0 : 1,
      transition: animateHiding ? `opacity ${100 / perPage * 0.01}s ${easing}` : undefined
    } : {
      visibility
    };
  }

  getTransform(position) {
    const {
      perPage,
      loop,
      children
    } = this.props;
    let pos = position;

    if (getChildrenLength(children) <= perPage) {
      return 'none';
    }

    if (loop) {
      pos += perPage + 1;
    }

    return `translate3d(${-100 * pos / perPage}%, 0, 0)`;
  }

  isElemHidden(i, position) {
    const {
      perPage,
      loop,
      margin,
      stagePadding,
      children,
      hideInvisibleSlides
    } = this.props;
    const currentIndex = !position && position !== 0 ? this.currentIndex : position;
    const offset = loop && getChildrenLength(children) > perPage ? perPage + 1 : 0;
    let leftSlide = currentIndex + offset;
    let rightSlide = leftSlide + perPage - 1;

    if (!hideInvisibleSlides && stagePadding && stagePadding > margin) {
      rightSlide += 1;

      if (loop || leftSlide - i >= 0) {
        leftSlide -= 1;
      }
    }

    return leftSlide <= i && rightSlide >= i ? undefined : true;
  }

  normalizePosition(pos) {
    const {
      children,
      perPage,
      elastic,
      loop
    } = this.props;

    if (!loop) {
      const from = 0;
      const to = getChildrenLength(children) - perPage;
      return elastic ? elasticClamp(from, to, pos) : clamp(from, to, pos);
    }

    return this.getCycledIndex(pos);
  }

  translate(from, to, dir) {
    const {
      loop,
      onSlide,
      elastic,
      perPage
    } = this.props;
    this.moving = true;
    let translateFrom = this.normalizePosition(from);
    let translateTo = this.normalizePosition(to);
    translateTo = elastic && !loop ? clamp(0, getChildrenLength(this.getChildren()) - perPage, translateTo) : translateTo;

    if (loop && getMathSign(translateTo - translateFrom) !== dir) {
      translateFrom -= getChildrenLength(this.props.children) * dir;
    }

    this.toggleFrameTransition(false);
    this.toggleElemsTransition(false);
    this.setFramePosition(translateFrom);
    /**
     * [UIKIT-5559]
     * Дожидаемся установки стилей для начальной позиции без анимации с помощью requestAnimationFrame,
     * затем анимируем переход
     */

    window.requestAnimationFrame(() => {
      if (translateTo !== this.currentIndex) {
        this.currentIndex = translateTo;
        this.setContainerHeight();
      }

      this.toggleFrameTransition(true);
      this.toggleElemsTransition(true);
      this.setFramePosition(translateTo);
      onSlide(translateTo);
    });
  }

  setFramePosition(position) {
    if (!this.sliderFrame) {
      return;
    }

    const transform = this.getTransform(position); // @ts-ignore

    this.sliderFrame.current.style.transform = transform; // @ts-ignore

    this.sliderFrame.current.style.WebkitTransform = transform;
    this.updateAriaHiddenOfElems(position);
  }

  clearDrag() {
    this.dragging = false;
    this.drag = {
      start: 0,
      end: 0,
      direction: null,
      startY: 0
    };
  }

  setContainerHeight() {
    if (!this.container) {
      return;
    }

    const {
      autoHeight,
      perPage
    } = this.props;

    if (!autoHeight) {
      // @ts-ignore
      this.container.current.style.height = 'auto';
      return;
    }

    const mH = range(this.currentIndex, this.currentIndex + perPage).reduce((maxHeight, index) => {
      const itemIndex = this.props.loop ? this.getCycledIndex(index) + perPage + 1 : index;
      /**
       * Если у нас perPage больше чем количество слайдов,
       * например, perPage 3, а видимых слайдов только 2, то мы тут обращаемся
       * к несуществующему элементу. В таком случае возвращаем
       * максимальнкую высоту среди всех слайдов
       */

      if (!this.items[`item-${itemIndex}`]) {
        return maxBy(i => i, childrenToArray(this.getChildren()).map((_, i) => this.items[`item-${i}`].getBoundingClientRect().height));
      }

      const {
        height
      } = this.items[`item-${itemIndex}`].getBoundingClientRect();
      return Math.max(maxHeight, height);
    }, 0); // @ts-ignore

    this.container.current.style.height = `${mH}px`;
  } // Recalculate drag /swipe event and reposition the frame of a slider


  updateAfterDrag() {
    const {
      threshold,
      loop
    } = this.props;
    const movement = this.drag.start - this.drag.end;
    const relativeMovement = movement / this.elemWidth;
    const from = this.currentIndex + relativeMovement;
    const to = this.currentIndex + parseInt(`${relativeMovement}`, 10) + (Math.abs(movement % this.elemWidth) > threshold ? getMathSign(movement) : 0);
    const dir = getMathSign(to - from);

    if (loop || to !== -1 && to !== getChildrenLength(this.getChildren())) {
      this.props.onDragEnd();
    }

    this.translate(from, to, dir);
  }

  prev() {
    this.translate(this.currentIndex, this.currentIndex - this.getSlideStep(), -1);
  }

  next() {
    this.translate(this.currentIndex, this.currentIndex + this.getSlideStep(), 1);
  }

  toggleFrameTransition(enabled) {
    if (!this.sliderFrame) {
      return;
    }

    const {
      duration,
      easing
    } = this.props;
    const val = `transform ${enabled ? duration : 0}ms ${easing}`; // @ts-ignore

    this.sliderFrame.current.style.WebkitTransition = val; // @ts-ignore

    this.sliderFrame.current.style.transition = val;
  }

  toggleElemsTransition(enabled) {
    const len = getChildrenLength(this.getChildren());

    for (let i = 0; i < len; i++) {
      const item = this.items[`item-${i}`];
      const transition = enabled ? this.getItemStyles(i).transition : null;
      item.style.webkitTransition = transition || '';
      item.style.transition = transition || '';
    }
  }

  updateAriaHiddenOfElems(position) {
    const {
      hideInvisibleSlides
    } = this.props;
    const len = getChildrenLength(this.getChildren());

    for (let i = 0; i < len; i++) {
      const item = this.items[`item-${i}`];
      const hidden = this.isElemHidden(i, position);
      const beforeVisible = this.dragging && hidden && !this.isElemHidden(i + 1, position);
      const afterVisible = this.dragging && hidden && !this.isElemHidden(i - 1, position);

      if (beforeVisible) {
        item.removeAttribute('aria-hidden');
        item.style.visibility = 'visible';

        if (position !== undefined && hideInvisibleSlides) {
          item.style.opacity = `${1 - position + Math.floor(position)}`;
        }
      } else if (afterVisible) {
        item.removeAttribute('aria-hidden');
        item.style.visibility = 'visible';

        if (position !== undefined && hideInvisibleSlides) {
          item.style.opacity = `${position - Math.floor(position)}`;
        }
      } else if (hidden) {
        item.setAttribute('aria-hidden', 'true');
        item.style.visibility = this.moving || this.dragging ? 'visible' : 'hidden';
        item.style.opacity = hideInvisibleSlides && !this.dragging ? '0' : '1';
      } else {
        item.removeAttribute('aria-hidden');
        item.style.visibility = 'visible';
        item.style.opacity = hideInvisibleSlides ? '1' : '';
      }
    }
  }

  render() {
    const {
      margin,
      autoHeight,
      duration,
      easing,
      stagePadding,
      perPage,
      startIndex,
      dataQaType,
      containerOverflow = 'hidden',
      borderRadius
    } = this.props;
    const {
      preview
    } = this.state;
    const transition = autoHeight ? `height ${duration}ms ${easing}` : undefined;
    let transform;

    if (preview) {
      const position = this.normalizePosition(startIndex);
      transform = this.getTransform(position);
    }

    return /*#__PURE__*/React.createElement("div", {
      style: {
        padding: `0 ${stagePadding}px`,
        WebkitTransition: transition,
        transition,
        overflow: containerOverflow,
        borderRadius
      },
      ref: this.container
    }, /*#__PURE__*/React.createElement("ul", Object.assign({}, dataQa({
      dataQaType: `${dataQaType}.frame`
    }), {
      ref: this.sliderFrame,
      className: cn({
        [styles.sliderFrame]: true,
        [styles.sliderFrame_stretch]: !autoHeight
      }),
      style: {
        marginRight: -margin,
        WebkitTransform: transform,
        transform
      },
      onTransitionEnd: this.handleTransitionEnd
    }), childrenToArray(this.getChildren()).map((child, i) => /*#__PURE__*/React.createElement("li", Object.assign({}, dataQa({
      dataQaType: `${dataQaType}.item`
    }), {
      ref: this.setRef(`item-${i}`),
      className: styles.item,
      "aria-hidden": this.isElemHidden(i),
      "data-key": `item-${i}`
      /* eslint-disable-next-line react/no-array-index-key */
      ,
      key: `item-${i}`,
      style: _extends({
        minWidth: `${100 / perPage}%`,
        paddingRight: margin
      }, this.getItemStyles(i))
    }), child))));
  }

}

Slider.defaultProps = {
  duration: 400,
  easing: 'ease',
  perPage: 1,
  startIndex: 0,
  draggable: true,
  threshold: 150,
  loop: false,
  onSlide: noop,
  children: [],
  margin: 0,
  stagePadding: 0,
  autoHeight: false,
  slideStep: null,
  elastic: false,
  onDragEnd: noop
};
export default Slider;