"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

exports.__esModule = true;
exports.default = void 0;

var _extends3 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _react = _interopRequireWildcard(require("react"));

var _dataQa = _interopRequireDefault(require("@platform-ui/dataQa"));

var _noop = _interopRequireDefault(require("@tinkoff/utils/function/noop"));

var _range = _interopRequireDefault(require("@tinkoff/utils/array/range"));

var _maxBy = _interopRequireDefault(require("@tinkoff/utils/array/maxBy"));

var _classnames = _interopRequireDefault(require("classnames"));

var _CarouselModule = _interopRequireDefault(require("./Carousel.module.css"));

// based on https://github.com/pawelgrzybek/siema
var documentLocal;

try {
  documentLocal = document;
} catch (e) {
  documentLocal = {
    addEventListener: _noop.default,
    removeEventListener: _noop.default
  };
}

var TOUCH_EVENTS = {
  start: 'touchstart',
  move: 'touchmove',
  end: 'touchend'
};
var MOUSE_EVENTS = {
  start: 'mousedown',
  move: 'mousemove',
  end: 'mouseup'
};

function getMathSign(x) {
  // Math.sing crossbrowse
  var num = +x; // eslint-disable-next-line no-restricted-globals

  if (num === 0 || isNaN(num)) {
    return num;
  }

  return num > 0 ? 1 : -1;
}

function clamp(min, max, value) {
  return Math.max(min, Math.min(value, max));
}

function elasticClamp(min, max, value, coeff) {
  if (coeff === void 0) {
    coeff = 0.25;
  }

  var from = clamp(min, max, value);
  return from - (from - value) * coeff;
}

function getShorterDirection(fromIndex, toIndex, length) {
  var start = fromIndex || length;
  var end = toIndex % length;
  var clearDiff = end - start;
  var loopDiff = clearDiff + length;
  var diff = Math.abs(clearDiff) <= Math.abs(loopDiff) ? clearDiff : loopDiff;
  return getMathSign(diff);
}

function getChildrenLength(children) {
  if (!children) return 0;
  if (Array.isArray(children)) return children.length;
  return 1;
}

function childrenToArray(children) {
  if (!children) return [];
  if (Array.isArray(children)) return children;
  return [children];
}

function isTouchEvent(event) {
  return !!event.touches;
}

var Slider = /*#__PURE__*/function (_PureComponent) {
  (0, _inheritsLoose2.default)(Slider, _PureComponent);

  function Slider(props) {
    var _this;

    _this = _PureComponent.call(this, props) || this;
    _this.container = /*#__PURE__*/_react.default.createRef();
    _this.sliderFrame = /*#__PURE__*/_react.default.createRef();
    _this.items = void 0;
    _this.refMemo = void 0;
    _this.currentIndex = void 0;
    _this.elemWidth = void 0;
    _this.moving = void 0;
    _this.dragging = void 0;
    _this.drag = void 0;

    _this.setRef = function (refName) {
      if (!_this.refMemo[refName]) {
        _this.refMemo[refName] = function (element) {
          _this.items[refName] = element;
        };
      }

      return _this.refMemo[refName];
    };

    _this.handleTransitionEnd = function () {
      _this.moving = false;
    };

    _this.handleResize = function () {
      if (!_this.sliderFrame.current) {
        return;
      }

      var perPage = _this.props.perPage;
      _this.elemWidth = _this.sliderFrame.current.getBoundingClientRect().width / perPage;

      _this.setContainerHeight();
    };

    _this.handleStart = function (e) {
      var coords = isTouchEvent(e) ? e.touches[0] : e;
      _this.dragging = true;
      _this.drag.start = coords.pageX;
      _this.drag.startY = coords.pageY;

      _this.updateAriaHiddenOfElems();
      /**
       * Делаем preventDefault на десктопе чтобы предотвратить изменение курсора в Safari
       * На мобилках этого делать нельзя, т.к. перестают работать ссылки и др. элементы внутри карусели
       */


      if (!isTouchEvent(e)) {
        e.preventDefault();
      }

      documentLocal.addEventListener(TOUCH_EVENTS.move, _this.handleMove, {
        passive: false
      });
      documentLocal.addEventListener(TOUCH_EVENTS.end, _this.handleEnd);
      documentLocal.addEventListener(MOUSE_EVENTS.move, _this.handleMove);
      documentLocal.addEventListener(MOUSE_EVENTS.end, _this.handleEnd);
    };

    _this.handleMove = function (e) {
      var isTouch = isTouchEvent(e);
      var coords = isTouchEvent(e) ? e.touches[0] : e;
      var shift = _this.drag.start - coords.pageX;

      if (!_this.drag.direction) {
        _this.drag.direction = Math.abs(_this.drag.startY - coords.pageY) > Math.abs(shift) ? 'vertical' : 'horizontal';
      } // не меняем слайды при вертикальном перетаскивании на тачах


      if (isTouch && _this.drag.direction === 'vertical') {
        _this.handleEnd();

        return;
      } // блочим вертикальный скролл, если скроллим по горизонтали


      if (isTouch) {
        e.preventDefault();
      }

      _this.drag.end = coords.pageX; // @ts-ignore

      _this.sliderFrame.current.style.cursor = 'grabbing';

      _this.toggleFrameTransition(false);

      _this.setFramePosition(_this.normalizePosition(_this.currentIndex + shift / _this.elemWidth));
    };

    _this.handleEnd = function () {
      // @ts-ignore
      _this.sliderFrame.current.style.cursor = null;

      if (_this.drag.end && _this.drag.start !== _this.drag.end) {
        _this.updateAfterDrag();
      }

      _this.clearDrag();

      _this.updateAriaHiddenOfElems();

      documentLocal.removeEventListener(TOUCH_EVENTS.end, _this.handleEnd);
      documentLocal.removeEventListener(TOUCH_EVENTS.move, _this.handleMove);
      documentLocal.removeEventListener(MOUSE_EVENTS.end, _this.handleEnd);
      documentLocal.removeEventListener(MOUSE_EVENTS.move, _this.handleMove);
    };

    _this.refMemo = {};
    _this.currentIndex = props.startIndex;
    _this.drag = {};
    _this.items = {};

    _this.clearDrag();

    _this.state = {
      preview: true
    };
    return _this;
  }

  var _proto = Slider.prototype;

  _proto.componentDidMount = function componentDidMount() {
    // eslint-disable-next-line react/no-did-mount-set-state
    this.setState({
      preview: false
    });
  } // eslint-disable-next-line complexity, max-statements
  ;

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var _this2 = this;

    var currentChildrenLength = getChildrenLength(prevProps.children);
    var prevChildrenLength = getChildrenLength(this.props.children);
    var changed = ['autoHeight', 'perPage', 'draggable', 'startIndex'].reduce(function (acc, propName) {
      var _extends2;

      return (0, _extends3.default)({}, acc, (_extends2 = {}, _extends2[propName] = _this2.props[propName] !== prevProps[propName], _extends2));
    }, {
      previewState: prevState.preview !== this.state.preview,
      childrenLength: prevChildrenLength !== currentChildrenLength
    });

    if (changed.previewState || changed.perPage || changed.autoHeight || changed.childrenLength) {
      this.handleResize();
      this.toggleFrameTransition(false);
      this.setFramePosition(this.normalizePosition(this.currentIndex));
    }

    if (changed.startIndex) {
      var dir = getShorterDirection(this.currentIndex, this.props.startIndex, currentChildrenLength);
      this.translate(this.currentIndex, this.props.startIndex, dir);
    }

    if (changed.previewState) {
      window.addEventListener('resize', this.handleResize);
    }

    if (changed.previewState || changed.perPage || changed.draggable || changed.childrenLength) {
      if (this.props.draggable && currentChildrenLength > this.props.perPage) {
        var _this$container$curre, _this$container$curre2;

        (_this$container$curre = this.container.current) == null ? void 0 : _this$container$curre.addEventListener(TOUCH_EVENTS.start, this.handleStart);
        (_this$container$curre2 = this.container.current) == null ? void 0 : _this$container$curre2.addEventListener(MOUSE_EVENTS.start, this.handleStart);
      } else {
        var _this$container$curre3, _this$container$curre4;

        (_this$container$curre3 = this.container.current) == null ? void 0 : _this$container$curre3.removeEventListener(TOUCH_EVENTS.start, this.handleStart);
        (_this$container$curre4 = this.container.current) == null ? void 0 : _this$container$curre4.removeEventListener(MOUSE_EVENTS.start, this.handleStart);
      }
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var _this$container$curre5, _this$container$curre6;

    window.removeEventListener('resize', this.handleResize);
    (_this$container$curre5 = this.container.current) == null ? void 0 : _this$container$curre5.removeEventListener(TOUCH_EVENTS.start, this.handleStart);
    documentLocal.removeEventListener(TOUCH_EVENTS.end, this.handleEnd);
    documentLocal.removeEventListener(TOUCH_EVENTS.move, this.handleMove);
    (_this$container$curre6 = this.container.current) == null ? void 0 : _this$container$curre6.removeEventListener(MOUSE_EVENTS.start, this.handleStart);
    documentLocal.removeEventListener(MOUSE_EVENTS.end, this.handleEnd);
    documentLocal.removeEventListener(MOUSE_EVENTS.move, this.handleMove);
  };

  // eslint-disable-next-line max-statements
  _proto.getChildren = function getChildren() {
    var _this$props = this.props,
        children = _this$props.children,
        perPage = _this$props.perPage,
        loop = _this$props.loop,
        stagePadding = _this$props.stagePadding,
        startIndex = _this$props.startIndex,
        autoHeight = _this$props.autoHeight;
    var preview = this.state.preview;

    if (getChildrenLength(children) <= perPage) {
      return children;
    }

    var childrenArray = childrenToArray(children);
    var ch = loop ? [].concat(childrenArray.slice(-perPage - 1), childrenArray, childrenArray.slice(0, perPage + 1)) : childrenArray;

    if (preview && autoHeight) {
      var start = startIndex;
      var end = startIndex + perPage;

      if (loop) {
        start += perPage + 1;
        end += perPage + 1;
      }

      if (stagePadding) {
        start = Math.max(start - 1, 0);
        end += 1;
      }

      return ch.map(function (child, index) {
        return index < start || index > end ? null : child;
      });
    }

    return ch;
  };

  _proto.getCycledIndex = function getCycledIndex(index) {
    var children = this.props.children;
    return index % getChildrenLength(children) + (index < 0 ? getChildrenLength(children) : 0);
  };

  _proto.getSlideStep = function getSlideStep() {
    return this.props.slideStep || this.props.perPage - 1 || 1;
  };

  _proto.getItemStyles = function getItemStyles(index) {
    var _this$props2 = this.props,
        animateHiding = _this$props2.animateHiding,
        hideInvisibleSlides = _this$props2.hideInvisibleSlides,
        perPage = _this$props2.perPage,
        easing = _this$props2.easing;
    var moving = this.moving;
    var hidden = this.isElemHidden(index);
    var visibility = hidden && !moving ? 'hidden' : 'visible';
    return hideInvisibleSlides ? {
      visibility: visibility,
      opacity: hideInvisibleSlides && hidden ? 0 : 1,
      transition: animateHiding ? "opacity " + 100 / perPage * 0.01 + "s " + easing : undefined
    } : {
      visibility: visibility
    };
  };

  _proto.getTransform = function getTransform(position) {
    var _this$props3 = this.props,
        perPage = _this$props3.perPage,
        loop = _this$props3.loop,
        children = _this$props3.children;
    var pos = position;

    if (getChildrenLength(children) <= perPage) {
      return 'none';
    }

    if (loop) {
      pos += perPage + 1;
    }

    return "translate3d(" + -100 * pos / perPage + "%, 0, 0)";
  };

  _proto.isElemHidden = function isElemHidden(i, position) {
    var _this$props4 = this.props,
        perPage = _this$props4.perPage,
        loop = _this$props4.loop,
        margin = _this$props4.margin,
        stagePadding = _this$props4.stagePadding,
        children = _this$props4.children,
        hideInvisibleSlides = _this$props4.hideInvisibleSlides;
    var currentIndex = !position && position !== 0 ? this.currentIndex : position;
    var offset = loop && getChildrenLength(children) > perPage ? perPage + 1 : 0;
    var leftSlide = currentIndex + offset;
    var rightSlide = leftSlide + perPage - 1;

    if (!hideInvisibleSlides && stagePadding && stagePadding > margin) {
      rightSlide += 1;

      if (loop || leftSlide - i >= 0) {
        leftSlide -= 1;
      }
    }

    return leftSlide <= i && rightSlide >= i ? undefined : true;
  };

  _proto.normalizePosition = function normalizePosition(pos) {
    var _this$props5 = this.props,
        children = _this$props5.children,
        perPage = _this$props5.perPage,
        elastic = _this$props5.elastic,
        loop = _this$props5.loop;

    if (!loop) {
      var from = 0;
      var to = getChildrenLength(children) - perPage;
      return elastic ? elasticClamp(from, to, pos) : clamp(from, to, pos);
    }

    return this.getCycledIndex(pos);
  };

  _proto.translate = function translate(from, to, dir) {
    var _this3 = this;

    var _this$props6 = this.props,
        loop = _this$props6.loop,
        onSlide = _this$props6.onSlide,
        elastic = _this$props6.elastic,
        perPage = _this$props6.perPage;
    this.moving = true;
    var translateFrom = this.normalizePosition(from);
    var translateTo = this.normalizePosition(to);
    translateTo = elastic && !loop ? clamp(0, getChildrenLength(this.getChildren()) - perPage, translateTo) : translateTo;

    if (loop && getMathSign(translateTo - translateFrom) !== dir) {
      translateFrom -= getChildrenLength(this.props.children) * dir;
    }

    this.toggleFrameTransition(false);
    this.toggleElemsTransition(false);
    this.setFramePosition(translateFrom);
    /**
     * [UIKIT-5559]
     * Дожидаемся установки стилей для начальной позиции без анимации с помощью requestAnimationFrame,
     * затем анимируем переход
     */

    window.requestAnimationFrame(function () {
      if (translateTo !== _this3.currentIndex) {
        _this3.currentIndex = translateTo;

        _this3.setContainerHeight();
      }

      _this3.toggleFrameTransition(true);

      _this3.toggleElemsTransition(true);

      _this3.setFramePosition(translateTo);

      onSlide(translateTo);
    });
  };

  _proto.setFramePosition = function setFramePosition(position) {
    if (!this.sliderFrame) {
      return;
    }

    var transform = this.getTransform(position); // @ts-ignore

    this.sliderFrame.current.style.transform = transform; // @ts-ignore

    this.sliderFrame.current.style.WebkitTransform = transform;
    this.updateAriaHiddenOfElems(position);
  };

  _proto.clearDrag = function clearDrag() {
    this.dragging = false;
    this.drag = {
      start: 0,
      end: 0,
      direction: null,
      startY: 0
    };
  };

  _proto.setContainerHeight = function setContainerHeight() {
    var _this4 = this;

    if (!this.container) {
      return;
    }

    var _this$props7 = this.props,
        autoHeight = _this$props7.autoHeight,
        perPage = _this$props7.perPage;

    if (!autoHeight) {
      // @ts-ignore
      this.container.current.style.height = 'auto';
      return;
    }

    var mH = (0, _range.default)(this.currentIndex, this.currentIndex + perPage).reduce(function (maxHeight, index) {
      var itemIndex = _this4.props.loop ? _this4.getCycledIndex(index) + perPage + 1 : index;
      /**
       * Если у нас perPage больше чем количество слайдов,
       * например, perPage 3, а видимых слайдов только 2, то мы тут обращаемся
       * к несуществующему элементу. В таком случае возвращаем
       * максимальнкую высоту среди всех слайдов
       */

      if (!_this4.items["item-" + itemIndex]) {
        return (0, _maxBy.default)(function (i) {
          return i;
        }, childrenToArray(_this4.getChildren()).map(function (_, i) {
          return _this4.items["item-" + i].getBoundingClientRect().height;
        }));
      }

      var _this4$items$$getBoun = _this4.items["item-" + itemIndex].getBoundingClientRect(),
          height = _this4$items$$getBoun.height;

      return Math.max(maxHeight, height);
    }, 0); // @ts-ignore

    this.container.current.style.height = mH + "px";
  } // Recalculate drag /swipe event and reposition the frame of a slider
  ;

  _proto.updateAfterDrag = function updateAfterDrag() {
    var _this$props8 = this.props,
        threshold = _this$props8.threshold,
        loop = _this$props8.loop;
    var movement = this.drag.start - this.drag.end;
    var relativeMovement = movement / this.elemWidth;
    var from = this.currentIndex + relativeMovement;
    var to = this.currentIndex + parseInt("" + relativeMovement, 10) + (Math.abs(movement % this.elemWidth) > threshold ? getMathSign(movement) : 0);
    var dir = getMathSign(to - from);

    if (loop || to !== -1 && to !== getChildrenLength(this.getChildren())) {
      this.props.onDragEnd();
    }

    this.translate(from, to, dir);
  };

  _proto.prev = function prev() {
    this.translate(this.currentIndex, this.currentIndex - this.getSlideStep(), -1);
  };

  _proto.next = function next() {
    this.translate(this.currentIndex, this.currentIndex + this.getSlideStep(), 1);
  };

  _proto.toggleFrameTransition = function toggleFrameTransition(enabled) {
    if (!this.sliderFrame) {
      return;
    }

    var _this$props9 = this.props,
        duration = _this$props9.duration,
        easing = _this$props9.easing;
    var val = "transform " + (enabled ? duration : 0) + "ms " + easing; // @ts-ignore

    this.sliderFrame.current.style.WebkitTransition = val; // @ts-ignore

    this.sliderFrame.current.style.transition = val;
  };

  _proto.toggleElemsTransition = function toggleElemsTransition(enabled) {
    var len = getChildrenLength(this.getChildren());

    for (var i = 0; i < len; i++) {
      var item = this.items["item-" + i];
      var transition = enabled ? this.getItemStyles(i).transition : null;
      item.style.webkitTransition = transition || '';
      item.style.transition = transition || '';
    }
  };

  _proto.updateAriaHiddenOfElems = function updateAriaHiddenOfElems(position) {
    var hideInvisibleSlides = this.props.hideInvisibleSlides;
    var len = getChildrenLength(this.getChildren());

    for (var i = 0; i < len; i++) {
      var item = this.items["item-" + i];
      var hidden = this.isElemHidden(i, position);
      var beforeVisible = this.dragging && hidden && !this.isElemHidden(i + 1, position);
      var afterVisible = this.dragging && hidden && !this.isElemHidden(i - 1, position);

      if (beforeVisible) {
        item.removeAttribute('aria-hidden');
        item.style.visibility = 'visible';

        if (position !== undefined && hideInvisibleSlides) {
          item.style.opacity = "" + (1 - position + Math.floor(position));
        }
      } else if (afterVisible) {
        item.removeAttribute('aria-hidden');
        item.style.visibility = 'visible';

        if (position !== undefined && hideInvisibleSlides) {
          item.style.opacity = "" + (position - Math.floor(position));
        }
      } else if (hidden) {
        item.setAttribute('aria-hidden', 'true');
        item.style.visibility = this.moving || this.dragging ? 'visible' : 'hidden';
        item.style.opacity = hideInvisibleSlides && !this.dragging ? '0' : '1';
      } else {
        item.removeAttribute('aria-hidden');
        item.style.visibility = 'visible';
        item.style.opacity = hideInvisibleSlides ? '1' : '';
      }
    }
  };

  _proto.render = function render() {
    var _cn,
        _this5 = this;

    var _this$props10 = this.props,
        margin = _this$props10.margin,
        autoHeight = _this$props10.autoHeight,
        duration = _this$props10.duration,
        easing = _this$props10.easing,
        stagePadding = _this$props10.stagePadding,
        perPage = _this$props10.perPage,
        startIndex = _this$props10.startIndex,
        dataQaType = _this$props10.dataQaType,
        _this$props10$contain = _this$props10.containerOverflow,
        containerOverflow = _this$props10$contain === void 0 ? 'hidden' : _this$props10$contain,
        borderRadius = _this$props10.borderRadius;
    var preview = this.state.preview;
    var transition = autoHeight ? "height " + duration + "ms " + easing : undefined;
    var transform;

    if (preview) {
      var position = this.normalizePosition(startIndex);
      transform = this.getTransform(position);
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      style: {
        padding: "0 " + stagePadding + "px",
        WebkitTransition: transition,
        transition: transition,
        overflow: containerOverflow,
        borderRadius: borderRadius
      },
      ref: this.container
    }, /*#__PURE__*/_react.default.createElement("ul", Object.assign({}, (0, _dataQa.default)({
      dataQaType: dataQaType + ".frame"
    }), {
      ref: this.sliderFrame,
      className: (0, _classnames.default)((_cn = {}, _cn[_CarouselModule.default.sliderFrame] = true, _cn[_CarouselModule.default.sliderFrame_stretch] = !autoHeight, _cn)),
      style: {
        marginRight: -margin,
        WebkitTransform: transform,
        transform: transform
      },
      onTransitionEnd: this.handleTransitionEnd
    }), childrenToArray(this.getChildren()).map(function (child, i) {
      return /*#__PURE__*/_react.default.createElement("li", Object.assign({}, (0, _dataQa.default)({
        dataQaType: dataQaType + ".item"
      }), {
        ref: _this5.setRef("item-" + i),
        className: _CarouselModule.default.item,
        "aria-hidden": _this5.isElemHidden(i),
        "data-key": "item-" + i
        /* eslint-disable-next-line react/no-array-index-key */
        ,
        key: "item-" + i,
        style: (0, _extends3.default)({
          minWidth: 100 / perPage + "%",
          paddingRight: margin
        }, _this5.getItemStyles(i))
      }), child);
    })));
  };

  return Slider;
}(_react.PureComponent);

Slider.defaultProps = {
  duration: 400,
  easing: 'ease',
  perPage: 1,
  startIndex: 0,
  draggable: true,
  threshold: 150,
  loop: false,
  onSlide: _noop.default,
  children: [],
  margin: 0,
  stagePadding: 0,
  autoHeight: false,
  slideStep: null,
  elastic: false,
  onDragEnd: _noop.default
};
var _default = Slider;
exports.default = _default;