"use strict";

exports.__esModule = true;
exports.addStep = addStep;
exports.canAddStep = canAddStep;

var _parse = require("./parse");

var ROUNDING_THRESHOLD = 0.0000001;

function stepBase(value, step, count) {
  var floatNumberOfSteps = value / step;
  var roundedNumberOfSteps = Math.round(floatNumberOfSteps);
  /**
   * Если value нацело делится на step с некоторой погрешностью,
   * то именно это значение и нужно использовать
   */

  if (Math.abs(roundedNumberOfSteps - floatNumberOfSteps) < ROUNDING_THRESHOLD) {
    return roundedNumberOfSteps;
  } // Если прибавляем шаги, то базовое значение нужно округлить вниз


  if (count > 0) {
    return Math.floor(floatNumberOfSteps);
  } // Если убавляем, то наоборот – вверх


  return Math.ceil(floatNumberOfSteps);
}

function addStep(value, props, count) {
  if (count === void 0) {
    count = 1;
  }

  var newValue = value;
  var step = props.step,
      min = props.min,
      max = props.max,
      precision = props.precision;

  if (typeof step === 'function') {
    return step(newValue, props, count);
  }

  newValue = (0, _parse.normalizeNumber)(newValue, props);

  if (step) {
    newValue = (stepBase(newValue, step, count) + count) * step;
  }

  newValue = +newValue.toFixed(precision);
  return (0, _parse.minMax)(newValue, min, max);
}

function canAddStep(value, props, count) {
  if (count === void 0) {
    count = 1;
  }

  var newValue = (0, _parse.normalizeNumber)(value, props);

  if (typeof props.max !== 'undefined' && count > 0) {
    return newValue < props.max;
  }

  if (typeof props.min !== 'undefined' && count < 0) {
    return newValue > props.min;
  }

  return true;
}