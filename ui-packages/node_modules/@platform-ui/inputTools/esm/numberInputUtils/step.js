import { minMax, normalizeNumber } from './parse';
const ROUNDING_THRESHOLD = 0.0000001;

function stepBase(value, step, count) {
  const floatNumberOfSteps = value / step;
  const roundedNumberOfSteps = Math.round(floatNumberOfSteps);
  /**
   * Если value нацело делится на step с некоторой погрешностью,
   * то именно это значение и нужно использовать
   */

  if (Math.abs(roundedNumberOfSteps - floatNumberOfSteps) < ROUNDING_THRESHOLD) {
    return roundedNumberOfSteps;
  } // Если прибавляем шаги, то базовое значение нужно округлить вниз


  if (count > 0) {
    return Math.floor(floatNumberOfSteps);
  } // Если убавляем, то наоборот – вверх


  return Math.ceil(floatNumberOfSteps);
}

export function addStep(value, props, count = 1) {
  let newValue = value;
  const {
    step,
    min,
    max,
    precision
  } = props;

  if (typeof step === 'function') {
    return step(newValue, props, count);
  }

  newValue = normalizeNumber(newValue, props);

  if (step) {
    newValue = (stepBase(newValue, step, count) + count) * step;
  }

  newValue = +newValue.toFixed(precision);
  return minMax(newValue, min, max);
}
export function canAddStep(value, props, count = 1) {
  const newValue = normalizeNumber(value, props);

  if (typeof props.max !== 'undefined' && count > 0) {
    return newValue < props.max;
  }

  if (typeof props.min !== 'undefined' && count < 0) {
    return newValue > props.min;
  }

  return true;
}