/* eslint-disable no-param-reassign */
import { decimalsCount } from '@platform-ui/format-utils';
import { isEmptyValue } from './parse';
const DIGIT_GROUP_LENGTH = 3;
export const DEFAULT_DIGIT_GROUPING_SEPARATOR = '\u0020';
export const DEFAULT_DECIMAL_SEPARATOR = ',';
export function propsToSettings(props) {
  const {
    min,
    max,
    showPlus,
    precision,
    insertSpaces,
    padStartingZeroes,
    digitGroupingSeparator = DEFAULT_DIGIT_GROUPING_SEPARATOR,
    decimalSeparator = DEFAULT_DECIMAL_SEPARATOR
  } = props;
  const minusAllowed = min && min < 0;
  const plusAllowed = showPlus && max && max > 0;
  const minusMandatory = max && max < 0;
  const plusMandatory = min && min > 0 && showPlus;
  const commaAllowed = precision && precision > 0;
  const dontInsertSpaces = !insertSpaces;
  const wholePartMinLength = `${max}`.length;
  return {
    minusAllowed,
    plusAllowed,
    minusMandatory,
    plusMandatory,
    commaAllowed,
    precision,
    dontInsertSpaces,
    padStartingZeroes,
    wholePartMinLength,
    digitGroupingSeparator,
    decimalSeparator
  };
}
export function tokenize({
  value,
  selectionStart,
  selectionEnd
}, settings) {
  const chars = (value.length === 1 && value === ',' ? settings.decimalSeparator : value).split('').map(char => {
    switch (true) {
      case char === settings.digitGroupingSeparator:
        return DEFAULT_DIGIT_GROUPING_SEPARATOR;

      case char === settings.decimalSeparator:
        return '.';

      default:
        return char;
    }
  });
  chars.unshift('');
  return chars.map((char, index) => {
    const token = {
      char
    };

    if (index === selectionStart) {
      token.isStart = true;
    }

    if (index === selectionEnd) {
      token.isEnd = true;
    }

    return token;
  });
}
export function isAllowedCharacter(token, settings) {
  return !!token.char.match(/\d/) || settings.plusAllowed && token.char === '+' || settings.minusAllowed && token.char === '-' || settings.commaAllowed && (token.char === '.' || token.char === ',' || token.char === settings.decimalSeparator);
}
export function cutToken(tokens, index) {
  const token = tokens[index];

  if (token.isStart) {
    tokens[index - 1].isStart = true;
  }

  if (token.isEnd) {
    tokens[index - 1].isEnd = true;
  }

  tokens.splice(index, 1);
  return tokens;
}
export function filterAllowedCharacters(tokens, settings) {
  for (let i = tokens.length - 1; i > 0; i--) {
    const currentToken = tokens[i];
    const allowedChar = isAllowedCharacter(currentToken, settings);

    if (!allowedChar) {
      cutToken(tokens, i);
    } else if (currentToken.char === '.' || currentToken.char === ',' || currentToken.char === settings.decimalSeparator) {
      currentToken.char = '.';
    }
  }

  return tokens;
}
export function findWholePartStart(tokens) {
  return tokens[1] && !tokens[1].char.match(/\d/) ? 2 : 1;
}
export function findWholePart(tokens, settings) {
  const wholePartStart = findWholePartStart(tokens);
  let wholePartEnd = tokens.findIndex(token => token.char === '.');

  if (wholePartEnd === -1) {
    wholePartEnd = tokens.length;
  }

  return [wholePartStart, wholePartEnd];
}
export function fillSpaces(tokens, settings) {
  const {
    dontInsertSpaces
  } = settings;

  if (tokens.length === 1 || dontInsertSpaces) {
    return tokens;
  }

  const [wholePartStart, wholePartEnd] = findWholePart(tokens, settings);

  for (let i = wholePartEnd - DIGIT_GROUP_LENGTH; i > wholePartStart; i -= DIGIT_GROUP_LENGTH) {
    tokens.splice(i, 0, {
      char: DEFAULT_DIGIT_GROUPING_SEPARATOR
    });
  }

  return tokens;
}
export function cutIndexes(tokens, indexes) {
  indexes.forEach(index => {
    cutToken(tokens, index);
  });
  return tokens;
}
export function filterExcessCommas(tokens) {
  const commaIndexes = [];
  let bestCommaFound = false;

  for (let i = tokens.length - 1; i > 0; i--) {
    if (tokens[i].char === '.') {
      if (tokens[i].isStart) {
        bestCommaFound = true;
      } else {
        commaIndexes.push(i);
      }
    }
  }

  if (!bestCommaFound) {
    commaIndexes.shift();
  }

  return cutIndexes(tokens, commaIndexes);
}
export const filterExcessSigns = tokens => {
  const signIndexes = [];
  let bestSignIndex;

  for (let i = tokens.length - 1; i > 0; i--) {
    if (tokens[i].char === '-' || tokens[i].char === '+') {
      if (tokens[i].isStart) {
        bestSignIndex = i;
      } else {
        signIndexes.push(i);

        if (bestSignIndex) {
          bestSignIndex--;
        }
      }
    }
  }

  if (!bestSignIndex) {
    bestSignIndex = signIndexes.pop();
  }

  cutIndexes(tokens, signIndexes);

  if (bestSignIndex && bestSignIndex > 1) {
    const sign = {
      char: tokens[bestSignIndex].char
    };
    cutToken(tokens, bestSignIndex);
    tokens.splice(1, 0, sign);
  }

  return tokens;
};

const reassembleValue = (tokens, settings) => {
  return tokens.map(token => {
    switch (true) {
      case token.char === DEFAULT_DIGIT_GROUPING_SEPARATOR:
        return settings.digitGroupingSeparator;

      case token.char === '.':
        return settings.decimalSeparator;

      default:
        return token.char;
    }
  }).join('');
};

const reassembleInput = (tokens, settings) => ({
  value: reassembleValue(tokens, settings),
  selectionStart: tokens.findIndex(token => token.isStart),
  selectionEnd: tokens.findIndex(token => token.isEnd)
});

export function insertMandatorySign(tokens, settings) {
  if (tokens.length < 2) {
    return tokens;
  }

  const {
    char
  } = tokens[1];

  if (char === '+' || char === '-') {
    return tokens;
  }

  if (settings.plusMandatory) {
    tokens.splice(1, 0, {
      char: '+'
    });
    return tokens;
  }

  if (settings.minusMandatory) {
    tokens.splice(1, 0, {
      char: '-'
    });
    return tokens;
  }
}
export function shouldUpdateFormat(prevProps, nextProps) {
  const propNames = ['min', 'max', 'showPlus', 'precision', 'digitGroupingSeparator', 'decimalSeparator']; // @ts-ignore

  return !!propNames.find(propName => prevProps[propName] !== nextProps[propName]);
}
export function numberToInput(number, settings) {
  const numberDecimals = decimalsCount(number);
  let value = number.toFixed(settings.precision && numberDecimals < settings.precision ? numberDecimals : settings.precision);
  const selectionStart = value.length;
  const selectionEnd = value.length;

  if (settings.plusAllowed && number > 0) {
    value = `+${value}`;
  }

  return {
    value,
    selectionStart,
    selectionEnd
  };
}
export function padEndZeroes(tokens, count) {
  while (count--) {
    tokens.push({
      char: '0'
    });
  }

  return tokens;
}
export function fixPrecision(tokens) {
  const newTokens = [...tokens];
  const commaIndex = newTokens.findIndex(token => token.char === '.');
  const signsAfterComma = newTokens.length - commaIndex - 1;
  const decimalPartSum = newTokens.reduce((sum, {
    char
  }, currentIndex) => {
    if (commaIndex < currentIndex) {
      sum += Number(char);
    }

    return sum;
  }, 0);

  if (commaIndex > -1 && !decimalPartSum) {
    newTokens.splice(commaIndex, signsAfterComma + 1);
  }

  return newTokens;
}
export function padStartZeroes(tokens, count) {
  const position = tokens[1] && !tokens[1].char.match(/\d/) ? 2 : 1;

  while (count--) {
    tokens.splice(position, 0, {
      char: '0'
    });
  }

  return tokens;
}
export function calcMaxLength(props) {
  const {
    min,
    max,
    showPlus,
    precision,
    insertSpaces
  } = props;
  const longestValue = Math.abs(min) >= Math.abs(max) ? min : max;
  let maxLength = Math.abs(longestValue).toString().length;

  if (insertSpaces) {
    maxLength += Math.ceil(maxLength / DIGIT_GROUP_LENGTH) - 1;
  }

  if (longestValue < 0 || showPlus) {
    maxLength += 1;
  }

  if (precision && precision > 0) {
    maxLength += 1 + precision;
  }

  return maxLength;
}
export function cutStartZeroes(tokens, count) {
  const pos = findWholePartStart(tokens);

  while (count > 0 && tokens[pos] && tokens[pos].char === '0') {
    cutToken(tokens, pos);
  }

  return tokens;
}
export function fixWholePartLength(tokens, settings) {
  const {
    padStartingZeroes,
    wholePartMinLength
  } = settings;

  if (!padStartingZeroes) {
    return tokens;
  }

  const [wholePartStart, wholePartEnd] = findWholePart(tokens, settings);
  const wholePartLength = wholePartEnd - wholePartStart;
  const count = wholePartMinLength - wholePartLength;

  if (count > 0) {
    padStartZeroes(tokens, count);
  } else if (count < 0) {
    cutStartZeroes(tokens, count);
  }

  return tokens;
}
export function formatInput(input, props) {
  const settings = propsToSettings(props);
  const tokens = tokenize(input, settings);
  filterAllowedCharacters(tokens, settings);

  if (settings.commaAllowed) {
    filterExcessCommas(tokens);
  }

  if (settings.plusAllowed || settings.minusAllowed) {
    filterExcessSigns(tokens);
  }

  insertMandatorySign(tokens, settings);
  fillSpaces(tokens, settings);
  return reassembleInput(tokens, settings);
}
export function formatNumber(number, props) {
  if (isEmptyValue(number)) {
    return '';
  }

  const settings = propsToSettings(props);
  const input = numberToInput(number, settings);
  const tokens = tokenize(input, settings);
  fixWholePartLength(tokens, settings);
  fillSpaces(tokens, settings);
  return reassembleValue(fixPrecision(tokens), settings);
}
/* eslint-enable no-param-reassign */