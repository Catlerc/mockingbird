import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
const _excluded = ["min", "max", "step", "type", "focused", "precision", "showPlus", "padStartingZeroes", "insertSpaces", "forwardedRef", "maxLength", "digitGroupingSeparator", "decimalSeparator"];
import React, { PureComponent, createRef, forwardRef } from 'react';
import hoistStatics from 'hoist-non-react-statics';
import memoizeWeak from '@platform-ui/memoizeWeak';
import { formatInput, formatNumber, shouldUpdateFormat, calcMaxLength, DEFAULT_DIGIT_GROUPING_SEPARATOR, DEFAULT_DECIMAL_SEPARATOR } from './numberInputUtils/format';
import { parseNumber } from './numberInputUtils/parse';
import { addStep } from './numberInputUtils/step';
const inputTypes = ['text', 'tel'];

const fixInputType = type => !type || inputTypes.indexOf(type) === -1 ? 'text' : type;

const numberInputHOC = memoizeWeak(InputComponent => {
  // eslint-disable-next-line react/no-unsafe
  class NumberInput extends PureComponent {
    constructor(props) {
      super(props);
      this.inputRef = this.props.forwardedRef || /*#__PURE__*/createRef();
      this.value = this.props.value;

      this.handleBackspace = event => {
        const input = event.target;
        const {
          value
        } = input;

        if (!input.selectionStart || input.selectionStart !== input.selectionEnd) {
          return;
        }

        if (value[input.selectionStart - 1] === this.props.digitGroupingSeparator) {
          input.selectionStart -= 1;
          input.selectionEnd = input.selectionStart;
        }
      };

      this.handleDelete = event => {
        const input = event.target;
        const {
          value,
          selectionStart,
          selectionEnd
        } = input;

        if (!input.selectionStart || selectionStart !== selectionEnd) {
          return;
        }

        if (value[input.selectionStart] === this.props.digitGroupingSeparator) {
          input.selectionStart += 1;
          input.selectionEnd = input.selectionStart;
        }
      };

      this.handleArrowHorizontal = (event, dir) => {
        const input = event.target;
        const {
          value
        } = input;

        if (!input.selectionStart) {
          return;
        }

        if (value[input.selectionStart - 1 + dir] === this.props.digitGroupingSeparator) {
          input.selectionStart += 2 * dir;
          input.selectionEnd = input.selectionStart;
          event.preventDefault();
        }
      };

      this.handleArrowVertical = (event, dir) => {
        const {
          name,
          onChange
        } = this.props;
        const value = addStep(this.value, this.props, dir);

        if (value !== this.value) {
          onChange(event, {
            value,
            name
          });
        }

        event.preventDefault();
      };

      this.handleKeyDown = event => {
        const {
          onKeyDown
        } = this.props;
        const key = event.key.toLowerCase();

        if (!event.shiftKey && !event.altKey && !event.metaKey) {
          switch (key) {
            case 'backspace':
              this.handleBackspace(event);
              break;

            case 'delete':
              this.handleDelete(event);
              break;

            case 'arrowleft':
              this.handleArrowHorizontal(event, -1);
              break;

            case 'arrowright':
              this.handleArrowHorizontal(event, 1);
              break;

            case 'arrowup':
              this.handleArrowVertical(event, 1);
              break;

            case 'arrowdown':
              this.handleArrowVertical(event, -1);
              break;

            default:
              break;
          }
        }

        onKeyDown && onKeyDown(event);
      };

      this.handleChange = event => {
        const input = event.target;
        const {
          name,
          onChange
        } = this.props;
        const {
          value: formattedValue,
          selectionStart,
          selectionEnd
        } = formatInput({
          value: input.value,
          selectionStart: input.selectionStart,
          selectionEnd: input.selectionEnd
        }, this.props);
        input.value = formattedValue;
        input.selectionStart = selectionStart;
        input.selectionEnd = selectionEnd;

        if (formattedValue !== this.state.formattedValue) {
          this.setState({
            formattedValue
          });
        }

        const numberValue = parseNumber(formattedValue, this.props);
        this.value = numberValue;
        onChange && onChange(event, {
          name,
          value: numberValue
        });
      };

      this.state = {
        formattedValue: formatNumber(this.value, props)
      };
    }

    componentDidMount() {
      const {
        focused
      } = this.props;

      if (focused) {
        this.focus();
      }
    }

    UNSAFE_componentWillReceiveProps(nextProps) {
      const {
        focused
      } = this.props;
      const {
        value
      } = nextProps;
      const blurred = focused && !nextProps.focused;

      if (!shouldUpdateFormat(this.props, nextProps) && !blurred && value === this.value) {
        return;
      }

      this.value = value;
      this.setState({
        formattedValue: formatNumber(value, nextProps)
      });
    }

    componentDidUpdate(prevProps) {
      const {
        focused
      } = this.props;

      if (prevProps.focused === focused) {
        return;
      }

      if (focused) {
        this.focus();
      } else {
        this.blur();
      }
    }

    focus() {
      this.inputRef && this.inputRef.current && this.inputRef.current !== document.activeElement && this.inputRef.current.focus && this.inputRef.current.focus();
    }

    blur() {
      this.inputRef && this.inputRef.current && this.inputRef.current === document.activeElement && this.inputRef.current.blur && this.inputRef.current.blur();
    }

    render() {
      const {
        formattedValue
      } = this.state;

      const _this$props = this.props,
            {
        type,
        maxLength
      } = _this$props,
            props = _objectWithoutPropertiesLoose(_this$props, _excluded);

      return /*#__PURE__*/React.createElement(InputComponent, Object.assign({}, props, {
        ref: this.inputRef,
        type: fixInputType(type),
        value: formattedValue,
        inputMode: "numeric",
        maxLength: maxLength || calcMaxLength(this.props),
        onChange: this.handleChange,
        onKeyDown: this.handleKeyDown
      }));
    }

  }

  NumberInput.defaultProps = {
    value: undefined,
    focused: false,
    min: -(2 ** 53 - 1),
    // Number.MIN_SAFE_INTEGER не поддерживается в IE 11
    max: 2 ** 53 - 1,
    // Number.MAX_SAFE_INTEGER не поддерживается в IE 11
    step: 1,
    type: 'text',
    precision: 0,
    insertSpaces: true,
    padStartingZeroes: false,
    showPlus: false,
    forwardedRef: undefined,
    digitGroupingSeparator: DEFAULT_DIGIT_GROUPING_SEPARATOR,
    decimalSeparator: DEFAULT_DECIMAL_SEPARATOR
  };
  const NumberInputWithRef = /*#__PURE__*/forwardRef((props, forwardedRef) => {
    return /*#__PURE__*/React.createElement(NumberInput, Object.assign({}, props, {
      forwardedRef: forwardedRef
    }));
  });
  return hoistStatics(NumberInput, NumberInputWithRef);
});
export default numberInputHOC;