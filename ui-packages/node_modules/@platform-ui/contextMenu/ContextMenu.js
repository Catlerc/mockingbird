"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

exports.__esModule = true;
exports.ContextMenu = void 0;

var _react = _interopRequireWildcard(require("react"));

var _dataQa = _interopRequireDefault(require("@platform-ui/dataQa"));

var _classnames = _interopRequireDefault(require("classnames"));

var _popover = _interopRequireDefault(require("@platform-ui/popover"));

var _scroll = _interopRequireDefault(require("@platform-ui/scroll"));

var _ContextMenuItem = require("./ContextMenuItem/ContextMenuItem");

var _ContextMenuModule = _interopRequireDefault(require("./ContextMenu.module.css"));

var ESCAPE_BUTTON = 27;
var popoverPositions = {
  left: {
    direction: 'bottom',
    align: 'start'
  },
  right: {
    direction: 'bottom',
    align: 'end'
  },
  center: {
    direction: 'bottom',
    align: 'center'
  },
  'left-side': {
    direction: 'left',
    align: 'start'
  },
  'right-side': {
    direction: 'right',
    align: 'start'
  }
};

var ContextMenu = function ContextMenu(props) {
  var _props$opened, _popoverPositions$pos, _popoverPositions$pos2, _cn3;

  var to = props.to,
      align = props.align,
      _props$buttonAriaLabe = props.buttonAriaLabel,
      buttonAriaLabel = _props$buttonAriaLabe === void 0 ? 'Меню' : _props$buttonAriaLabe,
      children = props.children,
      _props$closeOnPopover = props.closeOnPopoverClick,
      closeOnPopoverClick = _props$closeOnPopover === void 0 ? true : _props$closeOnPopover,
      colored = props.colored,
      contentBeforeList = props.contentBeforeList,
      _props$dataQaType = props.dataQaType,
      dataQaType = _props$dataQaType === void 0 ? 'uikit/contextMenu' : _props$dataQaType,
      direction = props.direction,
      disabled = props.disabled,
      hideOnResize = props.hideOnResize,
      highlightActive = props.highlightActive,
      id = props.id,
      _props$items = props.items,
      items = _props$items === void 0 ? [] : _props$items,
      _props$itemSize = props.itemSize,
      itemSize = _props$itemSize === void 0 ? 'l' : _props$itemSize,
      markable = props.markable,
      maxHeight = props.maxHeight,
      _props$position = props.position,
      position = _props$position === void 0 ? 'right' : _props$position,
      preventDefaultClick = props.preventDefaultClick,
      showOnHover = props.showOnHover,
      smartDirection = props.smartDirection,
      squareChecked = props.squareChecked,
      wide = props.wide,
      zIndex = props.zIndex,
      blockStyles = props.blockStyles,
      onClick = props.onClick,
      onClickOutside = props.onClickOutside,
      onClose = props.onClose,
      onShow = props.onShow;

  var _useState = (0, _react.useState)(false),
      openedState = _useState[0],
      setOpenedState = _useState[1];

  var opened = (_props$opened = props.opened) != null ? _props$opened : openedState;
  var updatePopoverPosition = (0, _react.useRef)(function () {});
  var customPadding = (0, _react.useMemo)(function () {
    return position === 'left-side' || position === 'right-side' ? 4 : 0;
  }, [position]);
  var getHandleItemClick = (0, _react.useCallback)(function (key, item, handler) {
    return function (event) {
      return handler(event, key, {
        opened: opened
      }, item);
    };
  }, [opened]);
  var close = (0, _react.useCallback)(function () {
    setOpenedState(false);
    onClose == null ? void 0 : onClose(null, {
      opened: false
    });
  }, [onClose]);
  var open = (0, _react.useCallback)(function () {
    setOpenedState(true);
    onShow == null ? void 0 : onShow(null, {
      opened: true
    });
  }, [onShow]);
  var getSetPopoverPosition = (0, _react.useCallback)(function (fn) {
    updatePopoverPosition.current = fn;
  }, []);
  var handleKeyDown = (0, _react.useCallback)(function (event) {
    if (event.keyCode === ESCAPE_BUTTON) {
      close();
    }
  }, [close]);
  /**
   * TODO: в мажорном обновлении выделить в отдельный компонент.
   * До этого сделать проблематично из-за экспорта типов ContextMenuItem.
   */

  var renderItems = (0, _react.useCallback)(function (menuItems) {
    return function (markableItems) {
      var canBeMarkable = markableItems || menuItems.some(function (item) {
        return item.checked === true;
      });
      return menuItems.map(function (item, key) {
        var _cn;

        return /*#__PURE__*/_react.default.createElement("li", Object.assign({
          key: item.key || key,
          className: (0, _classnames.default)((_cn = {}, _cn[_ContextMenuModule.default.listItem] = true, _cn[_ContextMenuModule.default.listItem_active] = item.active, _cn[_ContextMenuModule.default.listItem_disabled] = item.disabled, _cn[_ContextMenuModule.default.listItem_withTooltip] = item.tooltipContent, _cn))
        }, item.dataAttributes), item.title && !item.items && /*#__PURE__*/_react.default.createElement(_ContextMenuItem.ContextMenuItem, Object.assign({}, item, {
          markable: canBeMarkable,
          itemSize: itemSize,
          squareChecked: squareChecked,
          onClick: item.onClick && getHandleItemClick(key, item, item.onClick)
        })), item.items && /*#__PURE__*/_react.default.createElement("ul", {
          className: (0, _classnames.default)(_ContextMenuModule.default.list, _ContextMenuModule.default.list_secondary),
          id: item.id
        }, item.title && /*#__PURE__*/_react.default.createElement("li", {
          className: (0, _classnames.default)(_ContextMenuModule.default.groupTitle, _ContextMenuModule.default["groupTitle_size_" + itemSize])
        }, item.title), renderItems(item.items)(markableItems)));
      });
    };
  }, [getHandleItemClick, itemSize, squareChecked]);
  /**
   * TODO: в мажорном обновлении выделить в отдельный компонент.
   * До этого сделать проблематично из-за экспорта типов ContextMenuItem.
   */

  var renderMenu = (0, _react.useCallback)(function () {
    var _cn2;

    var list = /*#__PURE__*/_react.default.createElement("ul", {
      className: _ContextMenuModule.default.list
    }, items && markable !== undefined && renderItems(items)(markable));

    return /*#__PURE__*/_react.default.createElement(_react.Fragment, null, contentBeforeList, items && !!items.length && /*#__PURE__*/_react.default.createElement("div", Object.assign({
      className: (0, _classnames.default)((_cn2 = {}, _cn2[_ContextMenuModule.default.menu] = true, _cn2[_ContextMenuModule.default.menu_colored] = colored, _cn2[_ContextMenuModule.default.menu_highlightActive] = highlightActive, _cn2[_ContextMenuModule.default["menu_position_" + position]] = _ContextMenuModule.default["list_position_" + position], _cn2)),
      role: "menu",
      id: id
    }, (0, _dataQa.default)({
      dataQaType: dataQaType + ".menu"
    })), maxHeight ? /*#__PURE__*/_react.default.createElement("div", {
      style: {
        maxHeight: maxHeight
      },
      className: _ContextMenuModule.default.scrollWrapper
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: _ContextMenuModule.default.scroll
    }, /*#__PURE__*/_react.default.createElement(_scroll.default, {
      setContainer: function setContainer() {
        /**
         * [UIKIT-4978] из-за того что ширина скроллбара возвращается через Promise,
         * ширина Popover меняется после установки его позиции.
         * Требуется пересчитывать позицию Popover после обновления ширины.
         */
        requestAnimationFrame(function () {
          updatePopoverPosition.current();
        });
      }
    }, list))) : list));
  }, [colored, contentBeforeList, dataQaType, highlightActive, id, items, markable, maxHeight, position, renderItems]);
  return /*#__PURE__*/_react.default.createElement(_popover.default, {
    to: to,
    align: align || ((_popoverPositions$pos = popoverPositions[position]) == null ? void 0 : _popoverPositions$pos.align),
    direction: direction || ((_popoverPositions$pos2 = popoverPositions[position]) == null ? void 0 : _popoverPositions$pos2.direction),
    popoverBlock: renderMenu(),
    smartDirection: smartDirection,
    hideOnResize: hideOnResize,
    customPadding: props.customPadding || customPadding,
    toggleOnClick: !showOnHover,
    closeOnPopoverClick: closeOnPopoverClick,
    wide: wide,
    isActive: opened,
    isInactive: !opened,
    increasedTouchZone: false,
    onClose: close,
    onShow: open,
    zIndex: zIndex,
    dataQaType: dataQaType,
    preventDefaultClick: preventDefaultClick,
    onClick: onClick,
    getSetPositionFunc: getSetPopoverPosition,
    onClickOutside: onClickOutside,
    disabled: disabled,
    blockStyles: blockStyles
  }, /*#__PURE__*/_react.default.createElement("span", {
    className: (0, _classnames.default)((_cn3 = {}, _cn3[_ContextMenuModule.default.button] = true, _cn3[_ContextMenuModule.default.button_wide] = wide, _cn3[_ContextMenuModule.default.button_disabled] = disabled, _cn3)),
    "aria-label": buttonAriaLabel,
    onKeyDown: handleKeyDown
  }, children));
}; // TODO: убрать в мажорном обновлении


exports.ContextMenu = ContextMenu;
ContextMenu.defaultProps = {
  dataQaType: 'uikit/contextMenu',
  colored: false,
  children: null,
  items: [],
  opened: undefined,
  position: 'right',
  itemSize: 'l',
  hideOnResize: false,
  showOnHover: false,
  wide: false,
  squareChecked: false,
  closeOnPopoverClick: true,
  contentBeforeList: null,
  smartDirection: false,
  preventDefaultClick: false,
  buttonAriaLabel: 'Меню',
  markable: false
};