import React, { Fragment, useCallback, useMemo, useRef, useState } from 'react';
import dataQa from '@platform-ui/dataQa';
import cn from 'classnames';
import Popover from '@platform-ui/popover';
import Scroll from '@platform-ui/scroll';
import { ContextMenuItem as MenuItem } from './ContextMenuItem/ContextMenuItem';
import styles from './ContextMenu.module.css';
const ESCAPE_BUTTON = 27;
const popoverPositions = {
  left: {
    direction: 'bottom',
    align: 'start'
  },
  right: {
    direction: 'bottom',
    align: 'end'
  },
  center: {
    direction: 'bottom',
    align: 'center'
  },
  'left-side': {
    direction: 'left',
    align: 'start'
  },
  'right-side': {
    direction: 'right',
    align: 'start'
  }
};
export const ContextMenu = props => {
  var _props$opened, _popoverPositions$pos, _popoverPositions$pos2;

  const {
    to,
    align,
    buttonAriaLabel = 'Меню',
    children,
    closeOnPopoverClick = true,
    colored,
    contentBeforeList,
    dataQaType = 'uikit/contextMenu',
    direction,
    disabled,
    hideOnResize,
    highlightActive,
    id,
    items = [],
    itemSize = 'l',
    markable,
    maxHeight,
    position = 'right',
    preventDefaultClick,
    showOnHover,
    smartDirection,
    squareChecked,
    wide,
    zIndex,
    blockStyles,
    onClick,
    onClickOutside,
    onClose,
    onShow
  } = props;
  const [openedState, setOpenedState] = useState(false);
  const opened = (_props$opened = props.opened) != null ? _props$opened : openedState;
  const updatePopoverPosition = useRef(() => {});
  const customPadding = useMemo(() => position === 'left-side' || position === 'right-side' ? 4 : 0, [position]);
  const getHandleItemClick = useCallback((key, item, handler) => event => handler(event, key, {
    opened
  }, item), [opened]);
  const close = useCallback(() => {
    setOpenedState(false);
    onClose == null ? void 0 : onClose(null, {
      opened: false
    });
  }, [onClose]);
  const open = useCallback(() => {
    setOpenedState(true);
    onShow == null ? void 0 : onShow(null, {
      opened: true
    });
  }, [onShow]);
  const getSetPopoverPosition = useCallback(fn => {
    updatePopoverPosition.current = fn;
  }, []);
  const handleKeyDown = useCallback(event => {
    if (event.keyCode === ESCAPE_BUTTON) {
      close();
    }
  }, [close]);
  /**
   * TODO: в мажорном обновлении выделить в отдельный компонент.
   * До этого сделать проблематично из-за экспорта типов ContextMenuItem.
   */

  const renderItems = useCallback(menuItems => {
    return markableItems => {
      const canBeMarkable = markableItems || menuItems.some(item => item.checked === true);
      return menuItems.map((item, key) => /*#__PURE__*/React.createElement("li", Object.assign({
        key: item.key || key,
        className: cn({
          [styles.listItem]: true,
          [styles.listItem_active]: item.active,
          [styles.listItem_disabled]: item.disabled,
          [styles.listItem_withTooltip]: item.tooltipContent
        })
      }, item.dataAttributes), item.title && !item.items && /*#__PURE__*/React.createElement(MenuItem, Object.assign({}, item, {
        markable: canBeMarkable,
        itemSize: itemSize,
        squareChecked: squareChecked,
        onClick: item.onClick && getHandleItemClick(key, item, item.onClick)
      })), item.items && /*#__PURE__*/React.createElement("ul", {
        className: cn(styles.list, styles.list_secondary),
        id: item.id
      }, item.title && /*#__PURE__*/React.createElement("li", {
        className: cn(styles.groupTitle, styles[`groupTitle_size_${itemSize}`])
      }, item.title), renderItems(item.items)(markableItems))));
    };
  }, [getHandleItemClick, itemSize, squareChecked]);
  /**
   * TODO: в мажорном обновлении выделить в отдельный компонент.
   * До этого сделать проблематично из-за экспорта типов ContextMenuItem.
   */

  const renderMenu = useCallback(() => {
    const list = /*#__PURE__*/React.createElement("ul", {
      className: styles.list
    }, items && markable !== undefined && renderItems(items)(markable));
    return /*#__PURE__*/React.createElement(Fragment, null, contentBeforeList, items && !!items.length && /*#__PURE__*/React.createElement("div", Object.assign({
      className: cn({
        [styles.menu]: true,
        [styles.menu_colored]: colored,
        [styles.menu_highlightActive]: highlightActive,
        [styles[`menu_position_${position}`]]: styles[`list_position_${position}`]
      }),
      role: "menu",
      id: id
    }, dataQa({
      dataQaType: `${dataQaType}.menu`
    })), maxHeight ? /*#__PURE__*/React.createElement("div", {
      style: {
        maxHeight
      },
      className: styles.scrollWrapper
    }, /*#__PURE__*/React.createElement("div", {
      className: styles.scroll
    }, /*#__PURE__*/React.createElement(Scroll, {
      setContainer: () => {
        /**
         * [UIKIT-4978] из-за того что ширина скроллбара возвращается через Promise,
         * ширина Popover меняется после установки его позиции.
         * Требуется пересчитывать позицию Popover после обновления ширины.
         */
        requestAnimationFrame(() => {
          updatePopoverPosition.current();
        });
      }
    }, list))) : list));
  }, [colored, contentBeforeList, dataQaType, highlightActive, id, items, markable, maxHeight, position, renderItems]);
  return /*#__PURE__*/React.createElement(Popover, {
    to: to,
    align: align || ((_popoverPositions$pos = popoverPositions[position]) == null ? void 0 : _popoverPositions$pos.align),
    direction: direction || ((_popoverPositions$pos2 = popoverPositions[position]) == null ? void 0 : _popoverPositions$pos2.direction),
    popoverBlock: renderMenu(),
    smartDirection: smartDirection,
    hideOnResize: hideOnResize,
    customPadding: props.customPadding || customPadding,
    toggleOnClick: !showOnHover,
    closeOnPopoverClick: closeOnPopoverClick,
    wide: wide,
    isActive: opened,
    isInactive: !opened,
    increasedTouchZone: false,
    onClose: close,
    onShow: open,
    zIndex: zIndex,
    dataQaType: dataQaType,
    preventDefaultClick: preventDefaultClick,
    onClick: onClick,
    getSetPositionFunc: getSetPopoverPosition,
    onClickOutside: onClickOutside,
    disabled: disabled,
    blockStyles: blockStyles
  }, /*#__PURE__*/React.createElement("span", {
    className: cn({
      [styles.button]: true,
      [styles.button_wide]: wide,
      [styles.button_disabled]: disabled
    }),
    "aria-label": buttonAriaLabel,
    onKeyDown: handleKeyDown
  }, children));
}; // TODO: убрать в мажорном обновлении

ContextMenu.defaultProps = {
  dataQaType: 'uikit/contextMenu',
  colored: false,
  children: null,
  items: [],
  opened: undefined,
  position: 'right',
  itemSize: 'l',
  hideOnResize: false,
  showOnHover: false,
  wide: false,
  squareChecked: false,
  closeOnPopoverClick: true,
  contentBeforeList: null,
  smartDirection: false,
  preventDefaultClick: false,
  buttonAriaLabel: 'Меню',
  markable: false
};