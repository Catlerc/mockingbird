import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/extends";
const _excluded = ["tagName", "onDragStart", "onDrag", "onDragEnd", "dragTimeout", "dragThreshold", "allowDefaultAction", "dataQaType", "dataQaData", "touchable", "forwardedRef"];
import React, { PureComponent } from 'react';
import noop from '@tinkoff/utils/function/noop';
import mergeWith from '@tinkoff/utils/object/mergeWith';
import dataQa from '@platform-ui/dataQa';

const preventDefault = e => e.preventDefault();

const touchEventListenerOptions = {
  passive: false
};
const getDelta = mergeWith((start, next) => {
  if (typeof start === 'object') {
    return getDelta(start, next);
  }

  return next - start;
});
const LEFT_MOUSE_BUTTON = 0;
const STATUS_IDLE = 'idle';
const STATUS_WAITING = 'waiting';
const STATUS_DRAGGING = 'dragging';
export class Draggable extends PureComponent {
  constructor(...args) {
    super(...args);
    this.self = null;
    this.drag = null;
    this.startDrag = null;
    this.lastRect = {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      width: 0,
      height: 0
    };
    this.status = STATUS_IDLE;

    this.catchErr = err => {
      this.status = STATUS_IDLE;

      if (err instanceof Error) {
        throw err;
      }
    };

    this.selfRef = el => {
      this.self = el;
      const {
        forwardedRef
      } = this.props;

      if (forwardedRef) {
        if (typeof forwardedRef === 'function') {
          forwardedRef(el);
        } else {
          forwardedRef.current = el;
        }
      }
    };

    this.handleMove = null;
    this.handleUp = null;

    this.handleWrapper = handler => e => {
      const {
        allowDefaultAction
      } = this.props;

      if (!allowDefaultAction) {
        e.preventDefault();
        e.stopPropagation();
      }

      let touch;

      if ('touches' in e) {
        // тач-событие
        touch = e.touches[0] || this.drag;
        this.drag = touch; // touchEnd не возвращает координаты - запоминаем
      } else {
        // событие мыши
        if (e.button !== LEFT_MOUSE_BUTTON) {
          return;
        }

        touch = e;
      }

      let rect = this.self && this.self.getBoundingClientRect();

      if (rect) {
        this.lastRect = rect;
      } else {
        rect = this.lastRect;
      }

      const drag = {
        page: {
          x: touch.pageX,
          y: touch.pageY
        },
        client: {
          x: touch.clientX,
          y: touch.clientY
        },
        offset: {
          x: touch.clientX - rect.left,
          y: touch.clientY - rect.top
        },
        rect
      };
      return handler(drag);
    };

    this.handleMouseDown = this.handleWrapper(drag => {
      if (this.status !== STATUS_IDLE) {
        return;
      }

      this.startDrag = drag;
      this.status = STATUS_WAITING;
      const {
        onDragStart
      } = this.props; // eslint-disable-next-line consistent-return

      return (// eslint-disable-next-line compat/compat
        Promise.all([this.waitForTimeout(), this.waitForThreshold()]).then(() => onDragStart(this.getNextDrag(drag))) // eslint-disable-next-line promise/always-return
        .then(() => {
          this.status = STATUS_DRAGGING;
          this.addListeners(this.handleMouseMove, this.handleMouseUp);
        }).catch(this.catchErr)
      );
    });
    this.handleMouseMove = this.handleWrapper(drag => {
      return this.props.onDrag(this.getNextDrag(drag));
    });
    this.handleMouseUp = this.handleWrapper(drag => {
      this.removeListeners();
      const nextDrag = this.getNextDrag(drag);
      const {
        onDragEnd
      } = this.props; // eslint-disable-next-line compat/compat

      Promise.resolve(onDragEnd(nextDrag)) // eslint-disable-next-line promise/always-return
      .then(() => {
        this.status = STATUS_IDLE;
      }).catch(this.catchErr);
    });
  }

  componentDidMount() {
    const {
      touchable
    } = this.props;
    if (!this.self) return;
    this.self.addEventListener('mousedown', this.handleMouseDown);

    if (touchable) {
      this.self.addEventListener('touchstart', this.handleMouseDown, touchEventListenerOptions);
    }
  }

  componentWillUnmount() {
    if (!this.self) return;
    this.self.removeEventListener('mousedown', this.handleMouseDown);
    this.self.removeEventListener('touchstart', this.handleMouseDown, touchEventListenerOptions);
    this.removeListeners();
  }

  getNextDrag(drag) {
    return _extends({}, drag, this.startDrag ? {
      start: _extends({}, this.startDrag)
    } : {}, {
      delta: getDelta(this.startDrag, drag)
    });
  }

  waitForTimeout() {
    // eslint-disable-next-line compat/compat
    return new Promise(resolve => {
      const {
        dragTimeout
      } = this.props;

      if (dragTimeout === 0) {
        return resolve();
      }

      return setTimeout(resolve, dragTimeout);
    });
  }

  waitForThreshold() {
    // eslint-disable-next-line compat/compat, consistent-return
    return new Promise((resolve, reject) => {
      const {
        dragThreshold
      } = this.props;

      if (dragThreshold === 0) {
        return resolve();
      }

      const handleMove = this.handleWrapper(drag => {
        const {
          x,
          y
        } = getDelta(this.startDrag && this.startDrag.page, drag.page);

        if (Math.sqrt(x * x + y * y) >= dragThreshold) {
          this.removeListeners();
          resolve();
        }
      });
      const handleUp = this.handleWrapper(() => {
        this.removeListeners();
        reject();
      });
      this.addListeners(handleMove, handleUp);
    });
  }

  addListeners(handleMove, handleUp) {
    this.removeListeners();
    this.handleMove = handleMove;
    this.handleUp = handleUp;
    document.addEventListener('mousemove', handleMove);
    document.addEventListener('touchmove', handleMove, touchEventListenerOptions);
    document.addEventListener('mouseup', handleUp);
    document.addEventListener('mouseleave', handleUp);
    document.addEventListener('touchend', handleUp);
  }

  removeListeners() {
    if (this.handleMove) {
      document.removeEventListener('mousemove', this.handleMove);
      document.removeEventListener('touchmove', this.handleMove, touchEventListenerOptions);
      this.handleMove = null;
    }

    if (this.handleUp) {
      document.removeEventListener('mouseup', this.handleUp);
      document.removeEventListener('mouseleave', this.handleUp);
      document.removeEventListener('touchend', this.handleUp);
      this.handleUp = null;
    }
  }

  render() {
    const _this$props = this.props,
          {
      tagName,
      dataQaType,
      dataQaData
    } = _this$props,
          otherProps = _objectWithoutPropertiesLoose(_this$props, _excluded);

    return /*#__PURE__*/React.createElement(tagName, _extends({}, dataQa({
      dataQaType,
      dataQaData
    }), {
      ref: this.selfRef
    }, otherProps, {
      onDragOver: preventDefault,
      onDragEnd: preventDefault
    }));
  }

}
Draggable.defaultProps = {
  tagName: 'div',
  dataQaType: 'uikit/Draggable',
  touchable: false,
  onDragStart: noop,
  onDrag: noop,
  onDragEnd: noop,
  dragTimeout: 0,
  dragThreshold: 0,
  allowDefaultAction: false
};
export default /*#__PURE__*/React.forwardRef((props, forwardedRef) => /*#__PURE__*/React.createElement(Draggable, Object.assign({}, props, {
  forwardedRef: forwardedRef
})));