"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

exports.__esModule = true;
exports.layouts = exports.default = void 0;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _hoistNonReactStatics = _interopRequireDefault(require("hoist-non-react-statics"));

var _nil = _interopRequireDefault(require("@tinkoff/utils/is/nil"));

var _empty = _interopRequireDefault(require("@tinkoff/utils/is/empty"));

var _getActiveElement = require("./utils/getActiveElement");

var _ReactInputSelection = require("./utils/ReactInputSelection");

var _textConversion = require("./utils/textConversion");

var _excluded = ["type", "switchLayout", "keysForModify", "toUpperCase", "preserveRegister"];

var isFocused = function isFocused(element) {
  return (0, _getActiveElement.getActiveElement)() === element;
};

var modifyKeys = function modifyKeys(keys, valueObj, func) {
  if (valueObj === void 0) {
    valueObj = {};
  }

  var modifiedKeys = {};
  keys && keys.forEach(function (key) {
    if (!(0, _empty.default)(valueObj[key])) {
      modifiedKeys[key] = func(valueObj[key]);
    }
  });
  return modifiedKeys;
};

var withRegister = function withRegister(originalStr, modifiedSrt) {
  return originalStr.split('').map(function (char, index) {
    var modifiedChar = modifiedSrt[index];

    if (char === char.toUpperCase()) {
      return modifiedChar.toUpperCase();
    }

    return modifiedChar;
  }).join('');
};

var toUpperCaseFunc = function toUpperCaseFunc(str) {
  return str && str.toUpperCase();
};

var layouts = [undefined, 'toLatin', 'toCyrillic'];
exports.layouts = layouts;

var getName = function getName(Component) {
  return Component.displayName || Component.name || 'Component(!)';
};

var InputLayoutHOC = function InputLayoutHOC(WrappedComponent, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$nativeInputMode = _ref.nativeInputMode,
      nativeInputMode = _ref$nativeInputMode === void 0 ? false : _ref$nativeInputMode;

  var SwitchLayoutWrapper = /*#__PURE__*/function (_PureComponent) {
    (0, _inheritsLoose2.default)(SwitchLayoutWrapper, _PureComponent);

    function SwitchLayoutWrapper() {
      var _this;

      for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
        _args[_key] = arguments[_key];
      }

      _this = _PureComponent.call.apply(_PureComponent, [this].concat(_args)) || this;
      _this.keydown = {
        code: 0,
        ctrl: false,
        meta: false,
        alt: false,
        shift: false,
        name: ''
      };

      _this.refCallback = function (ref) {
        _this.input = ref;

        if (_this.props.refCallback) {
          if (typeof _this.props.refCallback === 'function') {
            _this.props.refCallback(ref);
          } else {
            _this.props.refCallback.current = ref;
          }
        }
      };

      _this.handleKeyDown = function (event) {
        _this.keydown = {
          code: event.keyCode,
          ctrl: event.ctrlKey,
          meta: event.metaKey,
          shift: event.shiftKey,
          alt: event.altKey,
          key: event.key,
          name: event.nativeEvent.code
        };

        if (_this.props.onKeyDown) {
          _this.props.onKeyDown(event);
        }
      };

      _this.handleKeyPress = function (event) {
        var _this$props = _this.props,
            switchLayout = _this$props.switchLayout,
            toUpperCase = _this$props.toUpperCase,
            onKeyPress = _this$props.onKeyPress;
        var isLayoutSwitching = switchLayout && !_this.keydown.ctrl && !_this.keydown.meta;
        onKeyPress && onKeyPress(event);

        if (toUpperCase || isLayoutSwitching) {
          var value = _this.input.value;
          var newSymbol = String.fromCharCode(event.charCode);
          var newVal = !(0, _nil.default)(value) ? value : '';
          var caretPos = _this.selection;
          var prevPart = newVal.slice(0, caretPos.start);
          var nextPart = newVal.slice(caretPos.end);

          if (isLayoutSwitching) {
            newSymbol = (0, _textConversion.charByKeyCode)(newSymbol, _this.keydown, switchLayout);
          }

          if (toUpperCase) {
            newSymbol = toUpperCaseFunc(newSymbol);
          }

          _this.switchedValue = {
            value: "" + prevPart + newSymbol + nextPart,
            caretPos: caretPos.start + 1
          };
        }
      };

      _this.handleChange = function (event, params) {
        if (params === void 0) {
          params = {
            value: _this.input.value
          };
        }

        var keysForModify = _this.props.keysForModify;
        var modifiedParams = {};
        var modifiedValue = _this.switchedValue ? _this.switchedValue.value : params.value; // Текст может быть изменен не только через KeyPress, но и через буфер обмена.
        // В этом случае попробуем заменить то, что можем заменить - только буквы, без спецсимволов.

        if (_this.props.switchLayout) {
          if (_this.props.switchLayout === 'toCyrillic') {
            modifiedValue = (0, _textConversion.toCyrillicOnlyCharStr)(modifiedValue);
            modifiedParams = modifyKeys(keysForModify, params, _textConversion.toCyrillicOnlyCharStr);
          } else {
            modifiedValue = (0, _textConversion.toLatinOnlyCharStr)(modifiedValue);
            modifiedParams = modifyKeys(keysForModify, params, _textConversion.toLatinOnlyCharStr);
          }
        }

        if (_this.props.toUpperCase) {
          modifiedValue = toUpperCaseFunc(modifiedValue);
          modifiedParams = modifyKeys(keysForModify, modifiedParams, toUpperCaseFunc);
        }

        if (_this.props.preserveRegister) {
          modifiedValue = withRegister(params.value, modifiedValue);
        }

        if (_this.input && nativeInputMode) {
          _this.input.value = modifiedValue;
        }

        if (_this.switchedValue) {
          _this.selection = {
            start: _this.switchedValue.caretPos,
            end: _this.switchedValue.caretPos
          };
          delete _this.switchedValue;
        }

        if (_this.props.onChange) {
          if (nativeInputMode) {
            _this.props.onChange(event);
          } else {
            _this.props.onChange(event, (0, _extends2.default)({}, params, modifiedParams, {
              value: modifiedValue
            }));
          }
        }
      };

      _this.handleInput = function () {
        if (_this.switchedValue && _this.input) {
          _this.input.value = _this.switchedValue.value;
          _this.selection = {
            start: _this.switchedValue.caretPos,
            end: _this.switchedValue.caretPos
          };
          delete _this.switchedValue;
        }

        if (_this.props.onInput) {
          var _this$props2;

          (_this$props2 = _this.props).onInput.apply(_this$props2, arguments);
        }
      };

      return _this;
    }

    var _proto = SwitchLayoutWrapper.prototype;

    _proto.render = function render() {
      var _ref2;

      var _this$props3 = this.props,
          type = _this$props3.type,
          switchLayout = _this$props3.switchLayout,
          keysForModify = _this$props3.keysForModify,
          toUpperCase = _this$props3.toUpperCase,
          preserveRegister = _this$props3.preserveRegister,
          restProps = (0, _objectWithoutPropertiesLoose2.default)(_this$props3, _excluded);
      var modesByType = {
        email: 'email',
        number: 'numeric'
      };
      return /*#__PURE__*/_react.default.createElement(WrappedComponent, Object.assign({}, restProps, (_ref2 = {}, _ref2[nativeInputMode ? 'ref' : 'refCallback'] = this.refCallback, _ref2), {
        type: modesByType[type] ? 'text' : type,
        inputMode: modesByType[type],
        onChange: this.handleChange,
        onKeyDown: this.handleKeyDown,
        onKeyPress: this.handleKeyPress,
        onInput: this.handleInput
      }));
    };

    (0, _createClass2.default)(SwitchLayoutWrapper, [{
      key: "selection",
      get: function get() {
        return this.input ? (0, _ReactInputSelection.getSelection)(this.input) : {
          start: 0,
          end: 0
        };
      },
      set: function set(selection) {
        // в мобильном сафари при попытке сменить позицию каретки ставится фокус на поле, поэтому проверка на фокус
        if (this.input && isFocused(this.input)) {
          (0, _ReactInputSelection.setSelection)(this.input, selection);
        }
      }
    }]);
    return SwitchLayoutWrapper;
  }(_react.PureComponent);

  SwitchLayoutWrapper.displayName = getName(WrappedComponent);
  SwitchLayoutWrapper.defaultProps = (0, _extends2.default)({}, WrappedComponent.defaultProps, {
    toUpperCase: false,
    preserveRegister: true,
    keysForModify: []
  });
  process.env.NODE_ENV !== "production" ? SwitchLayoutWrapper.propTypes = (0, _extends2.default)({}, WrappedComponent.propTypes, {
    /**
     * Выбор раскладки, в которую будут перведены введеные символы
     */
    switchLayout: _propTypes.default.oneOf(layouts),

    /**
     * Первод введенных символов в верхний регистр
     */
    toUpperCase: _propTypes.default.bool,

    /**
     * Сохранять регистр оригинальной строки
     */
    preserveRegister: _propTypes.default.bool,

    /**
     * Массив ключей payload в onChange, раскладку, которых необходимо переводить
     */
    keysForModify: _propTypes.default.arrayOf(_propTypes.default.string)
  }) : void 0;
  var WithStatics = (0, _hoistNonReactStatics.default)(SwitchLayoutWrapper, WrappedComponent);

  if (nativeInputMode) {
    return /*#__PURE__*/_react.default.forwardRef(function (props, forwardedRef) {
      return /*#__PURE__*/_react.default.createElement(WithStatics, Object.assign({}, props, {
        refCallback: forwardedRef
      }));
    });
  }

  return WithStatics;
};

var _default = InputLayoutHOC;
exports.default = _default;