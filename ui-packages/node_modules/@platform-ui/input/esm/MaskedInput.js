import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/extends";
const _excluded = ["inputComponent", "type", "placeholder", "partialPlaceholder", "hintholder", "value"];
import React, { PureComponent } from 'react';
import keycode from 'keycode';
import { getActiveElement } from './utils/getActiveElement'; // @ts-ignore

import { getSelection, setSelection } from './utils/ReactInputSelection';
import Mask from './utils/mask';
import Input, { isDefinedValue } from './StatelessInput';

const isFocused = element => getActiveElement() === element;

const INITIAL_SELECTION = {
  start: 0,
  end: 0
};
const inputTypes = ['text', 'search', 'password', 'tel', 'url']; // https://html.spec.whatwg.org/multipage/input.html#the-input-element:dom-textarea/input-selectionstart-3

const fixInputType = type => type && inputTypes.indexOf(type) === -1 ? 'text' : type;

const caretSymbol = '⿵';

const cut = (str, cutFrom, cutTo, replacement = '') => str.slice(0, cutFrom) + replacement + str.slice(cutTo);

const editableDiff = (indexesFrom = [], indexesTo = [], until = 0) => {
  let i;
  let editableCount = 0; // Считаем, сколько редактируемых позиций было до курсора

  for (i = 0; i < until; i++) {
    if (indexesFrom[i] !== false) {
      editableCount++;
    }
  } // Отсчитываем столько же редактируемых позиций с новой маской


  for (i = 0; editableCount > 0; i++) {
    if (indexesTo[i] !== false) {
      editableCount--;
    }
  }

  return i - until;
};

// eslint-disable-next-line react/no-unsafe
class MaskedInput extends PureComponent {
  constructor(props) {
    super(props);
    this.input = void 0;
    this.mask = void 0;
    this.syncState = void 0;

    this.refInput = ref => {
      this.input = ref;
      this.props.refCallback && this.props.refCallback(ref);
    };

    this.hasValue = value => isDefinedValue(value) && (this.props.showMaskPrefix ? true : value !== this.mask.fixedPrefix);

    this.handleBlur = (event, _ref) => {
      let rest = _extends({}, _ref);

      const {
        fieldDoneStrategy
      } = this.props;
      const {
        maskedValue,
        value
      } = this.syncState;
      this.props.onBlur && this.props.onBlur(event, _extends({}, rest, {
        value,
        maskedValue
      }));

      if ((fieldDoneStrategy === 'blur' || fieldDoneStrategy === 'lastCharBlur') && maskedValue.length === this.mask.length && this.mask.length > 0) {
        this.props.onFieldDone && this.props.onFieldDone(event, _extends({}, rest, {
          value,
          maskedValue
        }));
      }
    };

    this.handleFocus = (event, _ref2) => {
      let rest = _extends({}, _ref2);

      const {
        maskedValue,
        value
      } = this.syncState;
      this.adjustCaret();
      this.props.onFocus && this.props.onFocus(event, _extends({}, rest, {
        value,
        maskedValue
      }));
    };

    this.handleClick = (...args) => {
      this.adjustCaret();
      this.props.onClick && this.props.onClick(...args);
    };

    this.handleChange = (event, params) => {
      this.updateInput(event, params, params.value, this.selection.start);
    };

    this.handleKeyDown = (event, params) => {
      const {
        start,
        end
      } = this.selection;
      const code = keycode(event);
      const {
        shiftKey,
        ctrlKey,
        metaKey
      } = event;
      const {
        readOnly
      } = this.props;
      const isDelete = code === 'delete';
      const isBackspace = code === 'backspace';
      const isArrowUp = code === 'up';
      const isArrowLeft = code === 'left';
      const isArrowRight = code === 'right';

      if (start !== end && !isArrowLeft && !isArrowRight || shiftKey || ctrlKey || metaKey || !(isDelete || isBackspace || isArrowLeft || isArrowRight || isArrowUp)) {
        this.props.onKeyDown && this.props.onKeyDown(event, params);
        return;
      }

      event.preventDefault();
      event.stopPropagation();
      let newCaretPosition;
      let newMaskedValue = this.syncState.maskedValue;

      if (!readOnly) {
        switch (true) {
          case isArrowUp:
            newCaretPosition = this.mask.fixedPrefix.length;
            break;

          case isArrowRight:
            newCaretPosition = this.calcNextEditPosition(end, 1);
            break;

          case isArrowLeft:
            newCaretPosition = this.calcNextEditPosition(start, -1);
            break;

          case isDelete:
            {
              const cutUntil = this.calcNextEditPosition(start, 1);
              newCaretPosition = Math.max(start, this.calcNextEditPosition(cutUntil, -1));
              newMaskedValue = cut(newMaskedValue, newCaretPosition, cutUntil);
              break;
            }

          case isBackspace:
            newCaretPosition = this.calcNextEditPosition(start, -1);
            newMaskedValue = cut(newMaskedValue, newCaretPosition, start);
            break;
        }
      }

      this.props.onKeyDown && this.props.onKeyDown(event, params);
      !readOnly && this.updateInput(event, params, newMaskedValue, newCaretPosition);
    };

    this.initMask(props);
    const {
      value: val = '',
      maskedValue: _maskedValue
    } = props;

    let _value;

    if (_maskedValue !== undefined) {
      _value = this.mask.unmask(_maskedValue);
    } else {
      _value = val;
    }

    this.syncState = {
      value: _value,
      maskedValue: this.mask.mask(_value)
    };
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    const {
      value: val = '',
      maskedValue: maskedValueProp
    } = nextProps;
    const isMaskChanged = this.shouldUpdateMask(nextProps);
    const currentEditableIndexes = this.mask.editableIndexes;
    let value = '';

    if (maskedValueProp !== undefined) {
      value = this.mask.unmask(maskedValueProp);
    } else {
      value = val;
    }

    isMaskChanged && this.initMask(nextProps);
    const maskedValue = maskedValueProp !== undefined ? maskedValueProp : this.mask.mask(value);
    const isMaskedValueChanged = maskedValue !== this.syncState.maskedValue;

    if (isMaskChanged && isMaskedValueChanged) {
      const {
        end
      } = this.selection;
      this.updateInput(null, {}, maskedValue, this.calcNextEditPosition(end + editableDiff(currentEditableIndexes, this.mask.editableIndexes, end), 1));
    }

    if (isMaskedValueChanged) {
      this.syncState = {
        value,
        maskedValue
      };
      this.forceUpdate();
    }
  }

  getPlaceholderProps() {
    const {
      value,
      placeholder,
      partialPlaceholder,
      hintholder,
      focused
    } = this.props;
    const empty = !this.hasValue(value);

    if (!hintholder) {
      if (empty) {
        return {
          placeholder,
          partialPlaceholder: focused
        };
      }

      return {
        placeholder,
        partialPlaceholder
      };
    }

    const hintholderText = focused ? this.mask.getHintHolder() : '';

    if (empty) {
      return {
        placeholder: placeholder || hintholderText,
        partialPlaceholder: true
      };
    }

    return {
      placeholder: hintholderText,
      partialPlaceholder: true
    };
  }

  adjustCaret() {
    if (!this.input) {
      return;
    }

    const selection = {
      start: this.input.selectionStart,
      end: this.input.selectionEnd
    };
    const fixedPrefixLength = this.mask.fixedPrefix.length;

    if (fixedPrefixLength > 0 && selection.start === selection.end && selection.start < fixedPrefixLength) {
      this.selection = {
        start: fixedPrefixLength,
        end: fixedPrefixLength
      };
    }
  } // eslint-disable-next-line max-statements, max-params


  updateInput(event, params, pureValue, caretPosition, force) {
    let maskedValue = pureValue;

    if (maskedValue !== this.syncState.maskedValue || force) {
      maskedValue = cut(maskedValue, caretPosition, caretPosition, caretSymbol);
      const prefixIndex = maskedValue.indexOf(this.mask.fixedPrefix);

      if (prefixIndex !== -1) {
        maskedValue = cut(maskedValue, prefixIndex, prefixIndex + this.mask.fixedPrefix.length);
      }

      maskedValue = this.mask.mask(maskedValue, caretSymbol); // eslint-disable-next-line no-param-reassign

      caretPosition = maskedValue.indexOf(caretSymbol);
      maskedValue = cut(maskedValue, caretPosition, caretPosition + 1);

      if (this.input) {
        this.input.value = maskedValue;
      }

      if (maskedValue !== this.syncState.maskedValue) {
        const value = this.mask.unmask(maskedValue);

        const payload = _extends({}, params, {
          name: this.props.name,
          value,
          pureValue,
          maskedValue,
          caretPosition
        });

        this.syncState = {
          value,
          maskedValue
        };
        this.props.onChange && this.props.onChange(event, payload);

        if (maskedValue.length === this.mask.length && this.mask.length > 0) {
          if (this.props.fieldDoneStrategy === 'anyInput' || (this.props.fieldDoneStrategy === 'lastCharInput' || this.props.fieldDoneStrategy === 'lastCharBlur') && (!this.props.focused || caretPosition >= this.mask.length)) {
            this.props.onFieldDone && this.props.onFieldDone(event, payload);
          }
        }
      }
    }

    this.selection = {
      start: caretPosition,
      end: caretPosition
    };
  }

  calcNextEditPosition(firstPos, sign) {
    let result = firstPos + sign;
    const fixedPrefixLength = this.mask.fixedPrefix.length;

    if (result <= fixedPrefixLength) {
      return fixedPrefixLength;
    }

    if (this.mask.length === 0) {
      return result;
    }

    if (result > this.mask.length) {
      return this.mask.length;
    }

    while (result > 0 && result <= this.mask.length && !this.mask.editableIndexes[sign < 0 ? result : result - 1]) {
      result += sign;
    }

    return result;
  }

  get selection() {
    if (this.input) {
      return getSelection(this.input);
    }

    return INITIAL_SELECTION;
  }

  set selection(selection) {
    // в мобильном сафари при попытке сменить позицию каретки ставится фокус на поле, поэтому проверка на фокус
    if (this.input && isFocused(this.input)) {
      setSelection(this.input, selection);
    }
  }

  shouldUpdateMask(nextProps) {
    return nextProps.mask !== this.props.mask || nextProps.maskTransitions !== this.props.maskTransitions;
  }

  initMask(props) {
    this.mask = new Mask(props.mask, {
      maskTransitions: props.maskTransitions
    });
  }

  render() {
    const _this$props = this.props,
          {
      inputComponent: InputComponent = Input,
      type,
      value
    } = _this$props,
          otherProps = _objectWithoutPropertiesLoose(_this$props, _excluded);

    const {
      maskedValue
    } = this.syncState;
    return /*#__PURE__*/React.createElement(InputComponent, Object.assign({}, otherProps, this.getPlaceholderProps(), {
      refCallback: this.refInput,
      onKeyDown: this.handleKeyDown,
      onChange: this.handleChange,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur,
      onClick: this.handleClick,
      value: maskedValue,
      filled: this.hasValue(maskedValue || value),
      type: fixInputType(type)
    }));
  }

}

MaskedInput.defaultProps = {
  dataQaType: 'uikit/input',
  size: 'l',
  maskTransitions: {},
  fieldDoneStrategy: 'anyInput'
};
export default MaskedInput;