import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/extends";
const _excluded = ["type", "switchLayout", "keysForModify", "toUpperCase", "preserveRegister"];
import React, { PureComponent } from 'react';
import pt from 'prop-types';
import hoistStatics from 'hoist-non-react-statics';
import isNil from '@tinkoff/utils/is/nil';
import isEmpty from '@tinkoff/utils/is/empty';
import { getActiveElement } from './utils/getActiveElement';
import { getSelection, setSelection } from './utils/ReactInputSelection';
import { charByKeyCode, toCyrillicOnlyCharStr, toLatinOnlyCharStr } from './utils/textConversion';

const isFocused = element => getActiveElement() === element;

const modifyKeys = (keys, valueObj = {}, func) => {
  const modifiedKeys = {};
  keys && keys.forEach(key => {
    if (!isEmpty(valueObj[key])) {
      modifiedKeys[key] = func(valueObj[key]);
    }
  });
  return modifiedKeys;
};

const withRegister = (originalStr, modifiedSrt) => {
  return originalStr.split('').map((char, index) => {
    const modifiedChar = modifiedSrt[index];

    if (char === char.toUpperCase()) {
      return modifiedChar.toUpperCase();
    }

    return modifiedChar;
  }).join('');
};

const toUpperCaseFunc = str => str && str.toUpperCase();

export const layouts = [undefined, 'toLatin', 'toCyrillic'];

const getName = Component => Component.displayName || Component.name || 'Component(!)';

const InputLayoutHOC = (WrappedComponent, {
  nativeInputMode: _nativeInputMode = false
} = {}) => {
  class SwitchLayoutWrapper extends PureComponent {
    constructor(..._args) {
      super(..._args);
      this.keydown = {
        code: 0,
        ctrl: false,
        meta: false,
        alt: false,
        shift: false,
        name: ''
      };

      this.refCallback = ref => {
        this.input = ref;

        if (this.props.refCallback) {
          if (typeof this.props.refCallback === 'function') {
            this.props.refCallback(ref);
          } else {
            this.props.refCallback.current = ref;
          }
        }
      };

      this.handleKeyDown = event => {
        this.keydown = {
          code: event.keyCode,
          ctrl: event.ctrlKey,
          meta: event.metaKey,
          shift: event.shiftKey,
          alt: event.altKey,
          key: event.key,
          name: event.nativeEvent.code
        };

        if (this.props.onKeyDown) {
          this.props.onKeyDown(event);
        }
      };

      this.handleKeyPress = event => {
        const {
          switchLayout,
          toUpperCase,
          onKeyPress
        } = this.props;
        const isLayoutSwitching = switchLayout && !this.keydown.ctrl && !this.keydown.meta;
        onKeyPress && onKeyPress(event);

        if (toUpperCase || isLayoutSwitching) {
          const {
            value
          } = this.input;
          let newSymbol = String.fromCharCode(event.charCode);
          const newVal = !isNil(value) ? value : '';
          const caretPos = this.selection;
          const prevPart = newVal.slice(0, caretPos.start);
          const nextPart = newVal.slice(caretPos.end);

          if (isLayoutSwitching) {
            newSymbol = charByKeyCode(newSymbol, this.keydown, switchLayout);
          }

          if (toUpperCase) {
            newSymbol = toUpperCaseFunc(newSymbol);
          }

          this.switchedValue = {
            value: `${prevPart}${newSymbol}${nextPart}`,
            caretPos: caretPos.start + 1
          };
        }
      };

      this.handleChange = (event, params = {
        value: this.input.value
      }) => {
        const {
          keysForModify
        } = this.props;
        let modifiedParams = {};
        let modifiedValue = this.switchedValue ? this.switchedValue.value : params.value; // Текст может быть изменен не только через KeyPress, но и через буфер обмена.
        // В этом случае попробуем заменить то, что можем заменить - только буквы, без спецсимволов.

        if (this.props.switchLayout) {
          if (this.props.switchLayout === 'toCyrillic') {
            modifiedValue = toCyrillicOnlyCharStr(modifiedValue);
            modifiedParams = modifyKeys(keysForModify, params, toCyrillicOnlyCharStr);
          } else {
            modifiedValue = toLatinOnlyCharStr(modifiedValue);
            modifiedParams = modifyKeys(keysForModify, params, toLatinOnlyCharStr);
          }
        }

        if (this.props.toUpperCase) {
          modifiedValue = toUpperCaseFunc(modifiedValue);
          modifiedParams = modifyKeys(keysForModify, modifiedParams, toUpperCaseFunc);
        }

        if (this.props.preserveRegister) {
          modifiedValue = withRegister(params.value, modifiedValue);
        }

        if (this.input && _nativeInputMode) {
          this.input.value = modifiedValue;
        }

        if (this.switchedValue) {
          this.selection = {
            start: this.switchedValue.caretPos,
            end: this.switchedValue.caretPos
          };
          delete this.switchedValue;
        }

        if (this.props.onChange) {
          if (_nativeInputMode) {
            this.props.onChange(event);
          } else {
            this.props.onChange(event, _extends({}, params, modifiedParams, {
              value: modifiedValue
            }));
          }
        }
      };

      this.handleInput = (...args) => {
        if (this.switchedValue && this.input) {
          this.input.value = this.switchedValue.value;
          this.selection = {
            start: this.switchedValue.caretPos,
            end: this.switchedValue.caretPos
          };
          delete this.switchedValue;
        }

        if (this.props.onInput) {
          this.props.onInput(...args);
        }
      };
    }

    get selection() {
      return this.input ? getSelection(this.input) : {
        start: 0,
        end: 0
      };
    }

    set selection(selection) {
      // в мобильном сафари при попытке сменить позицию каретки ставится фокус на поле, поэтому проверка на фокус
      if (this.input && isFocused(this.input)) {
        setSelection(this.input, selection);
      }
    }

    render() {
      const _this$props = this.props,
            {
        type
      } = _this$props,
            restProps = _objectWithoutPropertiesLoose(_this$props, _excluded);

      const modesByType = {
        email: 'email',
        number: 'numeric'
      };
      return /*#__PURE__*/React.createElement(WrappedComponent, Object.assign({}, restProps, {
        [_nativeInputMode ? 'ref' : 'refCallback']: this.refCallback,
        type: modesByType[type] ? 'text' : type,
        inputMode: modesByType[type],
        onChange: this.handleChange,
        onKeyDown: this.handleKeyDown,
        onKeyPress: this.handleKeyPress,
        onInput: this.handleInput
      }));
    }

  }

  SwitchLayoutWrapper.displayName = getName(WrappedComponent);
  SwitchLayoutWrapper.defaultProps = _extends({}, WrappedComponent.defaultProps, {
    toUpperCase: false,
    preserveRegister: true,
    keysForModify: []
  });
  process.env.NODE_ENV !== "production" ? SwitchLayoutWrapper.propTypes = _extends({}, WrappedComponent.propTypes, {
    /**
     * Выбор раскладки, в которую будут перведены введеные символы
     */
    switchLayout: pt.oneOf(layouts),

    /**
     * Первод введенных символов в верхний регистр
     */
    toUpperCase: pt.bool,

    /**
     * Сохранять регистр оригинальной строки
     */
    preserveRegister: pt.bool,

    /**
     * Массив ключей payload в onChange, раскладку, которых необходимо переводить
     */
    keysForModify: pt.arrayOf(pt.string)
  }) : void 0;
  const WithStatics = hoistStatics(SwitchLayoutWrapper, WrappedComponent);

  if (_nativeInputMode) {
    return /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
      return /*#__PURE__*/React.createElement(WithStatics, Object.assign({}, props, {
        refCallback: forwardedRef
      }));
    });
  }

  return WithStatics;
};

export default InputLayoutHOC;