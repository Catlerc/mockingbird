import _extends from "@babel/runtime/helpers/extends";
import React, { PureComponent, forwardRef, Fragment } from 'react';
import pt from 'prop-types';
import noop from '@tinkoff/utils/function/noop';
import memoize from '@platform-ui/memoizeWeak';
import generateId from '@platform-ui/generateId';
import InputBox from '@platform-ui/inputBox';
import { placeholderHOC, FocusArea, InlinePlaceholder, InlineInput, PrefixPostfixInput } from '@platform-ui/inputTools';
import styles from './Input.module.css';
import isAutoFill from './utils/isAutoFill';
const InputComponent = placeholderHOC(InlinePlaceholder)(InlineInput);
const PrefixPostfixInputComponent = placeholderHOC(InlinePlaceholder)(PrefixPostfixInput);
export const isDefinedValue = value => Boolean(value) || value === 0;

const autoCompleteValue = autoCompleteProp => {
  if (typeof autoCompleteProp === 'string') {
    return autoCompleteProp;
  }

  return autoCompleteProp ? 'on' : 'off';
};

class Input extends PureComponent {
  constructor(...args) {
    super(...args);
    this.labelId = generateId(this);
    this.decorateCallback = memoize(callback => (event, params) => callback(event, _extends({
      name: this.props.name
    }, params)));

    this.setRef = elem => {
      const refCallback = this.props.forwardedRef || this.props.refCallback;
      this.input = elem;
      refCallback(elem);
    };

    this.handleBlur = (event, params) => {
      const {
        onBlur
      } = this.props; // отматывает значение в начало по блюру, исправляет баг в FF (https://)

      if (this.input) {
        this.input.scrollLeft = 0;
      }

      this.decorateCallback(onBlur)(event, _extends({}, params, {
        value: event.target.value
      }));
    };

    this.handleCleanerClick = (event, params) => {
      this.decorateCallback(this.props.onChange)(event, _extends({}, params, {
        value: ''
      }));
      this.decorateCallback(this.props.onClean)(event, params);
    };

    this.handleChange = (event, params) => {
      const autofilled = event ? isAutoFill(event) : false;
      this.decorateCallback(this.props.onChange)(event, _extends({}, params, {
        value: event.target.value,
        autofilled
      }));
    };
  }

  componentDidMount() {
    this.props.focused ? this.focus(this.props.focusOptions) : this.blur();
  }

  componentDidUpdate(prevProps) {
    if (!prevProps.focused && this.props.focused) {
      this.focus(this.props.focusOptions);
    }

    if (prevProps.focused && !this.props.focused) {
      this.blur();
    }
  }

  focus(options) {
    this.input && this.input.focus && this.input.focus(options);
  }

  blur() {
    this.input && this.input.blur && this.input.blur();
  }

  render() {
    const {
      ariaLabel,
      ariaLabelledby,
      ariaAutocomplete,
      ariaControls,
      ariaDescribedBy,
      ariaErrorMessage,
      autoComplete,
      autofilled,
      autoFocus,
      cleanable,
      cobrowsingSecure,
      cursor,
      dataQaData,
      dataQaType,
      disabled,
      error,
      filled,
      flatCorners,
      focused,
      hintBlock,
      id,
      inputIcon,
      inputMode,
      label,
      labelId,
      leftContent,
      max,
      maxLength,
      min,
      name,
      onAnimationStart,
      onClick,
      onFocus,
      onInput,
      onKeyDown,
      onKeyPress,
      onKeyUp,
      onPaste,
      partialPlaceholder,
      pattern,
      placeholder,
      prefix,
      postfix,
      readOnly,
      required,
      rightContent,
      informationContent,
      size,
      step,
      transparent,
      type,
      valid,
      value,
      ellipsis,

      /**
       * Временный проп для переопределения стилей, не предназначен для широкого использования.
       * Создан специально для задачи https://
       * TODO: удалить когда появится общий механизм темизации.
       */
      __overrideStyles,
      valueComponent: ValueComponent
    } = this.props;
    const showPrefixPostfix = isDefinedValue(value) && (prefix || postfix) && !(autoComplete && focused);
    const inputBoxProps = {
      autofilled,
      cleanable,
      cursor,
      dataQaType: `${dataQaType}.inputBox`,
      disabled,
      error,
      flatCorners,
      focused,
      hintBlock,
      inputIcon,
      label,
      labelId,
      leftContent,
      readOnly,
      required,
      rightContent,
      informationContent,
      size,
      transparent,
      valid,
      __overrideStyles,
      labelFor: id,
      filled: typeof filled === 'boolean' ? filled : isDefinedValue(value),
      onClean: this.handleCleanerClick
    };

    const inputProps = _extends({
      dataQaType: `${dataQaType}.value`,
      autoFocus,
      cobrowsingSecure,
      disabled,
      id,
      inputMode,
      max,
      maxLength,
      min,
      name,
      onAnimationStart,
      partialPlaceholder,
      pattern,
      placeholder,
      readOnly,
      required,
      step,
      type,
      value,
      __overrideStyles,
      ref: this.setRef,
      onBlur: this.handleBlur,
      onChange: this.handleChange,
      onClick: this.decorateCallback(onClick),
      onFocus: this.decorateCallback(onFocus),
      onInput: this.decorateCallback(onInput),
      onKeyDown: this.decorateCallback(onKeyDown),
      onKeyPress: this.decorateCallback(onKeyPress),
      onKeyUp: this.decorateCallback(onKeyUp),
      onPaste,
      autoComplete: autoCompleteValue(autoComplete),
      ellipsis,
      'aria-controls': ariaControls,
      'aria-autocomplete': ariaAutocomplete,
      'aria-errormessage': ariaErrorMessage,
      'aria-describedby': ariaDescribedBy,
      'aria-invalid': error,
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledby || labelId || this.labelId
    }, showPrefixPostfix ? {
      prefix,
      postfix
    } : {
      minWidth: '100%'
    });

    return /*#__PURE__*/React.createElement(FocusArea, {
      className: styles.root,
      "data-qa-data": typeof dataQaData === 'object' ? JSON.stringify(dataQaData) : dataQaData,
      "data-qa-type": dataQaType
    }, /*#__PURE__*/React.createElement(InputBox, inputBoxProps, ValueComponent ? /*#__PURE__*/React.createElement(ValueComponent, this.props) : /*#__PURE__*/React.createElement(Fragment, null, /*#__PURE__*/React.createElement(postfix || prefix ? PrefixPostfixInputComponent : InputComponent, inputProps))));
  }

}

Input.defaultProps = {
  ariaAutocomplete: null,
  ariaControls: null,
  ariaDescribedBy: null,
  ariaErrorMessage: null,
  autoComplete: false,
  autofilled: false,
  autoFocus: false,
  cleanable: false,
  cobrowsingSecure: false,
  cursor: undefined,
  dataQaType: 'uikit/input',
  disabled: false,
  error: false,
  flatCorners: '',
  focused: false,
  hintBlock: null,
  id: null,
  inputIcon: null,
  inputMode: null,
  label: '',
  labelId: null,
  maxLength: null,
  name: null,
  onAnimationStart: noop,
  onBlur: noop,
  onChange: noop,
  onClean: noop,
  onClick: noop,
  onFocus: noop,
  onInput: noop,
  onKeyDown: noop,
  onKeyPress: noop,
  onKeyUp: noop,
  partialPlaceholder: false,
  pattern: null,
  placeholder: '',
  readOnly: false,
  refCallback: noop,
  required: false,
  size: 'l',
  type: 'text',
  valid: false,
  value: ''
};
process.env.NODE_ENV !== "production" ? Input.propTypes = {
  /**
   * Атрибут aria-label для нативного инпута
   */
  ariaLabel: pt.string,

  /**
   * Атрибут aria-labelledby для нативного инпута
   */
  ariaLabelledby: pt.string,

  /**
   * Атрибут aria-autocomplete для нативного инпута
   */
  ariaAutocomplete: pt.string,

  /**
   * Атрибут aria-controls для нативного инпута
   */
  ariaControls: pt.string,

  /**
   * Атрибут aria-describedby для нативного инпута
   */
  ariaDescribedBy: pt.string,

  /**
   * Атрибут aria-errormessage для нативного инпута
   */
  ariaErrorMessage: pt.string,

  /**
   * Включает autoComplete у нативномого инпута
   */
  autoComplete: pt.oneOfType([pt.bool, pt.string]),

  /**
   * Включает подсветку автозаполнения
   */
  autofilled: pt.bool,

  /**
   * Включает autoFocus у нативного инпута (нужен только для SSR)
   */
  autoFocus: pt.bool,

  /**
   * Включает крестик для очистки поля
   */
  cleanable: pt.bool,

  /**
   * Включает необходимые атрибуты для cobrowsing
   */
  cobrowsingSecure: pt.bool,

  /**
   * Курсор при ховере на поле
   */
  cursor: pt.string,

  /**
   * Атрибут data-qa-data
   */
  dataQaData: pt.oneOfType([pt.string, pt.array, pt.object, pt.number]),

  /**
   * Атрибут data-qa-type
   */
  dataQaType: pt.string,

  /**
   * Состояние disabled
   */
  disabled: pt.bool,

  /**
   * Состояние error
   */
  error: pt.bool,

  /**
   * Состояние filled
   */
  filled: pt.bool,

  /**
   * Отключает скругление углов
   */
  flatCorners: pt.string,

  /**
   * Состояние focused
   */
  focused: pt.bool,

  /**
   * Опции для передачи в focus
   */
  focusOptions: pt.shape({
    preventScroll: pt.bool
  }),

  /**
   * ref переданный через React.forwardRef
   */
  forwardedRef: pt.func,

  /**
   * Слот для вывода подсказки
   */
  hintBlock: pt.node,

  /**
   * Атрибут id для нативного инпута
   */
  id: pt.string,

  /**
   * Контейнер для информации по инпуту (логотип карты, флаг государства и тд.)
   * Контейнер расположен первым за инпутом
   */
  informationContent: pt.node,

  /**
   * Слот для иконки, например стрелка у select, календарь у inputDate, лупа у inputSearch
   */
  inputIcon: pt.node,

  /**
   * Модификация инпута.
   * Позволяет задать тип клавиатуры
   */
  inputMode: pt.string,

  /**
   * Лейбл
   */
  label: pt.node,

  /**
   * Id лейбла
   */
  labelId: pt.string,

  /**
   * Слот для содержимого слева
   */
  leftContent: pt.node,

  /**
   * Максимальное значение для `type="number"`
   */
  max: pt.number,

  /**
   * Ограничивает максимальную длину содержимого инпута
   */
  maxLength: pt.number,

  /**
   * Минимальное значение для `type="number"`
   */
  min: pt.number,

  /**
   * Атрибут name для нативного инпута
   */
  name: pt.string,

  /**
   * Callback события onAnimationStart
   */
  onAnimationStart: pt.func,

  /**
   * Callback события onBlur
   */
  onBlur: pt.func,

  /**
   * Callback события onChange
   */
  onChange: pt.func,

  /**
   * Callback события onClean
   */
  onClean: pt.func,

  /**
   * Callback события onClick
   */
  onClick: pt.func,

  /**
   * Callback события onFocus
   */
  onFocus: pt.func,

  /**
   * Callback события onInput
   */
  onInput: pt.func,

  /**
   * Callback события onKeyDown
   */
  onKeyDown: pt.func,

  /**
   * Callback события onKeyPress
   */
  onKeyPress: pt.func,

  /**
   * Callback события onKeyUp
   */
  onKeyUp: pt.func,

  /**
   * Callback события onPaste
   */
  onPaste: pt.func,

  /**
   * Включает частичный плейсхолдер
   */
  partialPlaceholder: pt.bool,

  /**
   * Паттерн для нативного инпута
   */
  pattern: pt.string,

  /**
   * Текст плейсхолдера
   */
  placeholder: pt.oneOfType([pt.string, pt.object]),

  /**
   * Текст перед значением
   */
  prefix: pt.string,

  /**
   * Текст после значения
   */
  postfix: pt.string,

  /**
   * Состояние readOnly
   */
  readOnly: pt.bool,

  /**
   * Callback для установки рефа на нативный инпут.
   * Deprecated. Используйте ref.
   */
  refCallback: pt.func,

  /**
   * Обязательное поле, помечается звёздочкой
   */
  required: pt.bool,

  /**
   * Слот для содержимого справа
   */
  rightContent: pt.node,

  /**
   * Размер инпута (default: l)
   * Доступные размеры: [l - 56px, m - 44px, s - 32px]
   */
  size: pt.oneOf(['l', 'm', 's']),

  /**
   * Минимальный шаг значения для `type="number"`
   */
  step: pt.number,

  /**
   * Выключает стили контейнера
   */
  transparent: pt.bool,

  /**
   * Атрибут type для нативного инпута
   */
  type: pt.oneOf(['text', 'password', 'email', 'number', 'tel', 'url']),

  /**
   * Включает валидное состояние
   */
  valid: pt.bool,

  /**
   * Значение инпута
   */
  value: pt.oneOfType([pt.number, pt.string]),

  /**
   * Добавляет многоточие в расфокусированном состоянии.
   * Нужен для особых случаев, например readonly-инпут для копирования ссылок, для обычных инпутов применять не
   * рекомендуется
   */
  ellipsis: pt.bool,

  /**
   * Кастомный компонент для отображения значения
   */
  valueComponent: pt.elementType
} : void 0;
const InputWithRef = /*#__PURE__*/forwardRef((props, ref) => /*#__PURE__*/React.createElement(Input, Object.assign({}, props, {
  forwardedRef: ref
})));
InputWithRef.propTypes = Input.propTypes;
InputWithRef.defaultProps = Input.defaultProps;
export default InputWithRef;
