import _extends from "@babel/runtime/helpers/extends";
const tokenRegexp = /(\\.|.)/g;
const maskTransitions = {
  '9': /\d/,
  '&': /\d|,|\.| /,
  // eslint-disable-line no-irregular-whitespace
  '#': /\d| /,
  // eslint-disable-line no-irregular-whitespace
  S: /\d|\//,
  s: /\//,
  '*': /\d|\*|×/,
  $: /\w/,
  '@': /7/,
  '%': /8/,
  H: /[\dа-яёА-ЯЁ]/,
  Z: /[\dа-яА-Яa-zA-Z]/,
  E: /[a-zA-Z\[\];'`\{\}:"<>~,\.\-\s]+|[а-яА-Я\-\sёЁ]+/,
  D: /[a-zA-ZА-Яа-я\-\sёЁ ]/,
  //  pattern for login/phone field (numbers, letters, @_.-),
  L: /\w|[@\.\-]/,
  P: /\w|[+]|\*|×/,
  // pattern for phone field,
  U: /[авекмнорстухabekmhopctyx\d]/i,
  // pattern for drivers license
  R: /[А-ЯЁ]/i,
  T: /[\da-zA-Z]/,
  A: /[а-яёА-ЯЁa-zA-Z]/,
  // rus/eng letters only
  K: /[\wа-яА-ЯёЁ \-\\/]/ // address part

};
export default class Mask {
  constructor(mask, options = {}) {
    this.tokens = void 0;
    this.length = void 0;
    this.maskTransitions = void 0;
    this.editableIndexes = void 0;
    this.fixedPrefix = void 0;
    this.tokens = mask && mask.match(tokenRegexp) || [];
    this.length = this.tokens.length;
    this.maskTransitions = _extends({}, maskTransitions, options.maskTransitions);
    this.editableIndexes = this.tokens.map(token => !!this.maskTransitions[token]);
    this.fixedPrefix = this.mask('');
  } // eslint-disable-next-line complexity,max-statements


  mask(value, caretSymbol = '') {
    if (!this.tokens.length) {
      return value;
    }

    const result = [];
    const restTokens = [...this.tokens];
    const restValue = value.split('');
    let currentValue = restValue.shift();
    let currentToken = restTokens.shift();

    while (currentToken) {
      // если текущий токен - какой то паттерн
      if (this.maskTransitions[currentToken]) {
        if (currentValue) {
          while (currentValue) {
            if (currentValue === caretSymbol) {
              result.push(currentValue);
              currentValue = restValue.shift();
              break;
            } // если текущее значение подходит под паттерн - берем его


            if (this.maskTransitions[currentToken].test(currentValue)) {
              result.push(currentValue);
              currentValue = restValue.shift();
              currentToken = restTokens.shift();
              break;
            }

            currentValue = restValue.shift();
          }
        } else {
          return result.join('');
        }
      } else {
        const tokenSymbol = currentToken.slice(-1); // берем последний символ, тк токен может бьть заэкранированным

        currentToken = restTokens.shift();
        result.push(tokenSymbol);
      }
    }

    const caretSymbolInAppendix = caretSymbol !== '' && (currentValue === caretSymbol || restValue.indexOf(caretSymbol) > -1);
    return result.join('') + (caretSymbolInAppendix ? caretSymbol : '');
  }

  unmask(value = '') {
    if (!this.tokens || !this.tokens.length) {
      return value;
    }

    let result = '';
    value.split('').forEach((char, index) => {
      if (this.maskTransitions[this.tokens[index]]) {
        result += char;
      }
    });
    return result;
  }

  getHintHolder() {
    return this.tokens.map((token, index) => this.editableIndexes[index] ? '_' : token).join('');
  }

}