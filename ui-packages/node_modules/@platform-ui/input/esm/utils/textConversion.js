import _extends from "@babel/runtime/helpers/extends";
import invertObject from './invertObject';
export const LATIN_KEY_CODES = {
  '192': '`',
  '81': 'q',
  '87': 'w',
  '69': 'e',
  '82': 'r',
  '84': 't',
  '89': 'y',
  '85': 'u',
  '73': 'i',
  '79': 'o',
  '80': 'p',
  '219': '[',
  '221': ']',
  '65': 'a',
  '83': 's',
  '68': 'd',
  '70': 'f',
  '71': 'g',
  '72': 'h',
  '74': 'j',
  '75': 'k',
  '76': 'l',
  '186': ';',
  '222': "'",
  '90': 'z',
  '88': 'x',
  '67': 'c',
  '86': 'v',
  '66': 'b',
  '78': 'n',
  '77': 'm',
  '188': ',',
  '190': '.',
  '191': '/'
};
const SHIFTED_LATIN_KEY_CODES = {
  '192': '~',
  '49': '!',
  '50': '@',
  '51': '#',
  '52': '$',
  '53': '%',
  '54': '^',
  '55': '&',
  '56': '*',
  '57': '(',
  '48': ')',
  '219': '{',
  '221': '}',
  '186': ':',
  '222': '"',
  '188': '<',
  '190': '>',
  '191': '?'
};
export const RUS_KEY_CODES = {
  '192': 'ё',
  '81': 'й',
  '87': 'ц',
  '69': 'у',
  '82': 'к',
  '84': 'е',
  '89': 'н',
  '85': 'г',
  '73': 'ш',
  '79': 'щ',
  '80': 'з',
  '219': 'х',
  '221': 'ъ',
  '65': 'ф',
  '83': 'ы',
  '68': 'в',
  '70': 'а',
  '71': 'п',
  '72': 'р',
  '74': 'о',
  '75': 'л',
  '76': 'д',
  '186': 'ж',
  '222': 'э',
  '90': 'я',
  '88': 'ч',
  '67': 'с',
  '86': 'м',
  '66': 'и',
  '78': 'т',
  '77': 'ь',
  '188': 'б',
  '190': 'ю',
  '191': '.'
};
const SHIFTED_RUS_KEY_CODES = {
  '192': 'Ё',
  '49': '!',
  '50': '"',
  '51': '№',
  '52': ';',
  '53': '%',
  '54': ':',
  '55': '?',
  '56': '*',
  '57': '(',
  '48': ')',
  '219': 'Х',
  '221': 'Ъ',
  '186': 'Ж',
  '222': 'Э',
  '188': 'Б',
  '190': 'Ю',
  '191': ','
};
const latinCyrillicOnlyChars = {
  q: 'й',
  w: 'ц',
  e: 'у',
  r: 'к',
  t: 'е',
  y: 'н',
  u: 'г',
  i: 'ш',
  o: 'щ',
  p: 'з',
  a: 'ф',
  s: 'ы',
  d: 'в',
  f: 'а',
  g: 'п',
  h: 'р',
  j: 'о',
  k: 'л',
  l: 'д',
  z: 'я',
  x: 'ч',
  c: 'с',
  v: 'м',
  b: 'и',
  n: 'т',
  m: 'ь',
  Q: 'Й',
  W: 'Ц',
  E: 'У',
  R: 'К',
  T: 'Е',
  Y: 'Н',
  U: 'Г',
  I: 'Ш',
  O: 'Щ',
  P: 'З',
  A: 'Ф',
  S: 'Ы',
  D: 'В',
  F: 'А',
  G: 'П',
  H: 'Р',
  J: 'О',
  K: 'Л',
  L: 'Д',
  Z: 'Я',
  X: 'Ч',
  C: 'С',
  V: 'М',
  B: 'И',
  N: 'Т',
  M: 'Ь'
};

function isLatinLetter(char) {
  return char in latinCyrillicOnlyChars;
}

const cyrillicLatinOnlyCharsExtend = {
  б: ',',
  ю: '.',
  ж: ';',
  э: "'",
  х: '[',
  ъ: ']',
  ё: '`',
  Б: '<',
  Ю: '>',
  Ж: ':',
  Э: '"',
  Х: '{',
  Ъ: '}',
  Ё: '~'
};

const cyrillicLatinOnlyChars = _extends({}, invertObject(latinCyrillicOnlyChars), cyrillicLatinOnlyCharsExtend);

function isCyrillicLetter(char) {
  return char in cyrillicLatinOnlyChars;
}

const convertStr = convertCharFn => (str, options) => {
  const strOrig = str.toString();
  let resultStr = '';

  for (let i = 0, ln = strOrig.length; i < ln; i++) {
    const char = strOrig.charAt(i);
    resultStr += convertCharFn(char, options);
  }

  return resultStr;
};

const toCyrillicOnlyChar = char => isLatinLetter(char) ? latinCyrillicOnlyChars[char] : char;

const toLatinOnlyChar = char => isCyrillicLetter(char) ? cyrillicLatinOnlyChars[char] : char;

const userAgentsSkipCodes = {
  isIOS: ['188', '190', '191', '192', '186', '222', '219', '221']
};
/* eslint-disable no-param-reassign, max-params */

export const simpleCharByKeyCode = (newSymbol, keydown, switchLayout, userAgents) => {
  const keyMap = switchLayout === 'toCyrillic' ? RUS_KEY_CODES : LATIN_KEY_CODES;
  const shiftKeyMap = switchLayout === 'toCyrillic' ? SHIFTED_RUS_KEY_CODES : SHIFTED_LATIN_KEY_CODES;
  const isLiteral = newSymbol.toUpperCase() !== newSymbol.toLowerCase();
  let upperCase = newSymbol === newSymbol.toUpperCase() && isLiteral;
  let strKeyCode = keydown.code.toString();
  /**
   * OS Bugfixes
   * В мобильной раскладке IOS символы ,.;:'"[]{} некорректно конвертировались в кириллицу, решено через userAgentsSkipCodes
   * Если в дальнейшем будут какие-то еще проблемы на конкретных устройствах/браузерах, skipCodes можно дополнять
   * При расширении userAgentsSkipCodes нужно так же не забыть дополнить мап в charByKeyCode
   */

  if (userAgents) {
    const skipCodes = Object.keys(userAgentsSkipCodes).filter(userAgent => userAgents[userAgent]).reduce((acc, agent) => {
      if (agent in userAgentsSkipCodes) {
        return [...acc, ...userAgentsSkipCodes[agent]];
      }

      return acc;
    }, []);

    if (skipCodes.indexOf(strKeyCode) !== -1) {
      return newSymbol;
    }
  }
  /**
   * MacOS bugfix
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode
   *
   * The purpose of these new additional rules is for making users whose keyboard layouts map unicode characters
   * to punctuation keys in a US keyboard layout can use web applications which support Firefox only with ASCII-capable
   * keyboard layouts or just with a US keyboard layout. Otherwise, the newly mapped keyCode values may be conflict
   * with other keys. For example, if the active keyboard layout is Russian, the keyCode value of both the "Period" key
   * and "Slash" key are 190 (KeyEvent.DOM_VK_PERIOD). If you need to distinguish those keys but you don't want
   * to support all keyboard layouts in the world by yourself, you should probably use KeyboardEvent.code.
   */


  if (keydown.name === 'Slash' && keydown.code === 190) {
    strKeyCode = '191';
  }

  function isBaseKey(key) {
    return key in keyMap;
  }

  function isShiftKey(key) {
    return key in shiftKeyMap;
  }

  if (keydown.shift && isShiftKey(strKeyCode)) {
    newSymbol = shiftKeyMap[strKeyCode];
  } else {
    newSymbol = isBaseKey(strKeyCode) ? keyMap[strKeyCode] : newSymbol;
  }

  if (!isLiteral && newSymbol.toUpperCase() !== newSymbol.toLowerCase()) {
    upperCase = keydown.shift;
  }

  if (upperCase) {
    newSymbol = newSymbol.toUpperCase();
  }

  return newSymbol;
};
/* eslint-enable */

export const IS_SERVER_RUNTIME = !(typeof window !== 'undefined' && window.document);

const memoizeUserAgent = fn => {
  if (IS_SERVER_RUNTIME) {
    return () => false;
  }

  let result;
  return () => {
    if (result === undefined) {
      result = fn();
    }

    return result;
  };
};

export const isIOS = memoizeUserAgent(() => {
  const iosPlatforms = ['iPhone', 'iPad', 'iPod'];

  if (window.navigator) {
    return iosPlatforms.indexOf(window.navigator.platform) !== -1;
  }

  return false;
});
export const charByKeyCode = (newSymbol, keydown, switchLayout) => {
  return simpleCharByKeyCode(newSymbol, keydown, switchLayout, {
    isIOS: isIOS()
  });
};
export const toCyrillicOnlyCharStr = convertStr(toCyrillicOnlyChar);
export const toLatinOnlyCharStr = convertStr(toLatinOnlyChar);