"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

exports.__esModule = true;
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var tokenRegexp = /(\\.|.)/g;
var maskTransitions = {
  '9': /\d/,
  '&': /\d|,|\.| /,
  // eslint-disable-line no-irregular-whitespace
  '#': /\d| /,
  // eslint-disable-line no-irregular-whitespace
  S: /\d|\//,
  s: /\//,
  '*': /\d|\*|×/,
  $: /\w/,
  '@': /7/,
  '%': /8/,
  H: /[\dа-яёА-ЯЁ]/,
  Z: /[\dа-яА-Яa-zA-Z]/,
  E: /[a-zA-Z\[\];'`\{\}:"<>~,\.\-\s]+|[а-яА-Я\-\sёЁ]+/,
  D: /[a-zA-ZА-Яа-я\-\sёЁ ]/,
  //  pattern for login/phone field (numbers, letters, @_.-),
  L: /\w|[@\.\-]/,
  P: /\w|[+]|\*|×/,
  // pattern for phone field,
  U: /[авекмнорстухabekmhopctyx\d]/i,
  // pattern for drivers license
  R: /[А-ЯЁ]/i,
  T: /[\da-zA-Z]/,
  A: /[а-яёА-ЯЁa-zA-Z]/,
  // rus/eng letters only
  K: /[\wа-яА-ЯёЁ \-\\/]/ // address part

};

var Mask = /*#__PURE__*/function () {
  function Mask(mask, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    this.tokens = void 0;
    this.length = void 0;
    this.maskTransitions = void 0;
    this.editableIndexes = void 0;
    this.fixedPrefix = void 0;
    this.tokens = mask && mask.match(tokenRegexp) || [];
    this.length = this.tokens.length;
    this.maskTransitions = (0, _extends2.default)({}, maskTransitions, options.maskTransitions);
    this.editableIndexes = this.tokens.map(function (token) {
      return !!_this.maskTransitions[token];
    });
    this.fixedPrefix = this.mask('');
  } // eslint-disable-next-line complexity,max-statements


  var _proto = Mask.prototype;

  _proto.mask = function mask(value, caretSymbol) {
    if (caretSymbol === void 0) {
      caretSymbol = '';
    }

    if (!this.tokens.length) {
      return value;
    }

    var result = [];
    var restTokens = [].concat(this.tokens);
    var restValue = value.split('');
    var currentValue = restValue.shift();
    var currentToken = restTokens.shift();

    while (currentToken) {
      // если текущий токен - какой то паттерн
      if (this.maskTransitions[currentToken]) {
        if (currentValue) {
          while (currentValue) {
            if (currentValue === caretSymbol) {
              result.push(currentValue);
              currentValue = restValue.shift();
              break;
            } // если текущее значение подходит под паттерн - берем его


            if (this.maskTransitions[currentToken].test(currentValue)) {
              result.push(currentValue);
              currentValue = restValue.shift();
              currentToken = restTokens.shift();
              break;
            }

            currentValue = restValue.shift();
          }
        } else {
          return result.join('');
        }
      } else {
        var tokenSymbol = currentToken.slice(-1); // берем последний символ, тк токен может бьть заэкранированным

        currentToken = restTokens.shift();
        result.push(tokenSymbol);
      }
    }

    var caretSymbolInAppendix = caretSymbol !== '' && (currentValue === caretSymbol || restValue.indexOf(caretSymbol) > -1);
    return result.join('') + (caretSymbolInAppendix ? caretSymbol : '');
  };

  _proto.unmask = function unmask(value) {
    var _this2 = this;

    if (value === void 0) {
      value = '';
    }

    if (!this.tokens || !this.tokens.length) {
      return value;
    }

    var result = '';
    value.split('').forEach(function (char, index) {
      if (_this2.maskTransitions[_this2.tokens[index]]) {
        result += char;
      }
    });
    return result;
  };

  _proto.getHintHolder = function getHintHolder() {
    var _this3 = this;

    return this.tokens.map(function (token, index) {
      return _this3.editableIndexes[index] ? '_' : token;
    }).join('');
  };

  return Mask;
}();

exports.default = Mask;