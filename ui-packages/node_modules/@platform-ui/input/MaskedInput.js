"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

exports.__esModule = true;
exports.default = void 0;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _react = _interopRequireWildcard(require("react"));

var _keycode = _interopRequireDefault(require("keycode"));

var _getActiveElement = require("./utils/getActiveElement");

var _ReactInputSelection = require("./utils/ReactInputSelection");

var _mask = _interopRequireDefault(require("./utils/mask"));

var _StatelessInput = _interopRequireWildcard(require("./StatelessInput"));

var _excluded = ["inputComponent", "type", "placeholder", "partialPlaceholder", "hintholder", "value"];

var isFocused = function isFocused(element) {
  return (0, _getActiveElement.getActiveElement)() === element;
};

var INITIAL_SELECTION = {
  start: 0,
  end: 0
};
var inputTypes = ['text', 'search', 'password', 'tel', 'url']; // https://html.spec.whatwg.org/multipage/input.html#the-input-element:dom-textarea/input-selectionstart-3

var fixInputType = function fixInputType(type) {
  return type && inputTypes.indexOf(type) === -1 ? 'text' : type;
};

var caretSymbol = '⿵';

var cut = function cut(str, cutFrom, cutTo, replacement) {
  if (replacement === void 0) {
    replacement = '';
  }

  return str.slice(0, cutFrom) + replacement + str.slice(cutTo);
};

var editableDiff = function editableDiff(indexesFrom, indexesTo, until) {
  if (indexesFrom === void 0) {
    indexesFrom = [];
  }

  if (indexesTo === void 0) {
    indexesTo = [];
  }

  if (until === void 0) {
    until = 0;
  }

  var i;
  var editableCount = 0; // Считаем, сколько редактируемых позиций было до курсора

  for (i = 0; i < until; i++) {
    if (indexesFrom[i] !== false) {
      editableCount++;
    }
  } // Отсчитываем столько же редактируемых позиций с новой маской


  for (i = 0; editableCount > 0; i++) {
    if (indexesTo[i] !== false) {
      editableCount--;
    }
  }

  return i - until;
};

// eslint-disable-next-line react/no-unsafe
var MaskedInput = /*#__PURE__*/function (_PureComponent) {
  (0, _inheritsLoose2.default)(MaskedInput, _PureComponent);

  function MaskedInput(props) {
    var _this;

    _this = _PureComponent.call(this, props) || this;
    _this.input = void 0;
    _this.mask = void 0;
    _this.syncState = void 0;

    _this.refInput = function (ref) {
      _this.input = ref;
      _this.props.refCallback && _this.props.refCallback(ref);
    };

    _this.hasValue = function (value) {
      return (0, _StatelessInput.isDefinedValue)(value) && (_this.props.showMaskPrefix ? true : value !== _this.mask.fixedPrefix);
    };

    _this.handleBlur = function (event, _ref) {
      var rest = (0, _extends2.default)({}, _ref);
      var fieldDoneStrategy = _this.props.fieldDoneStrategy;
      var _this$syncState = _this.syncState,
          maskedValue = _this$syncState.maskedValue,
          value = _this$syncState.value;
      _this.props.onBlur && _this.props.onBlur(event, (0, _extends2.default)({}, rest, {
        value: value,
        maskedValue: maskedValue
      }));

      if ((fieldDoneStrategy === 'blur' || fieldDoneStrategy === 'lastCharBlur') && maskedValue.length === _this.mask.length && _this.mask.length > 0) {
        _this.props.onFieldDone && _this.props.onFieldDone(event, (0, _extends2.default)({}, rest, {
          value: value,
          maskedValue: maskedValue
        }));
      }
    };

    _this.handleFocus = function (event, _ref2) {
      var rest = (0, _extends2.default)({}, _ref2);
      var _this$syncState2 = _this.syncState,
          maskedValue = _this$syncState2.maskedValue,
          value = _this$syncState2.value;

      _this.adjustCaret();

      _this.props.onFocus && _this.props.onFocus(event, (0, _extends2.default)({}, rest, {
        value: value,
        maskedValue: maskedValue
      }));
    };

    _this.handleClick = function () {
      var _this$props;

      _this.adjustCaret();

      _this.props.onClick && (_this$props = _this.props).onClick.apply(_this$props, arguments);
    };

    _this.handleChange = function (event, params) {
      _this.updateInput(event, params, params.value, _this.selection.start);
    };

    _this.handleKeyDown = function (event, params) {
      var _this$selection = _this.selection,
          start = _this$selection.start,
          end = _this$selection.end;
      var code = (0, _keycode.default)(event);
      var shiftKey = event.shiftKey,
          ctrlKey = event.ctrlKey,
          metaKey = event.metaKey;
      var readOnly = _this.props.readOnly;
      var isDelete = code === 'delete';
      var isBackspace = code === 'backspace';
      var isArrowUp = code === 'up';
      var isArrowLeft = code === 'left';
      var isArrowRight = code === 'right';

      if (start !== end && !isArrowLeft && !isArrowRight || shiftKey || ctrlKey || metaKey || !(isDelete || isBackspace || isArrowLeft || isArrowRight || isArrowUp)) {
        _this.props.onKeyDown && _this.props.onKeyDown(event, params);
        return;
      }

      event.preventDefault();
      event.stopPropagation();
      var newCaretPosition;
      var newMaskedValue = _this.syncState.maskedValue;

      if (!readOnly) {
        switch (true) {
          case isArrowUp:
            newCaretPosition = _this.mask.fixedPrefix.length;
            break;

          case isArrowRight:
            newCaretPosition = _this.calcNextEditPosition(end, 1);
            break;

          case isArrowLeft:
            newCaretPosition = _this.calcNextEditPosition(start, -1);
            break;

          case isDelete:
            {
              var cutUntil = _this.calcNextEditPosition(start, 1);

              newCaretPosition = Math.max(start, _this.calcNextEditPosition(cutUntil, -1));
              newMaskedValue = cut(newMaskedValue, newCaretPosition, cutUntil);
              break;
            }

          case isBackspace:
            newCaretPosition = _this.calcNextEditPosition(start, -1);
            newMaskedValue = cut(newMaskedValue, newCaretPosition, start);
            break;
        }
      }

      _this.props.onKeyDown && _this.props.onKeyDown(event, params);
      !readOnly && _this.updateInput(event, params, newMaskedValue, newCaretPosition);
    };

    _this.initMask(props);

    var _props$value = props.value,
        val = _props$value === void 0 ? '' : _props$value,
        _maskedValue = props.maskedValue;

    var _value;

    if (_maskedValue !== undefined) {
      _value = _this.mask.unmask(_maskedValue);
    } else {
      _value = val;
    }

    _this.syncState = {
      value: _value,
      maskedValue: _this.mask.mask(_value)
    };
    return _this;
  }

  var _proto = MaskedInput.prototype;

  _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
    var _nextProps$value = nextProps.value,
        val = _nextProps$value === void 0 ? '' : _nextProps$value,
        maskedValueProp = nextProps.maskedValue;
    var isMaskChanged = this.shouldUpdateMask(nextProps);
    var currentEditableIndexes = this.mask.editableIndexes;
    var value = '';

    if (maskedValueProp !== undefined) {
      value = this.mask.unmask(maskedValueProp);
    } else {
      value = val;
    }

    isMaskChanged && this.initMask(nextProps);
    var maskedValue = maskedValueProp !== undefined ? maskedValueProp : this.mask.mask(value);
    var isMaskedValueChanged = maskedValue !== this.syncState.maskedValue;

    if (isMaskChanged && isMaskedValueChanged) {
      var end = this.selection.end;
      this.updateInput(null, {}, maskedValue, this.calcNextEditPosition(end + editableDiff(currentEditableIndexes, this.mask.editableIndexes, end), 1));
    }

    if (isMaskedValueChanged) {
      this.syncState = {
        value: value,
        maskedValue: maskedValue
      };
      this.forceUpdate();
    }
  };

  _proto.getPlaceholderProps = function getPlaceholderProps() {
    var _this$props2 = this.props,
        value = _this$props2.value,
        placeholder = _this$props2.placeholder,
        partialPlaceholder = _this$props2.partialPlaceholder,
        hintholder = _this$props2.hintholder,
        focused = _this$props2.focused;
    var empty = !this.hasValue(value);

    if (!hintholder) {
      if (empty) {
        return {
          placeholder: placeholder,
          partialPlaceholder: focused
        };
      }

      return {
        placeholder: placeholder,
        partialPlaceholder: partialPlaceholder
      };
    }

    var hintholderText = focused ? this.mask.getHintHolder() : '';

    if (empty) {
      return {
        placeholder: placeholder || hintholderText,
        partialPlaceholder: true
      };
    }

    return {
      placeholder: hintholderText,
      partialPlaceholder: true
    };
  };

  _proto.adjustCaret = function adjustCaret() {
    if (!this.input) {
      return;
    }

    var selection = {
      start: this.input.selectionStart,
      end: this.input.selectionEnd
    };
    var fixedPrefixLength = this.mask.fixedPrefix.length;

    if (fixedPrefixLength > 0 && selection.start === selection.end && selection.start < fixedPrefixLength) {
      this.selection = {
        start: fixedPrefixLength,
        end: fixedPrefixLength
      };
    }
  } // eslint-disable-next-line max-statements, max-params
  ;

  _proto.updateInput = function updateInput(event, params, pureValue, caretPosition, force) {
    var maskedValue = pureValue;

    if (maskedValue !== this.syncState.maskedValue || force) {
      maskedValue = cut(maskedValue, caretPosition, caretPosition, caretSymbol);
      var prefixIndex = maskedValue.indexOf(this.mask.fixedPrefix);

      if (prefixIndex !== -1) {
        maskedValue = cut(maskedValue, prefixIndex, prefixIndex + this.mask.fixedPrefix.length);
      }

      maskedValue = this.mask.mask(maskedValue, caretSymbol); // eslint-disable-next-line no-param-reassign

      caretPosition = maskedValue.indexOf(caretSymbol);
      maskedValue = cut(maskedValue, caretPosition, caretPosition + 1);

      if (this.input) {
        this.input.value = maskedValue;
      }

      if (maskedValue !== this.syncState.maskedValue) {
        var value = this.mask.unmask(maskedValue);
        var payload = (0, _extends2.default)({}, params, {
          name: this.props.name,
          value: value,
          pureValue: pureValue,
          maskedValue: maskedValue,
          caretPosition: caretPosition
        });
        this.syncState = {
          value: value,
          maskedValue: maskedValue
        };
        this.props.onChange && this.props.onChange(event, payload);

        if (maskedValue.length === this.mask.length && this.mask.length > 0) {
          if (this.props.fieldDoneStrategy === 'anyInput' || (this.props.fieldDoneStrategy === 'lastCharInput' || this.props.fieldDoneStrategy === 'lastCharBlur') && (!this.props.focused || caretPosition >= this.mask.length)) {
            this.props.onFieldDone && this.props.onFieldDone(event, payload);
          }
        }
      }
    }

    this.selection = {
      start: caretPosition,
      end: caretPosition
    };
  };

  _proto.calcNextEditPosition = function calcNextEditPosition(firstPos, sign) {
    var result = firstPos + sign;
    var fixedPrefixLength = this.mask.fixedPrefix.length;

    if (result <= fixedPrefixLength) {
      return fixedPrefixLength;
    }

    if (this.mask.length === 0) {
      return result;
    }

    if (result > this.mask.length) {
      return this.mask.length;
    }

    while (result > 0 && result <= this.mask.length && !this.mask.editableIndexes[sign < 0 ? result : result - 1]) {
      result += sign;
    }

    return result;
  };

  _proto.shouldUpdateMask = function shouldUpdateMask(nextProps) {
    return nextProps.mask !== this.props.mask || nextProps.maskTransitions !== this.props.maskTransitions;
  };

  _proto.initMask = function initMask(props) {
    this.mask = new _mask.default(props.mask, {
      maskTransitions: props.maskTransitions
    });
  };

  _proto.render = function render() {
    var _this$props3 = this.props,
        _this$props3$inputCom = _this$props3.inputComponent,
        InputComponent = _this$props3$inputCom === void 0 ? _StatelessInput.default : _this$props3$inputCom,
        type = _this$props3.type,
        placeholder = _this$props3.placeholder,
        partialPlaceholder = _this$props3.partialPlaceholder,
        hintholder = _this$props3.hintholder,
        value = _this$props3.value,
        otherProps = (0, _objectWithoutPropertiesLoose2.default)(_this$props3, _excluded);
    var maskedValue = this.syncState.maskedValue;
    return /*#__PURE__*/_react.default.createElement(InputComponent, Object.assign({}, otherProps, this.getPlaceholderProps(), {
      refCallback: this.refInput,
      onKeyDown: this.handleKeyDown,
      onChange: this.handleChange,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur,
      onClick: this.handleClick,
      value: maskedValue,
      filled: this.hasValue(maskedValue || value),
      type: fixInputType(type)
    }));
  };

  (0, _createClass2.default)(MaskedInput, [{
    key: "selection",
    get: function get() {
      if (this.input) {
        return (0, _ReactInputSelection.getSelection)(this.input);
      }

      return INITIAL_SELECTION;
    },
    set: function set(selection) {
      // в мобильном сафари при попытке сменить позицию каретки ставится фокус на поле, поэтому проверка на фокус
      if (this.input && isFocused(this.input)) {
        (0, _ReactInputSelection.setSelection)(this.input, selection);
      }
    }
  }]);
  return MaskedInput;
}(_react.PureComponent);

MaskedInput.defaultProps = {
  dataQaType: 'uikit/input',
  size: 'l',
  maskTransitions: {},
  fieldDoneStrategy: 'anyInput'
};
var _default = MaskedInput;
exports.default = _default;