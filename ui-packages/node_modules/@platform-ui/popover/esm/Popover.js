import _extends from "@babel/runtime/helpers/extends";
import pt from 'prop-types';
import React, { PureComponent } from 'react';
import cn from 'classnames';
import Portal, { PortalContext } from '@platform-ui/portal';
import dataQa from '@platform-ui/dataQa';
import { isTouchDevice } from '@platform-ui/device-info';
import PopoverBlock from './PopoverBlock';
import { setPosition, getViewportRect, isInPopover, onRectChange } from './utils';
import s from './Popover.module.css';

const noop = () => {};

const FADE_DELAY = 100;
export const propTypes = {
  direction: pt.oneOfType([pt.oneOf(['left', 'top', 'right', 'bottom']), pt.array]),
  align: pt.oneOf(['start', 'center', 'end', 'stretch'])
};

const isOpened = ({
  active,
  isInactive
}) => Boolean(!isInactive && active);

class Popover extends PureComponent {
  /* eslint-disable max-statements, complexity */

  /* eslint-enable max-statements, complexity */
  constructor(props) {
    super(props);

    this.open = () => {
      if (!this.state.active) {
        this.setState({
          active: true
        });
        this.props.onShow(_extends({}, this.state, {
          active: true
        }));
      }
    };

    this.close = ({
      isActive
    } = this.props) => {
      if (!isActive) {
        this.setState({
          active: false
        });
      }

      this.props.onClose(_extends({}, this.state, {
        active: false
      }));
    };

    this.toggle = ({
      active
    } = this.state) => (active ? this.close : this.open)();

    this.setTooltipPosition = () => {
      if (!this.state.active || !this.popover || !this.childrenBlock) {
        return;
      }

      const {
        direction,
        align,
        additionalShift,
        onActiveToggle,
        windowMargin,
        customPadding,
        smartDirection,
        minArrowOffset
      } = this.props;
      let childrenRect = this.childrenBlock.getBoundingClientRect();
      const viewportRect = getViewportRect(this.popoverContainer.parentNode);
      const containerRect = this.popoverContainer.getBoundingClientRect();
      const containerOffsets = {
        top: 0,
        left: 0
      };

      if (window && this.popoverContainer === document.body) {
        containerOffsets.top = containerRect.top + window.pageYOffset;
        containerOffsets.left = containerRect.left + window.pageXOffset;
      }

      childrenRect = {
        width: childrenRect.width,
        height: childrenRect.height,
        top: childrenRect.top - containerRect.top,
        left: childrenRect.left - containerRect.left,
        right: childrenRect.right - containerRect.left,
        bottom: childrenRect.bottom - containerRect.top
      };
      const {
        scrollTop
      } = this.popoverContainer;
      const options = {
        viewportRect,
        popoverRect: this.popover.getBoundingClientRect(),
        childrenRect,
        containerRect,
        containerOffsets,
        containerScroll: scrollTop >= 0 ? scrollTop : document.documentElement.scrollTop,
        smartDirection,
        align,
        windowMargin,
        additionalShift,
        customPadding,
        minArrowOffset,
        direction
      };
      const [newDirection, {
        tooltipStyle = {},
        cornerStyle = {}
      }] = setPosition(options);
      this.setState({
        left: tooltipStyle.left,
        top: tooltipStyle.top,
        width: tooltipStyle.width,
        height: tooltipStyle.height,
        direction: newDirection
      });
      onActiveToggle(newDirection, cornerStyle);
    };

    this.setChildrenBlock = elem => {
      this.childrenBlock = elem;
    };

    this.setPopover = elem => {
      this.popover = elem;

      if (elem) {
        this.animationDisabled = parseFloat(window.getComputedStyle(elem).getPropertyValue('animation-duration')) === 0;
      }
    };

    this.setPopoverContainer = elem => {
      this.popoverContainer = elem;
    };

    this.offChildrenBlockRectChange = noop;

    this.handleClick = event => {
      const {
        preventDefaultClick,
        closeOnPopoverClick,
        onClick
      } = this.props;

      if (preventDefaultClick) {
        event.preventDefault();
      }

      if (this.getToggleOnClick() && isInPopover(event.target, this.childrenBlock)) {
        this.toggle();
      } else if (closeOnPopoverClick && isInPopover(event.target, this.popover)) {
        this.close();
      }

      onClick(event);
    };

    this.handleClickOutside = e => {
      if (this.props.hideOnClickOutside && !isInPopover(e.target, this.childrenBlock) && !isInPopover(e.target, this.popover) && this.state.active) {
        var _this$props$onClickOu, _this$props;

        this.close();
        (_this$props$onClickOu = (_this$props = this.props).onClickOutside) == null ? void 0 : _this$props$onClickOu.call(_this$props, e);
      }
    };

    this.handleChildrenOver = e => {
      if (!this.props.noBubbleHover || isInPopover(e.target, this.childrenBlock)) {
        clearTimeout(this.closeTimeout);
      }

      if (!this.props.hoverDelay) {
        this.open();
      } else {
        this.openTimeout = setTimeout(this.open, this.props.hoverDelay);
      }
    };

    this.handleChildrenOut = () => {
      clearTimeout(this.openTimeout);
      this.closeTimeout = setTimeout(this.close, FADE_DELAY);
    };

    this.handleWindowResize = () => {
      if (this.props.hideOnResize) {
        this.close();
      }
    };

    this.handleWindowTouchMove = () => {
      if (this.props.hideOnTouchMove) {
        this.close();
      }
    };

    this.state = {
      active: props.isActive || false,
      toggleOnClick: this.getToggleOnClick()
    };
    this.animationDisabled = false;
    props.getSetPositionFunc(this.setTooltipPosition);
  }

  static getDerivedStateFromProps(props, state) {
    if (state.active !== props.isActive && props.isActive !== undefined) {
      return {
        active: props.isActive
      };
    }

    return null;
  }

  componentDidMount() {
    if (this.state.active) {
      this.addListeners();
    }
  }

  componentDidUpdate(_, prevState) {
    if (prevState.active !== this.state.active) {
      if (this.state.active) {
        this.addListeners();
      } else {
        this.removeListeners();
      }
    }
  }

  componentWillUnmount() {
    this.removeListeners();
  }

  addListeners() {
    window.addEventListener('resize', this.handleWindowResize);
    window.addEventListener('touchmove', this.handleWindowTouchMove);
    window.addEventListener('click', this.handleClickOutside);
    this.offChildrenBlockRectChange();
    this.offChildrenBlockRectChange = onRectChange(() => {
      if (!this.childrenBlock || !this.popoverContainer || !this.popover) {
        return null;
      }

      const childrenRect = this.childrenBlock.getBoundingClientRect();
      const containerRect = this.popoverContainer.getBoundingClientRect();
      const relativeChildrenRect = {
        top: childrenRect.top - containerRect.top,
        left: childrenRect.left - containerRect.left,
        width: childrenRect.width,
        height: childrenRect.height
      };
      return relativeChildrenRect;
    }, () => {
      this.setTooltipPosition();
    });
  }

  removeListeners() {
    window.removeEventListener('resize', this.handleWindowResize);
    window.removeEventListener('touchmove', this.handleWindowTouchMove);
    window.removeEventListener('click', this.handleClickOutside);
    this.offChildrenBlockRectChange();
    this.offChildrenBlockRectChange = noop;
  }

  getToggleOnClick() {
    return this.props.toggleOnClick || isTouchDevice();
  }

  render() {
    const {
      ariaOwnsId,
      isInactive,
      children,
      dataQaType,
      popoverBlock,
      renderPopoverBlock,
      increasedTouchZone,
      zIndex,
      wide,
      role,
      ariaDescribedBy,
      animated,
      disableToggleOnInsideEvents,
      to,
      disabled,
      toBody,
      blockStyles = {},
      portalTagName
    } = this.props;
    const {
      direction,
      left,
      top,
      active,
      width,
      height
    } = this.state;
    const toggleOnClick = this.getToggleOnClick();
    return /*#__PURE__*/React.createElement("span", Object.assign({}, dataQa({
      dataQaType
    }), {
      className: cn({
        [s.popover]: true,
        [s.popover_wide]: wide,
        [s.popover_disabled]: disabled
      }),
      role: role,
      "aria-describedby": ariaDescribedBy,
      "aria-owns": ariaOwnsId
    }, !disableToggleOnInsideEvents ? {
      onClick: this.handleClick,
      onMouseEnter: !toggleOnClick ? this.handleChildrenOver : undefined,
      onMouseLeave: !toggleOnClick ? this.handleChildrenOut : undefined
    } : {}), /*#__PURE__*/React.createElement("span", {
      ref: this.setChildrenBlock,
      className: s.childrenBlock,
      "data-qa-type": `${dataQaType}.children`
    }, children), /*#__PURE__*/React.createElement(Portal, {
      to: to,
      toBody: toBody,
      exitRef: this.setPopoverContainer,
      tagName: portalTagName
    }, /*#__PURE__*/React.createElement(PopoverBlock, {
      popoverBlock: popoverBlock || renderPopoverBlock(this.close),
      increasedTouchZone: typeof increasedTouchZone === 'boolean' ? increasedTouchZone : !toggleOnClick,
      refCallback: this.setPopover,
      direction: direction,
      animated: animated,
      animationDisabled: this.animationDisabled,
      dataQaType: `${dataQaType}.popoverBlock`,
      style: _extends({
        top,
        left,
        zIndex,
        width,
        height
      }, blockStyles),
      opened: isOpened({
        active,
        isInactive
      })
    })));
  }

}

Popover.contextType = PortalContext;
Popover.defaultProps = {
  dataQaType: 'uikit/popover',
  preventDefaultClick: false,
  animated: true,
  ariaOwnsId: null,
  toggleOnClick: false,
  onActiveToggle: noop,
  onClick: noop,
  direction: 'bottom',
  smartDirection: true,
  hideOnResize: false,
  renderPopoverBlock: noop,
  windowMargin: 18,
  increasedTouchZone: true,
  additionalShift: 0,
  customPadding: 0,
  zIndex: 100,
  hoverDelay: 0,
  wide: false,
  closeOnPopoverClick: true,
  noBubbleHover: false,
  role: null,
  isInactive: false,
  ariaDescribedBy: null,
  onClose: noop,
  onShow: noop,
  getSetPositionFunc: noop,
  align: 'center',
  minArrowOffset: 0,
  hideOnTouchMove: false,
  hideOnClickOutside: true,
  disableToggleOnInsideEvents: false
};
process.env.NODE_ENV !== "production" ? Popover.propTypes = {
  /**
   * Флаг для preventDefault на событие click
   */
  preventDefaultClick: pt.bool,

  /**
   * Задает атибут aria-owns, принимает id блока-владельца
   */
  ariaOwnsId: pt.string,

  /**
   * Принудительно отображает содержимое prop popoverContent
   */
  isActive: pt.bool,

  /**
   * Принудительно скрывает содержимое prop popoverContent
   */
  isInactive: pt.bool,

  /**
   * появление только по клику на элемент
   */
  toggleOnClick: pt.bool,

  /**
   * конент блока, к которому прикреплена всплывашка
   */
  children: pt.node,

  /**
   * направление/массив приоритетов направлений появления всплывашки
   */
  direction: propTypes.direction,

  /**
   * флаг умного определения позиции всплывашки, не дающего вылазить ей за экран
   */
  smartDirection: pt.bool,

  /**
   * Флаг, скрывать ли компонент при ресайзе
   */
  hideOnResize: pt.bool,

  /**
   * контент всплывашки
   */
  popoverBlock: pt.node,

  /**
   * Функция для рендера всплывашки, принимающая this.close в качестве аргумента.
   * Нужна для компонентов, где требуется ручное закрытие Popover.
   */
  renderPopoverBlock: pt.func,

  /**
   * отступ от границ контейнера (ближайший PortalContainer или body)
   */
  windowMargin: pt.number,

  /**
   * Выравнивание всплывашки относительно контента
   */
  align: propTypes.align,

  /**
   * Увеличенная ховер-зона вокруг всплывашки
   */
  increasedTouchZone: pt.bool,

  /**
   * Кастомный сдвиг перпендикулярно текущему направлению всплывашки
   */
  additionalShift: pt.number,

  /**
   * Кастомный отступ от контента
   */
  customPadding: pt.number,

  /**
   * Задержка появления при ховере
   */
  hoverDelay: pt.number,

  /**
   * Кастомный z-index (без крайней необходимости не использовать)
   */
  zIndex: pt.number,

  /**
   * Флаг, растягивает компонент на 100% по W x H
   */
  wide: pt.bool,

  /**
   * Скрывать поповер по клику на него
   */
  closeOnPopoverClick: pt.bool,

  /**
   * Скрывать поповер по ховеру на него
   */
  noBubbleHover: pt.bool,

  /**
   * ВНИМАНИЕ: нейминг пропа не соответствует фактическому назначению:
   * Обработчик отвечает за изменение позиции самого поповера и уголка.
   * Для обработки открытия/закрытия нужно использовать onClose
   */
  onActiveToggle: pt.func,
  onClick: pt.func,

  /**
   * Обработчик срабатывает при деактивации Popover'a
   */
  onClose: pt.func,

  /**
   * Обработчик срабатывает при активации Popover'a
   */
  onShow: pt.func,

  /**
   * Позволяет получить снаружи функцию для явного пересчета позиции тултипа (подробнее в README)
   */
  getSetPositionFunc: pt.func,

  /**
   * Aтрибут role компонента
   */
  role: pt.string,

  /**
   * Атрибут aria-describedby компонента
   */
  ariaDescribedBy: pt.string,

  /**
   * Атрибут data-qa-type компонента
   */
  dataQaType: pt.string,

  /**
   * Флаг анимированого появления/скрытия компонента
   */
  animated: pt.bool,

  /**
   * Задает ограничения для позиционирования стрелок относительно краев
   */
  minArrowOffset: pt.number,

  /**
   * Включает скрытие PopoverBlock на мобильных при событии TouchMove
   */
  hideOnTouchMove: pt.bool,

  /**
   * Включает скрытие поповера по внешнему клику
   */
  hideOnClickOutside: pt.bool,

  /**
   * Отключает показ/скрытие по событиям внутри Popover (onClick, onMouseEnter, onMouseLeave)
   * [UIKIT-5013]
   */
  disableToggleOnInsideEvents: pt.bool,

  /**
   *  Принудительно рендерит контент в <body>
   *  @deprecated используйте to='body'
   */
  toBody: pt.bool,

  /**
   * Куда рендерить контент: `body` либо значение `exitId` нужного PortalExit
   */
  to: pt.string,

  /**
   * Обработчик на клик вне Popover'а
   */
  onClickOutside: pt.func,

  /**
   * Инлайн-стили блока с контентом
   */
  // eslint-disable-next-line react/forbid-prop-types
  blockStyles: pt.object,

  /**
   * Тег создаваемый порталом
   */
  portalTagName: pt.string
} : void 0;
export default Popover;