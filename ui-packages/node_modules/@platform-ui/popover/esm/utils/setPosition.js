import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
const _excluded = ["smartDirection"];
import { setPositionStart } from './setPositionStart';
import { setPositionCenter } from './setPositionCenter';
import { setPositionEnd } from './setPositionEnd';
import { isEnoughSpace } from './isEnoughSpace';
import { getDirectionsQueue } from './getDirectionsQueue';
import { getAlignsQueue } from './getAlignsQueue';
import { setPositionAuto } from './setPositionAuto';
const setPositionMap = {
  start: setPositionStart,
  center: setPositionCenter,
  end: setPositionEnd,
  stretch: setPositionCenter,
  auto: setPositionAuto
};

const setPosMethod = _ref => {
  let {
    smartDirection
  } = _ref,
      args = _objectWithoutPropertiesLoose(_ref, _excluded);

  if (smartDirection && !isEnoughSpace(args)) {
    return;
  }

  return setPositionMap[args.align](args);
};

export function setPosition(options) {
  const directionsQueue = getDirectionsQueue(options.direction);
  const directionsQueueLength = directionsQueue.length;
  const mainDirection = directionsQueue[0];
  const mainAlign = options.align;
  let result;
  let direction;
  let alignsQueue;
  let alignsQueueLength;
  let i;
  let j;

  for (i = 0; !result && i < directionsQueueLength; i++) {
    direction = directionsQueue[i];
    alignsQueue = getAlignsQueue(mainDirection, mainAlign, direction);
    alignsQueueLength = alignsQueue.length;

    for (j = 0; !result && j < alignsQueueLength; j++) {
      result = setPosMethod(_extends({}, options, {
        direction,
        align: alignsQueue[j]
      }));
    }
  } // если тултип вылезает по всем границам, то берем иначально заданное направление


  if (!result) {
    direction = mainDirection;
    result = setPosMethod(_extends({}, options, {
      direction,
      smartDirection: false
    }));
  }

  return [direction, result];
}