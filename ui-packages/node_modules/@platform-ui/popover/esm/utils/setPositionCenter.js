const maxOffset = (offset, border, size, parentSize = 0) => {
  const sign = offset >= 0 ? 1 : -1;
  const limit = sign * ((size + parentSize) / 2 - border);
  return offset >= 0 ? Math.min(limit, offset) : Math.max(limit, offset);
};

const setHorizontal = ({
  direction,
  childrenRect,
  popoverRect,
  windowMargin,
  containerScroll,
  additionalShift,
  customPadding,
  minArrowOffset,
  align,
  containerOffsets
}) => {
  const tooltipStyle = {
    left: direction === 'right' ? childrenRect.right + customPadding + containerOffsets.left : childrenRect.left - popoverRect.width - customPadding + containerOffsets.left,
    top: childrenRect.top + (childrenRect.height - popoverRect.height) / 2 + containerScroll + maxOffset(additionalShift, minArrowOffset, popoverRect.height, childrenRect.height) + containerOffsets.top
  };
  const cornerStyle = {
    marginTop: -maxOffset(additionalShift, minArrowOffset, popoverRect.height)
  };
  const realWindowMargin = Math.min(windowMargin, childrenRect.top);

  if (tooltipStyle.top < realWindowMargin) {
    cornerStyle.marginTop = (cornerStyle.marginTop || 0) + tooltipStyle.top - realWindowMargin;
    tooltipStyle.top = realWindowMargin;
  }

  if (align === 'stretch') {
    tooltipStyle.top = childrenRect.top + containerOffsets.top;
    tooltipStyle.height = childrenRect.height;
  }

  return {
    tooltipStyle,
    cornerStyle
  };
};

const setVertical = ({
  direction,
  childrenRect,
  popoverRect,
  windowMargin,
  containerRect,
  additionalShift,
  customPadding,
  minArrowOffset,
  align,
  containerOffsets
}) => {
  const tooltipStyle = {
    top: direction === 'top' ? childrenRect.top - popoverRect.height - customPadding + containerOffsets.top : childrenRect.bottom + customPadding + containerOffsets.top,
    left: 0
  };
  const cornerStyle = {};
  const left = childrenRect.left + (childrenRect.width - popoverRect.width) / 2 + maxOffset(additionalShift, minArrowOffset, popoverRect.width, childrenRect.width);
  let realWindowMargin = Math.min(windowMargin, childrenRect.left); // не даем вылезти тултипу за экран

  if (left < realWindowMargin) {
    tooltipStyle.left = realWindowMargin;
    cornerStyle.marginLeft = left - realWindowMargin; // двигаем уголок к центру компонента
  } else {
    const right = containerRect.width - (childrenRect.width + popoverRect.width) / 2 - childrenRect.left - maxOffset(additionalShift, minArrowOffset, popoverRect.width, childrenRect.width);
    realWindowMargin = Math.min(windowMargin, containerRect.width - childrenRect.right);

    if (right < realWindowMargin) {
      tooltipStyle.left = left + right - realWindowMargin;
      cornerStyle.marginLeft = realWindowMargin - right;
    } else {
      tooltipStyle.left = left + containerOffsets.left;
      cornerStyle.marginLeft = 0;
    }
  }

  cornerStyle.marginLeft -= maxOffset(additionalShift, minArrowOffset, popoverRect.width);

  if (align === 'stretch') {
    tooltipStyle.left = childrenRect.left + containerOffsets.left;
    tooltipStyle.width = childrenRect.width;
  }

  return {
    tooltipStyle,
    cornerStyle
  };
};

export function setPositionCenter(args) {
  switch (args.direction) {
    case 'left':
    case 'right':
      return setHorizontal(args);

    case 'top':
    case 'bottom':
      return setVertical(args);
  }
}