"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

exports.__esModule = true;
exports.propTypes = exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _portal = _interopRequireWildcard(require("@platform-ui/portal"));

var _dataQa = _interopRequireDefault(require("@platform-ui/dataQa"));

var _deviceInfo = require("@platform-ui/device-info");

var _PopoverBlock = _interopRequireDefault(require("./PopoverBlock"));

var _utils = require("./utils");

var _PopoverModule = _interopRequireDefault(require("./Popover.module.css"));

var noop = function noop() {};

var FADE_DELAY = 100;
var propTypes = {
  direction: _propTypes.default.oneOfType([_propTypes.default.oneOf(['left', 'top', 'right', 'bottom']), _propTypes.default.array]),
  align: _propTypes.default.oneOf(['start', 'center', 'end', 'stretch'])
};
exports.propTypes = propTypes;

var isOpened = function isOpened(_ref) {
  var active = _ref.active,
      isInactive = _ref.isInactive;
  return Boolean(!isInactive && active);
};

var Popover = /*#__PURE__*/function (_PureComponent) {
  (0, _inheritsLoose2.default)(Popover, _PureComponent);

  /* eslint-disable max-statements, complexity */

  /* eslint-enable max-statements, complexity */
  function Popover(props) {
    var _this;

    _this = _PureComponent.call(this, props) || this;

    _this.open = function () {
      if (!_this.state.active) {
        _this.setState({
          active: true
        });

        _this.props.onShow((0, _extends2.default)({}, _this.state, {
          active: true
        }));
      }
    };

    _this.close = function (_temp) {
      var _ref2 = _temp === void 0 ? _this.props : _temp,
          isActive = _ref2.isActive;

      if (!isActive) {
        _this.setState({
          active: false
        });
      }

      _this.props.onClose((0, _extends2.default)({}, _this.state, {
        active: false
      }));
    };

    _this.toggle = function (_temp2) {
      var _ref3 = _temp2 === void 0 ? _this.state : _temp2,
          active = _ref3.active;

      return (active ? _this.close : _this.open)();
    };

    _this.setTooltipPosition = function () {
      if (!_this.state.active || !_this.popover || !_this.childrenBlock) {
        return;
      }

      var _this$props = _this.props,
          direction = _this$props.direction,
          align = _this$props.align,
          additionalShift = _this$props.additionalShift,
          onActiveToggle = _this$props.onActiveToggle,
          windowMargin = _this$props.windowMargin,
          customPadding = _this$props.customPadding,
          smartDirection = _this$props.smartDirection,
          minArrowOffset = _this$props.minArrowOffset;

      var childrenRect = _this.childrenBlock.getBoundingClientRect();

      var viewportRect = (0, _utils.getViewportRect)(_this.popoverContainer.parentNode);

      var containerRect = _this.popoverContainer.getBoundingClientRect();

      var containerOffsets = {
        top: 0,
        left: 0
      };

      if (window && _this.popoverContainer === document.body) {
        containerOffsets.top = containerRect.top + window.pageYOffset;
        containerOffsets.left = containerRect.left + window.pageXOffset;
      }

      childrenRect = {
        width: childrenRect.width,
        height: childrenRect.height,
        top: childrenRect.top - containerRect.top,
        left: childrenRect.left - containerRect.left,
        right: childrenRect.right - containerRect.left,
        bottom: childrenRect.bottom - containerRect.top
      };
      var scrollTop = _this.popoverContainer.scrollTop;
      var options = {
        viewportRect: viewportRect,
        popoverRect: _this.popover.getBoundingClientRect(),
        childrenRect: childrenRect,
        containerRect: containerRect,
        containerOffsets: containerOffsets,
        containerScroll: scrollTop >= 0 ? scrollTop : document.documentElement.scrollTop,
        smartDirection: smartDirection,
        align: align,
        windowMargin: windowMargin,
        additionalShift: additionalShift,
        customPadding: customPadding,
        minArrowOffset: minArrowOffset,
        direction: direction
      };

      var _setPosition = (0, _utils.setPosition)(options),
          newDirection = _setPosition[0],
          _setPosition$ = _setPosition[1],
          _setPosition$$tooltip = _setPosition$.tooltipStyle,
          tooltipStyle = _setPosition$$tooltip === void 0 ? {} : _setPosition$$tooltip,
          _setPosition$$cornerS = _setPosition$.cornerStyle,
          cornerStyle = _setPosition$$cornerS === void 0 ? {} : _setPosition$$cornerS;

      _this.setState({
        left: tooltipStyle.left,
        top: tooltipStyle.top,
        width: tooltipStyle.width,
        height: tooltipStyle.height,
        direction: newDirection
      });

      onActiveToggle(newDirection, cornerStyle);
    };

    _this.setChildrenBlock = function (elem) {
      _this.childrenBlock = elem;
    };

    _this.setPopover = function (elem) {
      _this.popover = elem;

      if (elem) {
        _this.animationDisabled = parseFloat(window.getComputedStyle(elem).getPropertyValue('animation-duration')) === 0;
      }
    };

    _this.setPopoverContainer = function (elem) {
      _this.popoverContainer = elem;
    };

    _this.offChildrenBlockRectChange = noop;

    _this.handleClick = function (event) {
      var _this$props2 = _this.props,
          preventDefaultClick = _this$props2.preventDefaultClick,
          closeOnPopoverClick = _this$props2.closeOnPopoverClick,
          onClick = _this$props2.onClick;

      if (preventDefaultClick) {
        event.preventDefault();
      }

      if (_this.getToggleOnClick() && (0, _utils.isInPopover)(event.target, _this.childrenBlock)) {
        _this.toggle();
      } else if (closeOnPopoverClick && (0, _utils.isInPopover)(event.target, _this.popover)) {
        _this.close();
      }

      onClick(event);
    };

    _this.handleClickOutside = function (e) {
      if (_this.props.hideOnClickOutside && !(0, _utils.isInPopover)(e.target, _this.childrenBlock) && !(0, _utils.isInPopover)(e.target, _this.popover) && _this.state.active) {
        _this.close();

        _this.props.onClickOutside == null ? void 0 : _this.props.onClickOutside(e);
      }
    };

    _this.handleChildrenOver = function (e) {
      if (!_this.props.noBubbleHover || (0, _utils.isInPopover)(e.target, _this.childrenBlock)) {
        clearTimeout(_this.closeTimeout);
      }

      if (!_this.props.hoverDelay) {
        _this.open();
      } else {
        _this.openTimeout = setTimeout(_this.open, _this.props.hoverDelay);
      }
    };

    _this.handleChildrenOut = function () {
      clearTimeout(_this.openTimeout);
      _this.closeTimeout = setTimeout(_this.close, FADE_DELAY);
    };

    _this.handleWindowResize = function () {
      if (_this.props.hideOnResize) {
        _this.close();
      }
    };

    _this.handleWindowTouchMove = function () {
      if (_this.props.hideOnTouchMove) {
        _this.close();
      }
    };

    _this.state = {
      active: props.isActive || false,
      toggleOnClick: _this.getToggleOnClick()
    };
    _this.animationDisabled = false;
    props.getSetPositionFunc(_this.setTooltipPosition);
    return _this;
  }

  Popover.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (state.active !== props.isActive && props.isActive !== undefined) {
      return {
        active: props.isActive
      };
    }

    return null;
  };

  var _proto = Popover.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.state.active) {
      this.addListeners();
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate(_, prevState) {
    if (prevState.active !== this.state.active) {
      if (this.state.active) {
        this.addListeners();
      } else {
        this.removeListeners();
      }
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.removeListeners();
  };

  _proto.addListeners = function addListeners() {
    var _this2 = this;

    window.addEventListener('resize', this.handleWindowResize);
    window.addEventListener('touchmove', this.handleWindowTouchMove);
    window.addEventListener('click', this.handleClickOutside);
    this.offChildrenBlockRectChange();
    this.offChildrenBlockRectChange = (0, _utils.onRectChange)(function () {
      if (!_this2.childrenBlock || !_this2.popoverContainer || !_this2.popover) {
        return null;
      }

      var childrenRect = _this2.childrenBlock.getBoundingClientRect();

      var containerRect = _this2.popoverContainer.getBoundingClientRect();

      var relativeChildrenRect = {
        top: childrenRect.top - containerRect.top,
        left: childrenRect.left - containerRect.left,
        width: childrenRect.width,
        height: childrenRect.height
      };
      return relativeChildrenRect;
    }, function () {
      _this2.setTooltipPosition();
    });
  };

  _proto.removeListeners = function removeListeners() {
    window.removeEventListener('resize', this.handleWindowResize);
    window.removeEventListener('touchmove', this.handleWindowTouchMove);
    window.removeEventListener('click', this.handleClickOutside);
    this.offChildrenBlockRectChange();
    this.offChildrenBlockRectChange = noop;
  };

  _proto.getToggleOnClick = function getToggleOnClick() {
    return this.props.toggleOnClick || (0, _deviceInfo.isTouchDevice)();
  };

  _proto.render = function render() {
    var _cn;

    var _this$props3 = this.props,
        ariaOwnsId = _this$props3.ariaOwnsId,
        isInactive = _this$props3.isInactive,
        children = _this$props3.children,
        dataQaType = _this$props3.dataQaType,
        popoverBlock = _this$props3.popoverBlock,
        renderPopoverBlock = _this$props3.renderPopoverBlock,
        increasedTouchZone = _this$props3.increasedTouchZone,
        zIndex = _this$props3.zIndex,
        wide = _this$props3.wide,
        role = _this$props3.role,
        ariaDescribedBy = _this$props3.ariaDescribedBy,
        animated = _this$props3.animated,
        disableToggleOnInsideEvents = _this$props3.disableToggleOnInsideEvents,
        to = _this$props3.to,
        disabled = _this$props3.disabled,
        toBody = _this$props3.toBody,
        _this$props3$blockSty = _this$props3.blockStyles,
        blockStyles = _this$props3$blockSty === void 0 ? {} : _this$props3$blockSty,
        portalTagName = _this$props3.portalTagName;
    var _this$state = this.state,
        direction = _this$state.direction,
        left = _this$state.left,
        top = _this$state.top,
        active = _this$state.active,
        width = _this$state.width,
        height = _this$state.height;
    var toggleOnClick = this.getToggleOnClick();
    return /*#__PURE__*/_react.default.createElement("span", Object.assign({}, (0, _dataQa.default)({
      dataQaType: dataQaType
    }), {
      className: (0, _classnames.default)((_cn = {}, _cn[_PopoverModule.default.popover] = true, _cn[_PopoverModule.default.popover_wide] = wide, _cn[_PopoverModule.default.popover_disabled] = disabled, _cn)),
      role: role,
      "aria-describedby": ariaDescribedBy,
      "aria-owns": ariaOwnsId
    }, !disableToggleOnInsideEvents ? {
      onClick: this.handleClick,
      onMouseEnter: !toggleOnClick ? this.handleChildrenOver : undefined,
      onMouseLeave: !toggleOnClick ? this.handleChildrenOut : undefined
    } : {}), /*#__PURE__*/_react.default.createElement("span", {
      ref: this.setChildrenBlock,
      className: _PopoverModule.default.childrenBlock,
      "data-qa-type": dataQaType + ".children"
    }, children), /*#__PURE__*/_react.default.createElement(_portal.default, {
      to: to,
      toBody: toBody,
      exitRef: this.setPopoverContainer,
      tagName: portalTagName
    }, /*#__PURE__*/_react.default.createElement(_PopoverBlock.default, {
      popoverBlock: popoverBlock || renderPopoverBlock(this.close),
      increasedTouchZone: typeof increasedTouchZone === 'boolean' ? increasedTouchZone : !toggleOnClick,
      refCallback: this.setPopover,
      direction: direction,
      animated: animated,
      animationDisabled: this.animationDisabled,
      dataQaType: dataQaType + ".popoverBlock",
      style: (0, _extends2.default)({
        top: top,
        left: left,
        zIndex: zIndex,
        width: width,
        height: height
      }, blockStyles),
      opened: isOpened({
        active: active,
        isInactive: isInactive
      })
    })));
  };

  return Popover;
}(_react.PureComponent);

Popover.contextType = _portal.PortalContext;
Popover.defaultProps = {
  dataQaType: 'uikit/popover',
  preventDefaultClick: false,
  animated: true,
  ariaOwnsId: null,
  toggleOnClick: false,
  onActiveToggle: noop,
  onClick: noop,
  direction: 'bottom',
  smartDirection: true,
  hideOnResize: false,
  renderPopoverBlock: noop,
  windowMargin: 18,
  increasedTouchZone: true,
  additionalShift: 0,
  customPadding: 0,
  zIndex: 100,
  hoverDelay: 0,
  wide: false,
  closeOnPopoverClick: true,
  noBubbleHover: false,
  role: null,
  isInactive: false,
  ariaDescribedBy: null,
  onClose: noop,
  onShow: noop,
  getSetPositionFunc: noop,
  align: 'center',
  minArrowOffset: 0,
  hideOnTouchMove: false,
  hideOnClickOutside: true,
  disableToggleOnInsideEvents: false
};
process.env.NODE_ENV !== "production" ? Popover.propTypes = {
  /**
   * Флаг для preventDefault на событие click
   */
  preventDefaultClick: _propTypes.default.bool,

  /**
   * Задает атибут aria-owns, принимает id блока-владельца
   */
  ariaOwnsId: _propTypes.default.string,

  /**
   * Принудительно отображает содержимое prop popoverContent
   */
  isActive: _propTypes.default.bool,

  /**
   * Принудительно скрывает содержимое prop popoverContent
   */
  isInactive: _propTypes.default.bool,

  /**
   * появление только по клику на элемент
   */
  toggleOnClick: _propTypes.default.bool,

  /**
   * конент блока, к которому прикреплена всплывашка
   */
  children: _propTypes.default.node,

  /**
   * направление/массив приоритетов направлений появления всплывашки
   */
  direction: propTypes.direction,

  /**
   * флаг умного определения позиции всплывашки, не дающего вылазить ей за экран
   */
  smartDirection: _propTypes.default.bool,

  /**
   * Флаг, скрывать ли компонент при ресайзе
   */
  hideOnResize: _propTypes.default.bool,

  /**
   * контент всплывашки
   */
  popoverBlock: _propTypes.default.node,

  /**
   * Функция для рендера всплывашки, принимающая this.close в качестве аргумента.
   * Нужна для компонентов, где требуется ручное закрытие Popover.
   */
  renderPopoverBlock: _propTypes.default.func,

  /**
   * отступ от границ контейнера (ближайший PortalContainer или body)
   */
  windowMargin: _propTypes.default.number,

  /**
   * Выравнивание всплывашки относительно контента
   */
  align: propTypes.align,

  /**
   * Увеличенная ховер-зона вокруг всплывашки
   */
  increasedTouchZone: _propTypes.default.bool,

  /**
   * Кастомный сдвиг перпендикулярно текущему направлению всплывашки
   */
  additionalShift: _propTypes.default.number,

  /**
   * Кастомный отступ от контента
   */
  customPadding: _propTypes.default.number,

  /**
   * Задержка появления при ховере
   */
  hoverDelay: _propTypes.default.number,

  /**
   * Кастомный z-index (без крайней необходимости не использовать)
   */
  zIndex: _propTypes.default.number,

  /**
   * Флаг, растягивает компонент на 100% по W x H
   */
  wide: _propTypes.default.bool,

  /**
   * Скрывать поповер по клику на него
   */
  closeOnPopoverClick: _propTypes.default.bool,

  /**
   * Скрывать поповер по ховеру на него
   */
  noBubbleHover: _propTypes.default.bool,

  /**
   * ВНИМАНИЕ: нейминг пропа не соответствует фактическому назначению:
   * Обработчик отвечает за изменение позиции самого поповера и уголка.
   * Для обработки открытия/закрытия нужно использовать onClose
   */
  onActiveToggle: _propTypes.default.func,
  onClick: _propTypes.default.func,

  /**
   * Обработчик срабатывает при деактивации Popover'a
   */
  onClose: _propTypes.default.func,

  /**
   * Обработчик срабатывает при активации Popover'a
   */
  onShow: _propTypes.default.func,

  /**
   * Позволяет получить снаружи функцию для явного пересчета позиции тултипа (подробнее в README)
   */
  getSetPositionFunc: _propTypes.default.func,

  /**
   * Aтрибут role компонента
   */
  role: _propTypes.default.string,

  /**
   * Атрибут aria-describedby компонента
   */
  ariaDescribedBy: _propTypes.default.string,

  /**
   * Атрибут data-qa-type компонента
   */
  dataQaType: _propTypes.default.string,

  /**
   * Флаг анимированого появления/скрытия компонента
   */
  animated: _propTypes.default.bool,

  /**
   * Задает ограничения для позиционирования стрелок относительно краев
   */
  minArrowOffset: _propTypes.default.number,

  /**
   * Включает скрытие PopoverBlock на мобильных при событии TouchMove
   */
  hideOnTouchMove: _propTypes.default.bool,

  /**
   * Включает скрытие поповера по внешнему клику
   */
  hideOnClickOutside: _propTypes.default.bool,

  /**
   * Отключает показ/скрытие по событиям внутри Popover (onClick, onMouseEnter, onMouseLeave)
   * [UIKIT-5013]
   */
  disableToggleOnInsideEvents: _propTypes.default.bool,

  /**
   *  Принудительно рендерит контент в <body>
   *  @deprecated используйте to='body'
   */
  toBody: _propTypes.default.bool,

  /**
   * Куда рендерить контент: `body` либо значение `exitId` нужного PortalExit
   */
  to: _propTypes.default.string,

  /**
   * Обработчик на клик вне Popover'а
   */
  onClickOutside: _propTypes.default.func,

  /**
   * Инлайн-стили блока с контентом
   */
  // eslint-disable-next-line react/forbid-prop-types
  blockStyles: _propTypes.default.object,

  /**
   * Тег создаваемый порталом
   */
  portalTagName: _propTypes.default.string
} : void 0;
var _default = Popover;
exports.default = _default;