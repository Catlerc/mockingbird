"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

exports.__esModule = true;
exports.setPositionAuto = setPositionAuto;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _excluded = ["direction", "childrenRect", "popoverRect", "windowMargin", "containerScroll", "additionalShift", "customPadding", "minArrowOffset", "align", "containerOffsets"];

var maxOffset = function maxOffset(offset, border, size, parentSize) {
  if (parentSize === void 0) {
    parentSize = 0;
  }

  var sign = offset >= 0 ? 1 : -1;
  var limit = sign * ((size + parentSize) / 2 - border);
  return offset >= 0 ? Math.min(limit, offset) : Math.max(limit, offset);
};

var setHorizontal = function setHorizontal(_ref) {
  var direction = _ref.direction,
      childrenRect = _ref.childrenRect,
      popoverRect = _ref.popoverRect,
      windowMargin = _ref.windowMargin,
      containerScroll = _ref.containerScroll,
      additionalShift = _ref.additionalShift,
      customPadding = _ref.customPadding,
      minArrowOffset = _ref.minArrowOffset,
      align = _ref.align,
      containerOffsets = _ref.containerOffsets,
      otherArgs = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
  var tooltipStyle = {
    left: direction === 'right' ? childrenRect.right + customPadding + containerOffsets.left : childrenRect.left - popoverRect.width - customPadding + containerOffsets.left,
    top: childrenRect.top + (childrenRect.height - popoverRect.height) / 2 + containerScroll + maxOffset(additionalShift, minArrowOffset, popoverRect.height, childrenRect.height) + containerOffsets.top
  };
  var cornerStyle = {
    marginTop: -maxOffset(additionalShift, minArrowOffset, popoverRect.height)
  };
  var realWindowMargin = Math.min(windowMargin, childrenRect.top);

  if (tooltipStyle.top < realWindowMargin) {
    cornerStyle.marginTop = (cornerStyle.marginTop || 0) + tooltipStyle.top - realWindowMargin;
    tooltipStyle.top = realWindowMargin;
  }

  if (align === 'stretch') {
    tooltipStyle.top = childrenRect.top + containerOffsets.top;
    tooltipStyle.height = childrenRect.height;
  }

  if (tooltipStyle.top + popoverRect.height - otherArgs.viewportRect.bottom > 0) {
    tooltipStyle.top -= tooltipStyle.top + popoverRect.height - otherArgs.viewportRect.bottom;
  }

  return {
    tooltipStyle: tooltipStyle,
    cornerStyle: cornerStyle
  };
};

var setVertical = function setVertical(_ref2) {
  var direction = _ref2.direction,
      childrenRect = _ref2.childrenRect,
      popoverRect = _ref2.popoverRect,
      windowMargin = _ref2.windowMargin,
      containerRect = _ref2.containerRect,
      additionalShift = _ref2.additionalShift,
      customPadding = _ref2.customPadding,
      minArrowOffset = _ref2.minArrowOffset,
      align = _ref2.align,
      containerOffsets = _ref2.containerOffsets;
  var tooltipStyle = {
    top: direction === 'top' ? childrenRect.top - popoverRect.height - customPadding + containerOffsets.top : childrenRect.bottom + customPadding + containerOffsets.top,
    left: 0
  };
  var cornerStyle = {};
  var left = childrenRect.left + (childrenRect.width - popoverRect.width) / 2 + maxOffset(additionalShift, minArrowOffset, popoverRect.width, childrenRect.width);
  var realWindowMargin = Math.min(windowMargin, childrenRect.left); // не даем вылезти тултипу за экран

  if (left < realWindowMargin) {
    tooltipStyle.left = realWindowMargin;
    cornerStyle.marginLeft = left - realWindowMargin; // двигаем уголок к центру компонента
  } else {
    var right = containerRect.width - (childrenRect.width + popoverRect.width) / 2 - childrenRect.left - maxOffset(additionalShift, minArrowOffset, popoverRect.width, childrenRect.width);
    realWindowMargin = Math.min(windowMargin, containerRect.width - childrenRect.right);

    if (right < realWindowMargin) {
      tooltipStyle.left = left + right - realWindowMargin;
      cornerStyle.marginLeft = realWindowMargin - right;
    } else {
      tooltipStyle.left = left + containerOffsets.left;
      cornerStyle.marginLeft = 0;
    }
  }

  cornerStyle.marginLeft -= maxOffset(additionalShift, minArrowOffset, popoverRect.width);

  if (align === 'stretch') {
    tooltipStyle.left = childrenRect.left + containerOffsets.left;
    tooltipStyle.width = childrenRect.width;
  }

  return {
    tooltipStyle: tooltipStyle,
    cornerStyle: cornerStyle
  };
};

function setPositionAuto(args) {
  switch (args.direction) {
    case 'left':
    case 'right':
      return setHorizontal(args);

    case 'top':
    case 'bottom':
      return setVertical(args);
  }
}