import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
const _excluded = ["items"];
import React, { useMemo } from 'react';
import MenuItem from './MenuItem';
import styles from './Menu.module.css';

const Menu = props => {
  const {
    items,
    underlined,
    onClick,
    align = 'left',
    dataQaType,
    dataQaData
  } = props;
  const [contextMenuIndex, setContextMenuIndex] = React.useState(items.length - 1);
  const memoizedContextItems = useMemo(() => items.slice(contextMenuIndex + 1, items.length).map(_ref => {
    let itemProps = _objectWithoutPropertiesLoose(_ref, _excluded);

    return _extends({
      onClick
    }, itemProps);
  }), [contextMenuIndex, items, onClick]);
  const rootRef = React.useRef(null);
  React.useEffect(() => {
    const root = rootRef.current;

    if (root === null) {
      return;
    }

    const indexMap = new WeakMap();
    let lastVisibleIndex = items.length - 1;

    if (typeof IntersectionObserver !== 'undefined') {
      const observer = new IntersectionObserver(entries => {
        entries.forEach(entry => {
          const index = indexMap.get(entry.target);
          const visible = entry.intersectionRatio > 0;

          if (visible && index > lastVisibleIndex) {
            lastVisibleIndex = index;
          }

          if (!visible && index <= lastVisibleIndex) {
            lastVisibleIndex = index - 1;
          }
        });
        setContextMenuIndex(lastVisibleIndex);
      }, {
        root,
        rootMargin: '-1px'
      });
      /**
       * Chrome до 51 версии не поддерживает forEach в NodeList,
       * а полифила может не оказаться, по этому перебираем через for
       * https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach
       */

      for (let i = 0; i < root.childNodes.length; i++) {
        indexMap.set(root.childNodes[i], i);
        observer.observe(root.childNodes[i]);
      }

      return () => {
        observer.disconnect();
      };
    }
    /**
     * Для старых браузеров делаем фолбэк на ресайз окна
     * Этого должно быть достаточно, т.к. навигация у нас во всю ширину
     */


    const onWindowResize = () => {
      const rootRect = root.getBoundingClientRect(); // Нулевой элемент всегда виден, поэтому > а не >= и установка индекса после цикла

      for (let i = root.childNodes.length - 1; i > 0; i--) {
        const child = root.childNodes[i];
        const childRect = child.getBoundingClientRect();

        if (childRect.top === rootRect.top) {
          setContextMenuIndex(i);
          return;
        }
      }

      setContextMenuIndex(0);
    };

    onWindowResize();
    window.addEventListener('resize', onWindowResize);
    return () => {
      window.removeEventListener('resize', onWindowResize);
    };
  }, [items]);
  return /*#__PURE__*/React.createElement("nav", {
    ref: rootRef,
    className: `${styles.root} ${styles[`root_align_${align}`]}`,
    "data-qa-type": dataQaType || 'uikit/navigation.menu',
    "data-qa-data": dataQaData
  }, items.map((itemProps, index) => {
    return /*#__PURE__*/React.createElement(MenuItem, Object.assign({
      key: itemProps.id || index,
      hidden: index > contextMenuIndex,
      contextItems: index === contextMenuIndex && index < items.length - 1 ? memoizedContextItems : undefined,
      underlined: underlined,
      onClick: onClick
    }, itemProps));
  }));
};

export default Menu;