import React, { Component } from 'react';
import hoistStatics from 'hoist-non-react-statics';
import head from '@tinkoff/utils/array/head';
import isFunction from '@tinkoff/utils/is/function';
const DRAG_THRESHOLD = 4; // величина в px, необходимая чтобы отличить клик от дрега
// eslint-disable-next-line no-shadow

const dragName = Component => `Drag(${Component.displayName || Component.name || 'Component(!)'})`; // eslint-disable-next-line compat/compat


const noopPromiseFunc = () => new Promise(resolve => resolve());
/**
 * @deprecated Используйте @platform-ui/draggable
 */


const drag = WrappedComponent => {
  class dragDecorator extends Component {
    constructor() {
      super();

      this.setRef = node => {
        this.wrappedComponent = node;
      };

      this.onDragMouseDown = () => {
        document.addEventListener('mousemove', this.onDragMouseMoveBind);
        document.addEventListener('touchmove', this.onDragMouseMoveBind);
        document.addEventListener('mouseup', this.onDragMouseUpBind);
        document.addEventListener('touchend', this.onDragMouseUpBind);
      };

      this.onDragMouseMove = event => {
        const {
          wrappedComponent
        } = this;

        if (wrappedComponent) {
          if (!wrappedComponent.allowDefaultAction) {
            event.preventDefault();
          }

          const touch = head(event.touches) || event;
          const currentPosition = {
            x: touch.pageX,
            y: touch.pageY,
            clientX: touch.clientX,
            clientY: touch.clientY
          };

          if (!wrappedComponent.props.noDragThreshold && Math.abs(currentPosition.x - wrappedComponent.dragStartPosition.x) < DRAG_THRESHOLD && Math.abs(currentPosition.y - wrappedComponent.dragStartPosition.y) < DRAG_THRESHOLD) {
            return;
          }

          isFunction(wrappedComponent.props.onDragStart) && wrappedComponent.props.onDragStart(wrappedComponent.startIndex);

          if (wrappedComponent.dragPrevPosition.x !== currentPosition.x || wrappedComponent.dragPrevPosition.y !== currentPosition.y) {
            isFunction(wrappedComponent.onDragProcess) && wrappedComponent.onDragProcess(currentPosition, wrappedComponent.dragPrevPosition, wrappedComponent.dragStartPosition, event);
            wrappedComponent.dragPrevPosition = currentPosition;
          }
        }
      };

      this.onDragMouseUp = event => {
        const {
          wrappedComponent
        } = this;

        if (wrappedComponent) {
          if (!wrappedComponent.allowDefaultAction) {
            event.stopPropagation();
            event.preventDefault();
          }

          const touch = head(event.changedTouches) || event;
          isFunction(wrappedComponent.onDragEnd) && wrappedComponent.onDragEnd({
            x: touch.pageX,
            y: touch.pageY,
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          wrappedComponent.dragStartPosition = {};
          wrappedComponent.dragPrevPosition = {};
        }

        document.removeEventListener('mousemove', this.onDragMouseMoveBind);
        document.removeEventListener('touchmove', this.onDragMouseMoveBind);
        document.removeEventListener('mouseup', this.onDragMouseUpBind);
        document.removeEventListener('touchend', this.onDragMouseUpBind);
      };

      this.handleDrag = event => {
        const {
          wrappedComponent
        } = this;

        if (wrappedComponent) {
          if (!wrappedComponent.allowDefaultAction) {
            event.stopPropagation();
            event.preventDefault();
          }

          const touch = head(event.touches) || event;
          wrappedComponent.dragStartPosition = {
            x: touch.pageX,
            y: touch.pageY,
            clientX: touch.clientX,
            clientY: touch.clientY
          };
          wrappedComponent.dragPrevPosition = wrappedComponent.dragStartPosition;
          isFunction(wrappedComponent.beforeDragStart) && wrappedComponent.beforeDragStart(wrappedComponent.dragStartPosition);
          (wrappedComponent.props.beforeDragStart || noopPromiseFunc)(wrappedComponent.startIndex).then(() => {
            this.onDragMouseDown(event);
            isFunction(wrappedComponent.onDragStart) && wrappedComponent.onDragStart(wrappedComponent.dragStartPosition, event);
          });
        }
      };

      this.onDragMouseMoveBind = event => this.onDragMouseMove(event);

      this.onDragMouseUpBind = event => this.onDragMouseUp(event);
    }

    componentWillUnmount() {
      document.removeEventListener('mousemove', this.onDragMouseMoveBind);
      document.removeEventListener('touchmove', this.onDragMouseMoveBind);
      document.removeEventListener('mouseup', this.onDragMouseUpBind);
      document.removeEventListener('touchend', this.onDragMouseUpBind);
    }

    render() {
      return /*#__PURE__*/React.createElement(WrappedComponent, Object.assign({
        onDrag: this.handleDrag,
        ref: this.setRef
      }, this.props));
    }

  }

  dragDecorator.displayName = dragName(WrappedComponent);
  return hoistStatics(dragDecorator, WrappedComponent);
};

export default drag;