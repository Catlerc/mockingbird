import _extends from "@babel/runtime/helpers/extends";
import React, { PureComponent, createRef, Fragment } from 'react';
import cn from 'classnames';
import findIndex from '@tinkoff/utils/array/findIndex';
import { isTouchDevice } from '@platform-ui/device-info';
import generateId from '@platform-ui/generateId';
import Loader from '@platform-ui/loader';
import Clickable from '@platform-ui/clickable';
import IconClose from '@platform-ui/iconsPack/interface/24/Close';
import IconTrash from '@platform-ui/iconsPack/interface/24/TrashFilled';
import IconSuccess from '@platform-ui/iconsPack/interface/24/SuccessFilled';
import IconAttention from '@platform-ui/iconsPack/interface/24/AttentionFilled';
import IconDocument from '@platform-ui/iconsPack/interface/24/Document';
import styles from './AttachFile.module.css';

const noop = () => {};

const splitFilename = filename => filename.split(/(?=.+)\.(?=[^.]*$)/);

export const FILE_STATUS = {
  LOADING: 'loading',
  SUCCESS: 'success',
  ERROR: 'error',
  REMOVED: 'removed'
};

const formatFileSize = (size, units) => {
  let i;
  let result = size;

  for (i = 0; i < units.length - 1 && result >= 1024; i++) {
    result /= 1024;
  }

  return `${+result.toFixed(2)} ${units[i]}`;
};

const DEFAULT_LABELS = {
  single: {
    common: 'Выберите файл',
    desktop: ' или перетяните его сюда',
    dragging: 'Поместите файл сюда'
  },
  multiple: {
    common: 'Выберите файлы',
    desktop: ' или перетяните их сюда',
    dragging: 'Поместите файлы сюда'
  }
};

const callIfFn = (val, param) => typeof val === 'function' ? val(param) : val;

class AttachFile extends PureComponent {
  constructor(props) {
    super(props);
    this.refInput = /*#__PURE__*/createRef();
    this.labelId = generateId(this);
    this.errorId = generateId(this);

    this.handleDocumentDragEnter = event => {
      if (event.dataTransfer && event.dataTransfer.files) {
        this.setState({
          drag: true
        });
      }
    };

    this.handleDocumentDrop = () => {
      this.setState({
        drag: false
      });
    };

    this.handleDocumentDragLeave = event => {
      // @ts-ignore
      if (!event.fromElement) {
        this.setState({
          drag: false
        });
      }
    };

    this.handleInputFocus = event => {
      this.setState({
        focused: true
      });
      this.props.onFocus(event);
    };

    this.handleInputBlur = event => {
      this.setState({
        focused: false
      });
      this.props.onBlur(event);
    };

    this.handleInputChange = event => {
      const files = [];

      if (event.target.files) {
        for (let i = 0, len = event.target.files.length; i < len; i++) {
          files.push({
            file: event.target.files[i],
            status: FILE_STATUS.LOADING
          });
        }
      }

      this.setState({
        dragHover: false
      }); // @ts-ignore
      // eslint-disable-next-line no-param-reassign

      event.target.value = null;

      if (files.length === 0) {
        return;
      }

      this.props.onAdd(event, {
        files
      });
    };

    this.handleRemoveButtonClick = event => {
      event.preventDefault();
      event.stopPropagation();
      const {
        index
      } = event.currentTarget.dataset;
      this.props.onRemove(event, {
        // @ts-ignore
        file: this.props.files[index]
      });
    };

    this.handleRestoreButtonClick = event => {
      event.preventDefault();
      const {
        index
      } = event.currentTarget.dataset;
      this.props.onRestore(event, {
        // @ts-ignore
        file: this.props.files[index]
      });
    };

    this.handleInputDragOver = () => {
      this.setState({
        dragHover: true
      });
    };

    this.handleInputDragLeave = () => {
      this.setState({
        dragHover: false
      });
    };

    this.handleCollapseButtonClick = event => {
      event.preventDefault();
      const {
        collapsed
      } = this.state;
      this.setState({
        collapsed: !collapsed
      });
    };

    this.state = {
      focused: props.focused,
      isTouch: false,
      collapsed: true
    };
  }

  componentDidMount() {
    const {
      focused
    } = this.state;
    focused ? this.focus() : this.blur();
    document.addEventListener('dragenter', this.handleDocumentDragEnter);
    document.addEventListener('dragleave', this.handleDocumentDragLeave);
    document.addEventListener('drop', this.handleDocumentDrop);
    this.setState({
      isTouch: isTouchDevice()
    });
  }

  componentDidUpdate(prevProps) {
    const {
      focused
    } = this.props;

    if (!prevProps.focused && focused) {
      this.focus();
    }

    if (prevProps.focused && !focused) {
      this.blur();
    }
  }

  componentWillUnmount() {
    document.removeEventListener('dragenter', this.handleDocumentDragEnter);
    document.removeEventListener('dragleave', this.handleDocumentDragLeave);
    document.removeEventListener('drop', this.handleDocumentDrop);
  }

  getLabels() {
    const {
      labels,
      single
    } = this.props;

    const mergedLabels = _extends({}, DEFAULT_LABELS[single ? 'single' : 'multiple']);

    Object.keys(labels).forEach(key => {
      if (labels[key]) {
        mergedLabels[key] = labels[key];
      }
    });
    return mergedLabels;
  }

  focus() {
    this.refInput && this.refInput.current && this.refInput.current.focus && this.refInput.current.focus();
  }

  blur() {
    this.refInput && this.refInput.current && this.refInput.current.blur && this.refInput.current.blur();
  }

  renderLabel() {
    const {
      files,
      single,
      accept,
      tabIndex,
      dataQaType
    } = this.props;
    const {
      drag
    } = this.state;
    const labels = this.getLabels();
    const hasError = Boolean(files.find(x => x.status === FILE_STATUS.ERROR));
    return /*#__PURE__*/React.createElement("div", {
      className: styles.labelContainer
    }, /*#__PURE__*/React.createElement("input", {
      className: styles.input,
      ref: this.refInput,
      tabIndex: tabIndex,
      type: "file",
      accept: accept,
      multiple: !single,
      "aria-labelledby": this.labelId,
      "aria-errormessage": hasError ? this.errorId : undefined,
      "aria-invalid": hasError || undefined,
      onMouseDown: event => event.preventDefault(),
      onDragLeave: this.handleInputDragLeave,
      onDragOver: this.handleInputDragOver,
      onChange: this.handleInputChange,
      onFocus: this.handleInputFocus,
      onBlur: this.handleInputBlur,
      "data-qa-type": `${dataQaType}.input`
    }), /*#__PURE__*/React.createElement("div", {
      className: styles.label,
      id: this.labelId,
      "data-qa-type": `${dataQaType}.label`
    }, drag ? /*#__PURE__*/React.createElement("span", {
      className: styles.dragLabel,
      "data-qa-type": `${dataQaType}.labelText ${dataQaType}.labelText_dragging`
    }, labels.dragging) : /*#__PURE__*/React.createElement(Fragment, null, labels.common, /*#__PURE__*/React.createElement("span", {
      className: styles.dragLabel,
      "data-qa-type": `${dataQaType}.labelText`
    }, labels.desktop))));
  }

  renderFile(fileItem, index) {
    const {
      file,
      status,
      message,
      url,
      previewUrl,
      removable = true,
      restorable = true,
      onClick
    } = fileItem;
    const {
      files,
      tabIndex,
      readOnly,
      preview,
      dataQaType,
      sizeUnits,
      formatFileSize,
      restoreButtonLabel,
      removeButtonAriaLabel,
      restoreButtonAriaLabel
    } = this.props;
    const errorIndex = findIndex(x => x.status === FILE_STATUS.ERROR)(files);
    const [name, extension] = splitFilename(file.name);
    return /*#__PURE__*/React.createElement("li", {
      key: `${file.name}-${status}-${url}`,
      className: styles.item,
      "data-qa-type": `${dataQaType}.item`
    }, /*#__PURE__*/React.createElement(Clickable, {
      className: cn({
        [styles.file]: true,
        [styles[`file_status-${status}`]]: true,
        [styles.file_link]: url || onClick
      }),
      innerClassName: styles.fileInner,
      href: url,
      tagName: !url ? 'div' : undefined,
      target: url ? '_blank' : undefined,
      dataQaType: `${dataQaType}.file_status-${status}`,
      innerDataQaType: `${dataQaType}.fileInner`,
      onClick: e => onClick && onClick(e, fileItem)
    }, preview ? /*#__PURE__*/React.createElement("div", {
      className: styles.preview,
      style: previewUrl ? {
        backgroundImage: `url(${previewUrl})`
      } : undefined
    }, /*#__PURE__*/React.createElement("div", {
      className: styles.previewOverlay
    }), /*#__PURE__*/React.createElement("div", {
      "data-qa-type": `${dataQaType}.statusIcon`,
      className: styles.icon
    }, {
      [FILE_STATUS.LOADING]: /*#__PURE__*/React.createElement(Loader, {
        size: "m",
        color: "rgba(0, 0, 0, .24)"
      }),
      [FILE_STATUS.SUCCESS]: previewUrl ? null : /*#__PURE__*/React.createElement(IconDocument, null),
      [FILE_STATUS.REMOVED]: /*#__PURE__*/React.createElement(IconTrash, null),
      [FILE_STATUS.ERROR]: /*#__PURE__*/React.createElement(IconAttention, null)
    }[status])) : /*#__PURE__*/React.createElement("div", {
      "data-qa-type": `${dataQaType}.statusIcon`,
      className: styles.icon
    }, {
      [FILE_STATUS.LOADING]: /*#__PURE__*/React.createElement(Loader, {
        size: "m"
      }),
      [FILE_STATUS.SUCCESS]: /*#__PURE__*/React.createElement(IconSuccess, null),
      [FILE_STATUS.REMOVED]: /*#__PURE__*/React.createElement(IconTrash, null),
      [FILE_STATUS.ERROR]: /*#__PURE__*/React.createElement(IconAttention, null)
    }[status]), /*#__PURE__*/React.createElement("div", {
      className: styles.fileInfo
    }, /*#__PURE__*/React.createElement("div", {
      className: styles.fileTitle
    }, /*#__PURE__*/React.createElement("span", {
      "data-qa-type": `${dataQaType}.fileName`,
      className: styles.fileName
    }, name), extension && /*#__PURE__*/React.createElement("span", {
      "data-qa-type": `${dataQaType}.fileExtension`
    }, ".", extension), typeof file.size === 'number' && /*#__PURE__*/React.createElement("span", {
      "data-qa-type": `${dataQaType}.fileSize`,
      className: styles.fileSize
    }, formatFileSize(file.size, sizeUnits))), message && /*#__PURE__*/React.createElement("div", {
      id: index === errorIndex ? this.errorId : undefined,
      className: styles.message
    }, message), status === 'removed' && restorable && /*#__PURE__*/React.createElement(Clickable, {
      "data-index": index,
      className: styles.restoreButton,
      onClick: this.handleRestoreButtonClick,
      "aria-label": callIfFn(restoreButtonAriaLabel, {
        file
      })
    }, restoreButtonLabel)), !readOnly && status !== 'removed' && removable && /*#__PURE__*/React.createElement(Clickable, {
      "data-index": index,
      tabIndex: tabIndex,
      onClick: this.handleRemoveButtonClick,
      className: styles.removeButton,
      "aria-label": callIfFn(removeButtonAriaLabel, {
        file
      }),
      dataQaType: `${dataQaType}.removeButton`
    }, /*#__PURE__*/React.createElement(IconClose, null))));
  }

  render() {
    const {
      files,
      error,
      single,
      readOnly,
      dataQaType,
      preview,
      expandButtonLabel,
      collapseButtonLabel
    } = this.props;
    const {
      drag,
      dragHover,
      focused,
      isTouch,
      collapsed
    } = this.state;
    const hasError = Boolean(files.find(x => x.status === FILE_STATUS.ERROR));
    const showInput = !(single && files.length > 0) && !readOnly;
    const collapsible = this.props.collapsible && files.length > 3 && !hasError;
    const viewFiles = collapsible && collapsed ? files.slice(0, 3) : files;
    return /*#__PURE__*/React.createElement("div", {
      "data-qa-type": dataQaType,
      className: cn(styles.root, {
        [styles.root_focused]: focused,
        [styles.root_filled]: !showInput,
        [styles.root_isTouch]: isTouch,
        [styles.root_error]: error,
        [styles.root_dragHover]: dragHover,
        [styles.root_drag]: drag,
        [styles.root_readOnly]: readOnly,
        [styles.root_preview]: preview,
        [styles.root_collapsible]: collapsible,
        [styles.root_collapsed]: collapsible && collapsed
      })
    }, showInput && this.renderLabel(), files.length > 0 && /*#__PURE__*/React.createElement("div", {
      className: styles.listContainer
    }, /*#__PURE__*/React.createElement("ul", {
      className: styles.list
    }, viewFiles.map(this.renderFile.bind(this))), collapsible && /*#__PURE__*/React.createElement(Clickable, {
      tagName: "div",
      onClick: this.handleCollapseButtonClick,
      className: styles.collapseButton
    }, collapsed ? expandButtonLabel : collapseButtonLabel)));
  }

}

AttachFile.defaultProps = {
  dataQaType: 'uikit/attachFile',
  files: [],
  single: false,
  focused: false,
  readOnly: false,
  preview: false,
  collapsible: false,
  labels: {},
  onBlur: noop,
  onFocus: noop,
  onAdd: noop,
  onRemove: noop,
  onRestore: noop,
  sizeUnits: ['Б', 'КБ', 'МБ', 'ГБ'],
  formatFileSize,
  expandButtonLabel: 'Показать все',
  collapseButtonLabel: 'Скрыть',
  restoreButtonLabel: 'Восстановить',
  removeButtonAriaLabel: ({
    file
  }) => `Удалить файл ${file.name}`,
  restoreButtonAriaLabel: ({
    file
  }) => `Восстановить файл ${file.name}`
};
export default AttachFile;