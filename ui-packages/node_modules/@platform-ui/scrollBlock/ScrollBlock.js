"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

exports.__esModule = true;
exports.default = void 0;

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _dataQa = _interopRequireDefault(require("@platform-ui/dataQa"));

var _animation = _interopRequireWildcard(require("@platform-ui/utils/animation"));

var _getScrollBarWidth = _interopRequireDefault(require("@platform-ui/utils/getScrollBarWidth"));

var _draggable = _interopRequireDefault(require("@platform-ui/draggable"));

var _color = require("@platform-ui/utils/color");

var _ScrollBlockModule = _interopRequireDefault(require("./ScrollBlock.module.css"));

// @ts-ignore
// @ts-ignore
// @ts-ignore
var SCROLL_HIDE_PADDING = 30;

var noop = function noop() {};

var ScrollBlock = /*#__PURE__*/function (_PureComponent) {
  (0, _inheritsLoose2.default)(ScrollBlock, _PureComponent);

  function ScrollBlock(props) {
    var _this;

    _this = _PureComponent.call(this, props) || this;
    _this.container = void 0;
    _this.animation = void 0;
    _this.scrollStartPosition = void 0;
    _this.scrollTimerId = void 0;
    _this.mounted = false;

    _this.checkFade = function () {
      requestAnimationFrame(function () {
        // Компонент может быть размонтирован на момент рендера следующего фрейма
        if (!_this.mounted || !_this.container) {
          return;
        }

        var withFade = _this.props.withFade;
        var _this$container = _this.container,
            scrollLeft = _this$container.scrollLeft,
            scrollWidth = _this$container.scrollWidth,
            clientWidth = _this$container.clientWidth;
        var isOverflow = scrollWidth > clientWidth;

        _this.setStateSafe({
          isOverflow: isOverflow,
          leftFade: withFade && isOverflow && !!scrollLeft,
          rightFade: withFade && isOverflow && scrollLeft + clientWidth !== scrollWidth
        });
      });
    };

    _this.setScrollPosition = function (animationValue, animated) {
      if (animated === void 0) {
        animated = true;
      }

      var _this$props = _this.props,
          animationDuration = _this$props.animationDuration,
          animationFunction = _this$props.animationFunction;

      if (!_this.container) {
        return;
      }

      var endValue = animationValue;

      if (animationValue === 'left') {
        endValue = 0;
      }

      if (animationValue === 'right') {
        endValue = _this.container.scrollWidth;
      }

      if (!animated) {
        _this.container.scrollLeft = endValue;
      } else {
        var start = _this.container.scrollLeft;

        if (endValue !== start) {
          _this.animation.stop(); // останавливаем предыдущую анимацию, если она запущена


          _this.animation.play({
            duration: animationDuration,
            timing: animationFunction,
            draw: function draw(progress) {
              if (_this.container) {
                _this.container.scrollLeft = Math.ceil(start + (endValue - start) * progress);
              }
            }
          });
        }
      }
    };

    _this.setRef = function (elem) {
      _this.container = elem;
    };

    _this.setStateSafe = function () {
      if (_this.mounted) {
        var _this2;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        (_this2 = _this).setState.apply(_this2, args);
      }
    };

    _this.handleScroll = function (event) {
      var _this$props2 = _this.props,
          onScroll = _this$props2.onScroll,
          onScrollStop = _this$props2.onScrollStop,
          scrollStopDelay = _this$props2.scrollStopDelay;

      _this.checkFade();

      if (onScrollStop) {
        if (_this.scrollTimerId) {
          window.clearTimeout(_this.scrollTimerId);
        }

        _this.scrollTimerId = window.setTimeout(function () {
          onScrollStop(event);
        }, scrollStopDelay);
      }

      onScroll(event);
    };

    _this.handleDragStart = function () {
      _this.scrollStartPosition = _this.container.scrollLeft;
    };

    _this.handleDrag = function (event) {
      _this.container.scrollLeft = _this.scrollStartPosition - event.delta.offset.x;
    };

    _this.animation = new _animation.default();
    _this.state = {
      isOverflow: true,
      scrollBarWidth: 0,
      overflowX: props.height ? 'scroll' : 'hidden'
    };
    return _this;
  }

  var _proto = ScrollBlock.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this3 = this;

    this.mounted = true; // eslint-disable-next-line promise/catch-or-return

    (0, _getScrollBarWidth.default)().then(function (width) {
      _this3.setStateSafe({
        scrollBarWidth: width,
        overflowX: 'scroll'
      });
    });
    var getControllers = this.props.getControllers;
    getControllers({
      setScrollPosition: this.setScrollPosition,
      getScrollPosition: function getScrollPosition() {
        return _this3.container.scrollLeft;
      }
    });
    this.checkFade();
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    this.checkFade();

    if (prevProps.onScrollStop && !this.props.onScrollStop && this.scrollTimerId) {
      window.clearTimeout(this.scrollTimerId);
      this.scrollTimerId = undefined;
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var getControllers = this.props.getControllers;
    this.mounted = false;
    getControllers({
      setScrollPosition: undefined,
      getScrollPosition: undefined
    });

    if (this.scrollTimerId) {
      window.clearTimeout(this.scrollTimerId);
    }
  };

  _proto.renderFade = function renderFade() {
    var _cn, _cn2;

    var fadeColor = this.props.fadeColor;
    var _this$state = this.state,
        leftFade = _this$state.leftFade,
        rightFade = _this$state.rightFade;
    var transparentFadeColor = (0, _color.hex2rgba)((0, _color.restoreCssHexColor)(fadeColor), 0);
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement("div", {
      className: (0, _classnames.default)((_cn = {}, _cn[_ScrollBlockModule.default.fade_left] = true, _cn[_ScrollBlockModule.default.fade_show] = leftFade, _cn)),
      style: {
        backgroundImage: "linear-gradient(90deg, " + fadeColor + ", " + transparentFadeColor + ")"
      }
    }), /*#__PURE__*/_react.default.createElement("div", {
      className: (0, _classnames.default)((_cn2 = {}, _cn2[_ScrollBlockModule.default.fade_right] = true, _cn2[_ScrollBlockModule.default.fade_show] = rightFade, _cn2)),
      style: {
        background: "linear-gradient(-90deg, " + fadeColor + ", " + transparentFadeColor + ")"
      }
    }));
  };

  _proto.render = function render() {
    var _cn3;

    var _this$props3 = this.props,
        dataQaType = _this$props3.dataQaType,
        children = _this$props3.children,
        draggable = _this$props3.draggable,
        innerPadding = _this$props3.innerPadding,
        withFade = _this$props3.withFade,
        scrollId = _this$props3.scrollId,
        height = _this$props3.height,
        noScroll = _this$props3.noScroll;
    var _this$state2 = this.state,
        scrollBarWidth = _this$state2.scrollBarWidth,
        overflowX = _this$state2.overflowX,
        isOverflow = _this$state2.isOverflow;
    return /*#__PURE__*/_react.default.createElement("div", Object.assign({
      className: _ScrollBlockModule.default.wrapper,
      style: {
        height: height
      }
    }, (0, _dataQa.default)(this.props)), withFade && this.renderFade(), /*#__PURE__*/_react.default.createElement(_draggable.default, {
      onDragStart: draggable ? this.handleDragStart : undefined,
      onDrag: draggable ? this.handleDrag : undefined,
      allowDefaultAction: true
    }, /*#__PURE__*/_react.default.createElement("div", Object.assign({
      className: _ScrollBlockModule.default.scroll,
      style: !isOverflow ? undefined : {
        paddingBottom: SCROLL_HIDE_PADDING,
        marginBottom: -SCROLL_HIDE_PADDING - scrollBarWidth,
        overflowX: overflowX
      },
      ref: this.setRef,
      onScroll: this.handleScroll,
      id: scrollId
    }, (0, _dataQa.default)({
      dataQaType: dataQaType + ".scroll"
    })), /*#__PURE__*/_react.default.createElement("div", {
      className: (0, _classnames.default)((_cn3 = {}, _cn3[_ScrollBlockModule.default.content] = true, _cn3[_ScrollBlockModule.default.content_noscroll] = noScroll, _cn3)),
      style: {
        paddingLeft: innerPadding,
        paddingRight: innerPadding
      }
    }, children))));
  };

  return ScrollBlock;
}(_react.PureComponent);

ScrollBlock.defaultProps = {
  dataQaType: 'uikit/scrollBlock',
  draggable: true,
  innerPadding: null,
  getControllers: noop,
  onScroll: noop,
  scrollStopDelay: 150,
  withFade: false,
  fadeColor: '#fff',
  animationDuration: 200,
  animationFunction: _animation.TIMING_FUNCS.EASE_IN,
  height: null,
  noScroll: false,
  children: null,
  scrollId: null
};
var _default = ScrollBlock;
exports.default = _default;