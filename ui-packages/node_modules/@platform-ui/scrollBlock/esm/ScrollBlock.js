import React, { PureComponent } from 'react';
import cn from 'classnames';
import dataQa from '@platform-ui/dataQa'; // @ts-ignore

import Animation, { TIMING_FUNCS } from '@platform-ui/utils/animation'; // @ts-ignore

import getScrollBarWidth from '@platform-ui/utils/getScrollBarWidth';
import Draggable from '@platform-ui/draggable'; // @ts-ignore

import { hex2rgba, restoreCssHexColor } from '@platform-ui/utils/color';
import styles from './ScrollBlock.module.css';
const SCROLL_HIDE_PADDING = 30;

const noop = () => {};

class ScrollBlock extends PureComponent {
  constructor(props) {
    super(props);
    this.container = void 0;
    this.animation = void 0;
    this.scrollStartPosition = void 0;
    this.scrollTimerId = void 0;
    this.mounted = false;

    this.checkFade = () => {
      requestAnimationFrame(() => {
        // Компонент может быть размонтирован на момент рендера следующего фрейма
        if (!this.mounted || !this.container) {
          return;
        }

        const {
          withFade
        } = this.props;
        const {
          scrollLeft,
          scrollWidth,
          clientWidth
        } = this.container;
        const isOverflow = scrollWidth > clientWidth;
        this.setStateSafe({
          isOverflow,
          leftFade: withFade && isOverflow && !!scrollLeft,
          rightFade: withFade && isOverflow && scrollLeft + clientWidth !== scrollWidth
        });
      });
    };

    this.setScrollPosition = (animationValue, animated = true) => {
      const {
        animationDuration,
        animationFunction
      } = this.props;

      if (!this.container) {
        return;
      }

      let endValue = animationValue;

      if (animationValue === 'left') {
        endValue = 0;
      }

      if (animationValue === 'right') {
        endValue = this.container.scrollWidth;
      }

      if (!animated) {
        this.container.scrollLeft = endValue;
      } else {
        const start = this.container.scrollLeft;

        if (endValue !== start) {
          this.animation.stop(); // останавливаем предыдущую анимацию, если она запущена

          this.animation.play({
            duration: animationDuration,
            timing: animationFunction,
            draw: progress => {
              if (this.container) {
                this.container.scrollLeft = Math.ceil(start + (endValue - start) * progress);
              }
            }
          });
        }
      }
    };

    this.setRef = elem => {
      this.container = elem;
    };

    this.setStateSafe = (...args) => {
      if (this.mounted) {
        this.setState(...args);
      }
    };

    this.handleScroll = event => {
      const {
        onScroll,
        onScrollStop,
        scrollStopDelay
      } = this.props;
      this.checkFade();

      if (onScrollStop) {
        if (this.scrollTimerId) {
          window.clearTimeout(this.scrollTimerId);
        }

        this.scrollTimerId = window.setTimeout(() => {
          onScrollStop(event);
        }, scrollStopDelay);
      }

      onScroll(event);
    };

    this.handleDragStart = () => {
      this.scrollStartPosition = this.container.scrollLeft;
    };

    this.handleDrag = event => {
      this.container.scrollLeft = this.scrollStartPosition - event.delta.offset.x;
    };

    this.animation = new Animation();
    this.state = {
      isOverflow: true,
      scrollBarWidth: 0,
      overflowX: props.height ? 'scroll' : 'hidden'
    };
  }

  componentDidMount() {
    this.mounted = true; // eslint-disable-next-line promise/catch-or-return

    getScrollBarWidth().then(width => {
      this.setStateSafe({
        scrollBarWidth: width,
        overflowX: 'scroll'
      });
    });
    const {
      getControllers
    } = this.props;
    getControllers({
      setScrollPosition: this.setScrollPosition,
      getScrollPosition: () => this.container.scrollLeft
    });
    this.checkFade();
  }

  componentDidUpdate(prevProps) {
    this.checkFade();

    if (prevProps.onScrollStop && !this.props.onScrollStop && this.scrollTimerId) {
      window.clearTimeout(this.scrollTimerId);
      this.scrollTimerId = undefined;
    }
  }

  componentWillUnmount() {
    const {
      getControllers
    } = this.props;
    this.mounted = false;
    getControllers({
      setScrollPosition: undefined,
      getScrollPosition: undefined
    });

    if (this.scrollTimerId) {
      window.clearTimeout(this.scrollTimerId);
    }
  }

  renderFade() {
    const {
      fadeColor
    } = this.props;
    const {
      leftFade,
      rightFade
    } = this.state;
    const transparentFadeColor = hex2rgba(restoreCssHexColor(fadeColor), 0);
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
      className: cn({
        [styles.fade_left]: true,
        [styles.fade_show]: leftFade
      }),
      style: {
        backgroundImage: `linear-gradient(90deg, ${fadeColor}, ${transparentFadeColor})`
      }
    }), /*#__PURE__*/React.createElement("div", {
      className: cn({
        [styles.fade_right]: true,
        [styles.fade_show]: rightFade
      }),
      style: {
        background: `linear-gradient(-90deg, ${fadeColor}, ${transparentFadeColor})`
      }
    }));
  }

  render() {
    const {
      dataQaType,
      children,
      draggable,
      innerPadding,
      withFade,
      scrollId,
      height,
      noScroll
    } = this.props;
    const {
      scrollBarWidth,
      overflowX,
      isOverflow
    } = this.state;
    return /*#__PURE__*/React.createElement("div", Object.assign({
      className: styles.wrapper,
      style: {
        height
      }
    }, dataQa(this.props)), withFade && this.renderFade(), /*#__PURE__*/React.createElement(Draggable, {
      onDragStart: draggable ? this.handleDragStart : undefined,
      onDrag: draggable ? this.handleDrag : undefined,
      allowDefaultAction: true
    }, /*#__PURE__*/React.createElement("div", Object.assign({
      className: styles.scroll,
      style: !isOverflow ? undefined : {
        paddingBottom: SCROLL_HIDE_PADDING,
        marginBottom: -SCROLL_HIDE_PADDING - scrollBarWidth,
        overflowX
      },
      ref: this.setRef,
      onScroll: this.handleScroll,
      id: scrollId
    }, dataQa({
      dataQaType: `${dataQaType}.scroll`
    })), /*#__PURE__*/React.createElement("div", {
      className: cn({
        [styles.content]: true,
        [styles.content_noscroll]: noScroll
      }),
      style: {
        paddingLeft: innerPadding,
        paddingRight: innerPadding
      }
    }, children))));
  }

}

ScrollBlock.defaultProps = {
  dataQaType: 'uikit/scrollBlock',
  draggable: true,
  innerPadding: null,
  getControllers: noop,
  onScroll: noop,
  scrollStopDelay: 150,
  withFade: false,
  fadeColor: '#fff',
  animationDuration: 200,
  animationFunction: TIMING_FUNCS.EASE_IN,
  height: null,
  noScroll: false,
  children: null,
  scrollId: null
};
export default ScrollBlock;