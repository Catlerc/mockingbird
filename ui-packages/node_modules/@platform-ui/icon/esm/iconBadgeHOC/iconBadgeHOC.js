import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
const _excluded = ["topBadge", "bottomBadge", "withNotification", "iconSize", "verticalAlign", "badgeBorderColor", "badgeBackgroundColor", "topBadgeBorderColor", "topBadgeBackgroundColor", "bottomBadgeBackgroundColor", "bottomBadgeBorderColor", "animateNotification", "animateNotificationFirstRender", "notificationType"];
import React, { PureComponent } from 'react';
import cn from 'classnames';
import hoistStatics from 'hoist-non-react-statics';
import CSSTransitionGroup from '../utils/CSSTransitionGroup';
import { roundSize, ICON_SIZES } from '../Icon';
import styles from './iconBadgeHOC.module.css';
const MOUNT_RENDER_DELAY = 400;
const SIZES_MAP = {
  128: 'xxl',
  96: 'xl',
  64: 'l',
  48: 'm',
  32: 's',
  24: 'xs'
};
const BORDER_WIDTH = {
  xxxl: '3',
  xxl: '3',
  xl: '3',
  l: '2',
  m: '2',
  s: '2',
  xs: '2'
};
export const NOTIFICATION_TYPES = {
  ALERT: 'alert',
  WARNING: 'warning',
  SUCCESS: 'success'
};

const iconBadgeHOC = WrappedComponent => {
  class BadgeWrapper extends PureComponent {
    constructor(props) {
      super(props);
      this.timeoutId = void 0;
      this.state = {
        mounted: false
      };
    }

    componentDidMount() {
      // добавляем небольшую задержку, чтобы контент успел прогрузиться
      this.timeoutId = window.setTimeout(() => {
        this.setState({
          mounted: true
        });
      }, MOUNT_RENDER_DELAY);
    }

    componentWillUnmount() {
      window.clearTimeout(this.timeoutId);
    }

    renderNotification(size) {
      const {
        square,
        badgeBorderColor,
        badgeBackgroundColor,
        topBadgeBorderColor,
        topBadgeBackgroundColor,
        withNotification,
        animateNotification,
        animateNotificationFirstRender,
        notificationType
      } = this.props;
      let content;

      if (!this.state.mounted && animateNotificationFirstRender) {
        return;
      }

      if (!withNotification) {
        content = null;
      } else if (typeof withNotification === 'boolean') {
        content = /*#__PURE__*/React.createElement("span", {
          className: cn({
            [styles.notification]: true,
            [styles.notification_square]: square,
            [styles[`notification_type_${notificationType}`]]: notificationType
          }),
          style: {
            boxShadow: `0 0 0 ${BORDER_WIDTH[size]}px ${topBadgeBorderColor || badgeBorderColor}`,
            backgroundColor: topBadgeBackgroundColor || badgeBackgroundColor
          }
        });
      } else {
        content = this.renderBadge(withNotification > 99 ? '99+' : withNotification, 'top', size);
      }

      return animateNotification ? /*#__PURE__*/React.createElement(CSSTransitionGroup, {
        animateFirstRender: animateNotificationFirstRender,
        transitionName: {
          show: styles.transition_show,
          hide: styles.transition_hide,
          enter: styles.transition_enter,
          leave: styles.transition_leave
        }
      }, content) : content;
    }

    renderBadge(badge, position, size) {
      if (!badge) {
        return null;
      }

      const {
        badgeBorderColor,
        badgeBackgroundColor,
        topBadgeBorderColor,
        topBadgeBackgroundColor,
        bottomBadgeBackgroundColor,
        bottomBadgeBorderColor,
        square
      } = this.props;
      let isText;
      let badgeContent;
      let isLongText;

      switch (typeof badge) {
        case 'string':
        case 'number':
          isText = true;
          isLongText = badge.toString().length > 1;
          badgeContent = badge;
          break;

        case 'function':
          {
            badgeContent = badge({
              size
            });
            break;
          }
      }

      return /*#__PURE__*/React.createElement("span", {
        className: cn({
          [styles.badgeWrapper]: true,
          [styles[`badgeWrapper_position_${position}`]]: true,
          [styles.badgeWrapper_text]: isText,
          [styles.badgeWrapper_longText]: isLongText,
          [styles.badgeWrapper_square]: square
        }),
        style: {
          boxShadow: position === 'top' ? `0 0 0 ${BORDER_WIDTH[size]}px ${topBadgeBorderColor || badgeBorderColor}` : `0 0 0 ${BORDER_WIDTH[size]}px ${bottomBadgeBorderColor || badgeBorderColor}`,
          backgroundColor: position === 'top' ? topBadgeBackgroundColor || badgeBackgroundColor : bottomBadgeBackgroundColor || badgeBackgroundColor
        }
      }, badgeContent);
    }

    render() {
      const _this$props = this.props,
            {
        topBadge,
        bottomBadge,
        withNotification,
        iconSize,
        verticalAlign
      } = _this$props,
            otherProps = _objectWithoutPropertiesLoose(_this$props, _excluded); // @ts-ignore


      const size = SIZES_MAP[roundSize(iconSize, ICON_SIZES)] || iconSize || 'l';
      return /*#__PURE__*/React.createElement("span", {
        className: cn({
          [styles.root]: true,
          [styles[`root_size_${size}`]]: true
        }),
        style: {
          verticalAlign
        }
      }, /*#__PURE__*/React.createElement(WrappedComponent, Object.assign({}, otherProps, {
        iconSize: iconSize
      })), this.renderNotification(size), !withNotification ? this.renderBadge(topBadge, 'top', size) : undefined, this.renderBadge(bottomBadge, 'bottom', size));
    }

  }

  BadgeWrapper.defaultProps = _extends({}, WrappedComponent.defaultProps, {
    badgeBorderColor: '#FFFFFF',
    topBadgeBorderColor: null,
    topBadgeBackgroundColor: null,
    bottomBadgeBackgroundColor: null,
    bottomBadgeBorderColor: null,
    bottomBadge: null,
    topBadge: null,
    withNotification: false,
    animateNotification: true,
    animateNotificationFirstRender: false,
    square: false,
    verticalAlign: 'top',
    notificationType: NOTIFICATION_TYPES.WARNING
  });
  hoistStatics(BadgeWrapper, WrappedComponent);
  return BadgeWrapper;
};

export default iconBadgeHOC;