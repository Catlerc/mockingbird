"use strict";

exports.__esModule = true;
exports.calcFontColor = calcFontColor;
exports.checkHash = checkHash;
exports.colorType = colorType;
exports.colorsDiff = colorsDiff;
exports.dec2hex = dec2hex;
exports.getColor = getColor;
exports.getShiftColor = getShiftColor;
exports.hex2hsv = hex2hsv;
exports.hex2rgb = hex2rgb;
exports.hex2rgba = hex2rgba;
exports.hexa2hex = hexa2hex;
exports.hsl2rgb = hsl2rgb;
exports.hsv2hex = hsv2hex;
exports.hsv2rgb = hsv2rgb;
exports.isGrayShade = isGrayShade;
exports.isHSVColor = isHSVColor;
exports.isHexAColor = isHexAColor;
exports.isHexColor = isHexColor;
exports.isRGBColor = isRGBColor;
exports.isWhite = isWhite;
exports.list = void 0;
exports.luminance = luminance;
exports.productGradientColor = productGradientColor;
exports.restoreCssHexColor = restoreCssHexColor;
exports.rgb2hex = rgb2hex;
exports.rgb2hsl = rgb2hsl;
exports.rgb2hsv = rgb2hsv;
exports.rgba2hex = rgba2hex;
var DEFAULT_STRING = '';
var DEFAULT_RGB = {
  r: 255,
  g: 255,
  b: 255
};
var DEFAULT_HSV = {
  h: 0,
  s: 0,
  v: 1
};
var list = ['#00bee0', '#ffdd2d', '#5695c4', '#b39fda', '#ff9797', '#37a89d', '#6bd2ec', '#ffad5c', '#b3baec', '#ffb4b4', '#68c24d', '#80abcc', '#ffba00', '#b186c4', '#f97f7c', '#17d15f', '#589db6', '#ff9138', '#d4a0f3', '#d97789', '#50a06f', '#00c6d3', '#ff7047', '#db8cec', '#dd567a', '#4dbf81', '#66b1ad', '#f2bc85', '#f3a3ff', '#ff85b4', '#bfd386'];
exports.list = list;

function isDefinedByType(value, type) {
  return value !== '' && value !== undefined && typeof value === type; // eslint-disable-line valid-typeof
}

function isRGBColor(color) {
  return isDefinedByType(color, 'object') && isDefinedByType(color.r, 'number') && isDefinedByType(color.g, 'number') && isDefinedByType(color.b, 'number');
}

function isHSVColor(color) {
  return isDefinedByType(color, 'object') && isDefinedByType(color.h, 'number') && isDefinedByType(color.s, 'number') && isDefinedByType(color.v, 'number');
}

function isHexColor(color) {
  return isDefinedByType(color, 'string') && (color.length === 7 || color.length === 4) && /^#/.test(color);
}

function isHexAColor(color) {
  return isDefinedByType(color, 'string') && /^#[0-9a-fA-F]{8}$/.test(color);
}

function restoreCssHexColor(hexValue) {
  if (hexValue === void 0) {
    hexValue = '';
  }

  var hex = hexValue.toLowerCase().replace(/[^\da-f]/g, '');

  if (!isDefinedByType(hex, 'string') || hex.length !== 3 && hex.length !== 6) {
    return DEFAULT_STRING;
  }

  if (hex.length === 3) {
    hex = hex.replace(/(.)/g, '$1$1');
  }

  return "#" + hex;
}

function isGrayShade(hex) {
  var color = restoreCssHexColor(hex);
  return color.slice(1, 3) === color.slice(3, 5) && color.slice(3, 5) === color.slice(5, 7);
}

function luminance(rgb) {
  // http://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color/3943023#3943023
  if (!isRGBColor(rgb)) {
    return DEFAULT_STRING;
  }

  return rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114;
}

function getColor(n) {
  var i = !isDefinedByType(n, 'number') || n < 0 ? 0 : n;
  return list[i % list.length];
}

function hex2rgb(hex) {
  if (!isHexColor(hex)) {
    return DEFAULT_RGB;
  }

  return {
    r: parseInt(hex.substr(1, 2), 16),
    g: parseInt(hex.substr(3, 2), 16),
    b: parseInt(hex.substr(5, 2), 16)
  };
}
/**
 * see https://www.compuphase.com/cmetric.htm
 * @name colorsPerceiveDiff
 * @description определяет размер визуальной разницы между двумя цветами
 * @param {string} first hex цвет
 * @param {string} second еще hex цвет
 * @return {number} расстояние
 */


function colorsPerceiveDiff(first, second) {
  var firstRGB = hex2rgb(restoreCssHexColor(first));
  var secondRGB = hex2rgb(restoreCssHexColor(second));
  var rMean = (firstRGB.r + secondRGB.r) / 2;
  var rDiff = firstRGB.r - secondRGB.r;
  var gDiff = firstRGB.g - secondRGB.g;
  var bDiff = firstRGB.b - secondRGB.b;
  var rWeight = 2 + rMean / 256;
  var gWeight = 4;
  var bWeight = 2 + (255 - rMean) / 256;
  return Math.sqrt(rWeight * rDiff * rDiff + gWeight * gDiff * gDiff + bWeight * bDiff * bDiff);
}

var maxPerceiveDiff;
/**
 * @name colorsDiff
 * @param {string} first hex цвет
 * @param {string} second еще hex цвет
 * @return {number} нормализованное расстояние в диапазоне [0..100]
 */

function colorsDiff(first, second) {
  if (maxPerceiveDiff === undefined) {
    maxPerceiveDiff = colorsPerceiveDiff('fff', '000');
  }

  return 100 * colorsPerceiveDiff(first, second) / maxPerceiveDiff;
}

function calcFontColor(hex) {
  if (!isHexColor(hex)) {
    return '#333';
  }

  return luminance(hex2rgb(restoreCssHexColor(hex))) > 186 ? '#333' : '#fff';
}

function colorType(hex) {
  if (!isHexColor(hex)) {
    return 'light';
  }

  return luminance(hex2rgb(restoreCssHexColor(hex))) > 186 ? 'light' : 'dark';
}

function hex2rgba(hex, opacity) {
  if (opacity === void 0) {
    opacity = 1;
  }

  if (!isHexColor(hex)) {
    return "rgba(" + DEFAULT_RGB.r + "," + DEFAULT_RGB.g + "," + DEFAULT_RGB.b + ",1)";
  }

  var rgb = hex2rgb(hex);
  return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + opacity + ")";
}

function dec2hex(dec) {
  if (dec > 255 || dec < 0) {
    return 'ff';
  }

  var hex = Math.round(+dec).toString(16);
  return hex.length === 1 ? "0" + hex : hex;
}

function rgb2hex(rgb) {
  if (!isRGBColor(rgb)) {
    return '#ffffff';
  }

  return "#" + dec2hex(rgb.r) + dec2hex(rgb.g) + dec2hex(rgb.b);
}

function rgba2hex(color) {
  var values = color.replace(/rgba?\(/, '').replace(/\)/, '').replace(/[\s+]/g, '').split(',');
  var a = parseFloat(values[3] || 1);
  var r = Math.round(a * parseInt(values[0], 10) + (1 - a) * 255);
  var g = Math.round(a * parseInt(values[1], 10) + (1 - a) * 255);
  var b = Math.round(a * parseInt(values[2], 10) + (1 - a) * 255);
  return "#" + ("0" + r.toString(16)).slice(-2) + ("0" + g.toString(16)).slice(-2) + ("0" + b.toString(16)).slice(-2);
}

function hexa2hex(color) {
  var _color$match$slice$ma = color.match(/^#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})$/).slice(1).map(function (n) {
    return parseInt(n, 16);
  }),
      r = _color$match$slice$ma[0],
      g = _color$match$slice$ma[1],
      b = _color$match$slice$ma[2],
      a = _color$match$slice$ma[3];

  return "#" + [r, g, b].map(function (n) {
    return Math.floor(n * a / 255) + 255 - a;
  }).map(function (n) {
    return ("0" + n.toString(16)).slice(-2);
  }).join('');
} // https://github.com/colorjs/color-space/blob/master/hsl.js


function rgb2hsl(rgb) {
  var r = rgb.r / 255;
  var g = rgb.g / 255;
  var b = rgb.b / 255;
  var h;
  var s;
  var min = Math.min(r, g, b);
  var max = Math.max(r, g, b);
  var delta = max - min;

  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }

  h = Math.min(h * 60, 360);

  if (h < 0) {
    h += 360;
  }

  var l = (min + max) / 2;

  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }

  return {
    h: h / 360,
    s: s,
    l: l
  };
} //  https://github.com/colorjs/color-space/blob/master/hsl.js


function hsl2rgb(hsl) {
  var h = hsl.h,
      s = hsl.s,
      l = hsl.l;
  var t2;
  var t3;
  var val;

  if (s === 0) {
    val = l * 255;
    return {
      r: val,
      g: val,
      b: val
    };
  }

  if (l < 0.5) {
    t2 = l * (1 + s);
  } else {
    t2 = l + s - l * s;
  }

  var t1 = 2 * l - t2;
  var rgb = [0, 0, 0];

  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * -(i - 1);

    if (t3 < 0) {
      t3++;
    } else if (t3 > 1) {
      t3--;
    }

    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }

    rgb[i] = val * 255;
  }

  return {
    r: rgb[0],
    g: rgb[1],
    b: rgb[2]
  };
} // eslint-disable-next-line max-statements


function rgb2hsv(rgb) {
  if (!isRGBColor(rgb)) {
    return DEFAULT_HSV;
  }

  var r = rgb.r / 255;
  var g = rgb.g / 255;
  var b = rgb.b / 255;
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var v = max;
  var d = max - min;
  var s = max === 0 ? 0 : d / max;
  var h = max;

  if (max === min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;

      case g:
        h = (b - r) / d + 2;
        break;

      case b:
        h = (r - g) / d + 4;
        break;
    }

    h /= 6;
  }

  return {
    h: h,
    s: s,
    v: v
  };
}

function hsv2rgb(hsv) {
  var r;
  var g;
  var b;
  var i;
  var f;
  var p;
  var q;
  var t;

  if (!isHSVColor(hsv)) {
    return DEFAULT_RGB;
  }
  /* eslint-disable prefer-const */


  i = Math.floor(hsv.h * 6);
  f = hsv.h * 6 - i;
  p = hsv.v * (1 - hsv.s);
  q = hsv.v * (1 - f * hsv.s);
  t = hsv.v * (1 - (1 - f) * hsv.s);
  /* eslint-enable prefer-const */

  switch (i % 6) {
    case 0:
      r = hsv.v;
      g = t;
      b = p;
      break;

    case 1:
      r = q;
      g = hsv.v;
      b = p;
      break;

    case 2:
      r = p;
      g = hsv.v;
      b = t;
      break;

    case 3:
      r = p;
      g = q;
      b = hsv.v;
      break;

    case 4:
      r = t;
      g = p;
      b = hsv.v;
      break;

    case 5:
      r = hsv.v;
      g = p;
      b = q;
      break;
  }

  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}

function hex2hsv(hex) {
  if (!isHexColor(hex)) {
    return DEFAULT_HSV;
  }

  return rgb2hsv(hex2rgb(hex));
}

function hsv2hex(hsv) {
  if (!isHSVColor(hsv)) {
    return DEFAULT_STRING;
  }

  return rgb2hex(hsv2rgb(hsv));
}

function getShiftColor(color, shiftValue, hsvSchema) {
  if (shiftValue === void 0) {
    shiftValue = -17;
  }

  if (hsvSchema === void 0) {
    hsvSchema = 360;
  }

  var newColor = restoreCssHexColor(color);
  var shift = shiftValue;
  var type = 'h';
  var mod = 1; // edit Brightness if it gray shade

  if (isGrayShade(newColor)) {
    type = 'v';
    shift = 30;
  }

  newColor = hex2hsv(newColor);

  if (newColor.h > 0.119 && newColor.h < 0.23) {
    shift = -10;
  }

  if (newColor.h * hsvSchema + shift >= hsvSchema || newColor.h * hsvSchema + shift <= 0) {
    mod = -1;
  }

  newColor[type] = (newColor.h * hsvSchema + shift * mod) / hsvSchema;
  return hsv2hex(newColor);
}

function checkHash(color) {
  if (!isDefinedByType(color, 'string') || color.length !== 6 && color.length !== 7) {
    return '';
  }

  return isHexColor(color) ? color : "#" + color;
}

function isWhite(hex) {
  return hex && restoreCssHexColor(hex) === '#ffffff';
}

function productGradientColor(hex) {
  var _hex2rgb = hex2rgb(restoreCssHexColor(hex)),
      r = _hex2rgb.r,
      g = _hex2rgb.g,
      b = _hex2rgb.b;

  var _rgb2hsl = rgb2hsl({
    r: r,
    g: g,
    b: b
  }),
      h = _rgb2hsl.h,
      s = _rgb2hsl.s,
      l = _rgb2hsl.l;

  var isDarkColor = s < 0.5;
  var hueOffset = isDarkColor ? -10 : 10;
  var lightnessOffset = 0.15;
  var result;

  if (Math.abs(r - g) <= 3 && Math.abs(b - g) <= 3) {
    result = rgb2hex(hsl2rgb({
      h: h,
      s: s,
      l: l + lightnessOffset
    }));
  } else {
    result = rgb2hex(hsl2rgb({
      h: h + hueOffset / 360,
      s: s,
      l: l + lightnessOffset
    }));
  }

  return result;
}