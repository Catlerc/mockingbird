const DEFAULT_STRING = '';
const DEFAULT_RGB = {
  r: 255,
  g: 255,
  b: 255
};
const DEFAULT_HSV = {
  h: 0,
  s: 0,
  v: 1
};
export const list = ['#00bee0', '#ffdd2d', '#5695c4', '#b39fda', '#ff9797', '#37a89d', '#6bd2ec', '#ffad5c', '#b3baec', '#ffb4b4', '#68c24d', '#80abcc', '#ffba00', '#b186c4', '#f97f7c', '#17d15f', '#589db6', '#ff9138', '#d4a0f3', '#d97789', '#50a06f', '#00c6d3', '#ff7047', '#db8cec', '#dd567a', '#4dbf81', '#66b1ad', '#f2bc85', '#f3a3ff', '#ff85b4', '#bfd386'];

function isDefinedByType(value, type) {
  return value !== '' && value !== undefined && typeof value === type; // eslint-disable-line valid-typeof
}

export function isRGBColor(color) {
  return isDefinedByType(color, 'object') && isDefinedByType(color.r, 'number') && isDefinedByType(color.g, 'number') && isDefinedByType(color.b, 'number');
}
export function isHSVColor(color) {
  return isDefinedByType(color, 'object') && isDefinedByType(color.h, 'number') && isDefinedByType(color.s, 'number') && isDefinedByType(color.v, 'number');
}
export function isHexColor(color) {
  return isDefinedByType(color, 'string') && (color.length === 7 || color.length === 4) && /^#/.test(color);
}
export function isHexAColor(color) {
  return isDefinedByType(color, 'string') && /^#[0-9a-fA-F]{8}$/.test(color);
}
export function restoreCssHexColor(hexValue = '') {
  let hex = hexValue.toLowerCase().replace(/[^\da-f]/g, '');

  if (!isDefinedByType(hex, 'string') || hex.length !== 3 && hex.length !== 6) {
    return DEFAULT_STRING;
  }

  if (hex.length === 3) {
    hex = hex.replace(/(.)/g, '$1$1');
  }

  return `#${hex}`;
}
export function isGrayShade(hex) {
  const color = restoreCssHexColor(hex);
  return color.slice(1, 3) === color.slice(3, 5) && color.slice(3, 5) === color.slice(5, 7);
}
export function luminance(rgb) {
  // http://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color/3943023#3943023
  if (!isRGBColor(rgb)) {
    return DEFAULT_STRING;
  }

  return rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114;
}
export function getColor(n) {
  const i = !isDefinedByType(n, 'number') || n < 0 ? 0 : n;
  return list[i % list.length];
}
export function hex2rgb(hex) {
  if (!isHexColor(hex)) {
    return DEFAULT_RGB;
  }

  return {
    r: parseInt(hex.substr(1, 2), 16),
    g: parseInt(hex.substr(3, 2), 16),
    b: parseInt(hex.substr(5, 2), 16)
  };
}
/**
 * see https://www.compuphase.com/cmetric.htm
 * @name colorsPerceiveDiff
 * @description определяет размер визуальной разницы между двумя цветами
 * @param {string} first hex цвет
 * @param {string} second еще hex цвет
 * @return {number} расстояние
 */

function colorsPerceiveDiff(first, second) {
  const firstRGB = hex2rgb(restoreCssHexColor(first));
  const secondRGB = hex2rgb(restoreCssHexColor(second));
  const rMean = (firstRGB.r + secondRGB.r) / 2;
  const rDiff = firstRGB.r - secondRGB.r;
  const gDiff = firstRGB.g - secondRGB.g;
  const bDiff = firstRGB.b - secondRGB.b;
  const rWeight = 2 + rMean / 256;
  const gWeight = 4;
  const bWeight = 2 + (255 - rMean) / 256;
  return Math.sqrt(rWeight * rDiff * rDiff + gWeight * gDiff * gDiff + bWeight * bDiff * bDiff);
}

let maxPerceiveDiff;
/**
 * @name colorsDiff
 * @param {string} first hex цвет
 * @param {string} second еще hex цвет
 * @return {number} нормализованное расстояние в диапазоне [0..100]
 */

export function colorsDiff(first, second) {
  if (maxPerceiveDiff === undefined) {
    maxPerceiveDiff = colorsPerceiveDiff('fff', '000');
  }

  return 100 * colorsPerceiveDiff(first, second) / maxPerceiveDiff;
}
export function calcFontColor(hex) {
  if (!isHexColor(hex)) {
    return '#333';
  }

  return luminance(hex2rgb(restoreCssHexColor(hex))) > 186 ? '#333' : '#fff';
}
export function colorType(hex) {
  if (!isHexColor(hex)) {
    return 'light';
  }

  return luminance(hex2rgb(restoreCssHexColor(hex))) > 186 ? 'light' : 'dark';
}
export function hex2rgba(hex, opacity = 1) {
  if (!isHexColor(hex)) {
    return `rgba(${DEFAULT_RGB.r},${DEFAULT_RGB.g},${DEFAULT_RGB.b},1)`;
  }

  const rgb = hex2rgb(hex);
  return `rgba(${rgb.r},${rgb.g},${rgb.b},${opacity})`;
}
export function dec2hex(dec) {
  if (dec > 255 || dec < 0) {
    return 'ff';
  }

  const hex = Math.round(+dec).toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
}
export function rgb2hex(rgb) {
  if (!isRGBColor(rgb)) {
    return '#ffffff';
  }

  return `#${dec2hex(rgb.r)}${dec2hex(rgb.g)}${dec2hex(rgb.b)}`;
}
export function rgba2hex(color) {
  const values = color.replace(/rgba?\(/, '').replace(/\)/, '').replace(/[\s+]/g, '').split(',');
  const a = parseFloat(values[3] || 1);
  const r = Math.round(a * parseInt(values[0], 10) + (1 - a) * 255);
  const g = Math.round(a * parseInt(values[1], 10) + (1 - a) * 255);
  const b = Math.round(a * parseInt(values[2], 10) + (1 - a) * 255);
  return `#${`0${r.toString(16)}`.slice(-2)}${`0${g.toString(16)}`.slice(-2)}${`0${b.toString(16)}`.slice(-2)}`;
}
export function hexa2hex(color) {
  const [r, g, b, a] = color.match(/^#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})$/).slice(1).map(n => parseInt(n, 16));
  return `#${[r, g, b].map(n => Math.floor(n * a / 255) + 255 - a).map(n => `0${n.toString(16)}`.slice(-2)).join('')}`;
} // https://github.com/colorjs/color-space/blob/master/hsl.js

export function rgb2hsl(rgb) {
  const r = rgb.r / 255;
  const g = rgb.g / 255;
  const b = rgb.b / 255;
  let h;
  let s;
  const min = Math.min(r, g, b);
  const max = Math.max(r, g, b);
  const delta = max - min;

  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }

  h = Math.min(h * 60, 360);

  if (h < 0) {
    h += 360;
  }

  const l = (min + max) / 2;

  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }

  return {
    h: h / 360,
    s,
    l
  };
} //  https://github.com/colorjs/color-space/blob/master/hsl.js

export function hsl2rgb(hsl) {
  const {
    h,
    s,
    l
  } = hsl;
  let t2;
  let t3;
  let val;

  if (s === 0) {
    val = l * 255;
    return {
      r: val,
      g: val,
      b: val
    };
  }

  if (l < 0.5) {
    t2 = l * (1 + s);
  } else {
    t2 = l + s - l * s;
  }

  const t1 = 2 * l - t2;
  const rgb = [0, 0, 0];

  for (let i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * -(i - 1);

    if (t3 < 0) {
      t3++;
    } else if (t3 > 1) {
      t3--;
    }

    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }

    rgb[i] = val * 255;
  }

  return {
    r: rgb[0],
    g: rgb[1],
    b: rgb[2]
  };
} // eslint-disable-next-line max-statements

export function rgb2hsv(rgb) {
  if (!isRGBColor(rgb)) {
    return DEFAULT_HSV;
  }

  const r = rgb.r / 255;
  const g = rgb.g / 255;
  const b = rgb.b / 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const v = max;
  const d = max - min;
  const s = max === 0 ? 0 : d / max;
  let h = max;

  if (max === min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;

      case g:
        h = (b - r) / d + 2;
        break;

      case b:
        h = (r - g) / d + 4;
        break;
    }

    h /= 6;
  }

  return {
    h,
    s,
    v
  };
}
export function hsv2rgb(hsv) {
  let r;
  let g;
  let b;
  let i;
  let f;
  let p;
  let q;
  let t;

  if (!isHSVColor(hsv)) {
    return DEFAULT_RGB;
  }
  /* eslint-disable prefer-const */


  i = Math.floor(hsv.h * 6);
  f = hsv.h * 6 - i;
  p = hsv.v * (1 - hsv.s);
  q = hsv.v * (1 - f * hsv.s);
  t = hsv.v * (1 - (1 - f) * hsv.s);
  /* eslint-enable prefer-const */

  switch (i % 6) {
    case 0:
      r = hsv.v;
      g = t;
      b = p;
      break;

    case 1:
      r = q;
      g = hsv.v;
      b = p;
      break;

    case 2:
      r = p;
      g = hsv.v;
      b = t;
      break;

    case 3:
      r = p;
      g = q;
      b = hsv.v;
      break;

    case 4:
      r = t;
      g = p;
      b = hsv.v;
      break;

    case 5:
      r = hsv.v;
      g = p;
      b = q;
      break;
  }

  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}
export function hex2hsv(hex) {
  if (!isHexColor(hex)) {
    return DEFAULT_HSV;
  }

  return rgb2hsv(hex2rgb(hex));
}
export function hsv2hex(hsv) {
  if (!isHSVColor(hsv)) {
    return DEFAULT_STRING;
  }

  return rgb2hex(hsv2rgb(hsv));
}
export function getShiftColor(color, shiftValue = -17, hsvSchema = 360) {
  let newColor = restoreCssHexColor(color);
  let shift = shiftValue;
  let type = 'h';
  let mod = 1; // edit Brightness if it gray shade

  if (isGrayShade(newColor)) {
    type = 'v';
    shift = 30;
  }

  newColor = hex2hsv(newColor);

  if (newColor.h > 0.119 && newColor.h < 0.23) {
    shift = -10;
  }

  if (newColor.h * hsvSchema + shift >= hsvSchema || newColor.h * hsvSchema + shift <= 0) {
    mod = -1;
  }

  newColor[type] = (newColor.h * hsvSchema + shift * mod) / hsvSchema;
  return hsv2hex(newColor);
}
export function checkHash(color) {
  if (!isDefinedByType(color, 'string') || color.length !== 6 && color.length !== 7) {
    return '';
  }

  return isHexColor(color) ? color : `#${color}`;
}
export function isWhite(hex) {
  return hex && restoreCssHexColor(hex) === '#ffffff';
}
export function productGradientColor(hex) {
  const {
    r,
    g,
    b
  } = hex2rgb(restoreCssHexColor(hex));
  const {
    h,
    s,
    l
  } = rgb2hsl({
    r,
    g,
    b
  });
  const isDarkColor = s < 0.5;
  const hueOffset = isDarkColor ? -10 : 10;
  const lightnessOffset = 0.15;
  let result;

  if (Math.abs(r - g) <= 3 && Math.abs(b - g) <= 3) {
    result = rgb2hex(hsl2rgb({
      h,
      s,
      l: l + lightnessOffset
    }));
  } else {
    result = rgb2hex(hsl2rgb({
      h: h + hueOffset / 360,
      s,
      l: l + lightnessOffset
    }));
  }

  return result;
}