let scrollingElement;

function getScrollWidth() {
  return window.innerWidth - document.documentElement.clientWidth;
}

let hasScrollBar;
export function bodyHasScrollBar() {
  if (hasScrollBar === undefined) {
    return !!getScrollWidth();
  }

  return hasScrollBar;
}

function findScrollingElement() {
  const html = document.querySelector('html');
  const {
    body
  } = document;
  const htmlStyles = window.getComputedStyle(html);

  if (htmlStyles['overflow-x'] === 'scroll' || htmlStyles['overflow-y'] === 'scroll') {
    return html;
  }

  return body;
}

if (typeof window !== 'undefined') {
  try {
    scrollingElement = findScrollingElement();
  } catch (e) {}

  window.addEventListener('DOMContentLoaded', () => {
    if (!scrollingElement) {
      scrollingElement = findScrollingElement();
    }
  });
}

let locks = [];
let previousBodyOverflowSetting;
let previousBodyPaddingRight;

const setOverflowHidden = () => {
  setTimeout(() => {
    // If previousBodyPaddingRight is already set, don't set it again.
    if (previousBodyPaddingRight === undefined) {
      const scrollBarGap = getScrollWidth();
      hasScrollBar = scrollBarGap > 0;

      if (hasScrollBar) {
        previousBodyPaddingRight = scrollingElement.style.paddingRight;
        scrollingElement.style.paddingRight = `${scrollBarGap}px`;
      }
    } // If previousBodyOverflowSetting is already set, don't set it again.


    if (previousBodyOverflowSetting === undefined) {
      previousBodyOverflowSetting = scrollingElement.style.overflow;
      scrollingElement.style.overflow = 'hidden';
    }
  });
};

const restoreOverflowSetting = () => {
  // Setting overflow on body/documentElement synchronously in Desktop Safari slows down
  // the responsiveness for some reason. Setting within a setTimeout fixes this.
  setTimeout(() => {
    if (previousBodyPaddingRight !== undefined) {
      scrollingElement.style.paddingRight = previousBodyPaddingRight; // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it
      // can be set again.

      previousBodyPaddingRight = undefined;
    }

    if (previousBodyOverflowSetting !== undefined) {
      scrollingElement.style.overflow = previousBodyOverflowSetting; // Restore previousBodyOverflowSetting to undefined
      // so setOverflowHidden knows it can be set again.

      previousBodyOverflowSetting = undefined;
    }

    hasScrollBar = undefined;
  });
};
/**
 * @deprecated
 * Используйте disableBodyScroll из @platform-ui/body-scroll-lock
 */


export const disableBodyScroll = (targetElement, options) => {
  setOverflowHidden(options);
  const lock = {
    targetElement,
    options: options || {}
  };
  locks = [...locks, lock];
};
/**
 * @deprecated
 * Используйте clearAllBodyScrollLocks из @platform-ui/body-scroll-lock
 */

export const clearAllBodyScrollLocks = () => {
  restoreOverflowSetting();
  locks = [];
};
/**
 * @deprecated
 * Используйте enableBodyScroll из @platform-ui/body-scroll-lock
 */

export const enableBodyScroll = targetElement => {
  if (locks.length === 1 && locks[0].targetElement === targetElement) {
    restoreOverflowSetting();
    locks = [];
  } else {
    locks = locks.filter(lock => lock.targetElement !== targetElement);
  }
};