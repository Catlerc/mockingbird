"use strict";

exports.__esModule = true;
exports.bodyHasScrollBar = bodyHasScrollBar;
exports.enableBodyScroll = exports.disableBodyScroll = exports.clearAllBodyScrollLocks = void 0;
var scrollingElement;

function getScrollWidth() {
  return window.innerWidth - document.documentElement.clientWidth;
}

var hasScrollBar;

function bodyHasScrollBar() {
  if (hasScrollBar === undefined) {
    return !!getScrollWidth();
  }

  return hasScrollBar;
}

function findScrollingElement() {
  var html = document.querySelector('html');
  var _document = document,
      body = _document.body;
  var htmlStyles = window.getComputedStyle(html);

  if (htmlStyles['overflow-x'] === 'scroll' || htmlStyles['overflow-y'] === 'scroll') {
    return html;
  }

  return body;
}

if (typeof window !== 'undefined') {
  try {
    scrollingElement = findScrollingElement();
  } catch (e) {}

  window.addEventListener('DOMContentLoaded', function () {
    if (!scrollingElement) {
      scrollingElement = findScrollingElement();
    }
  });
}

var locks = [];
var previousBodyOverflowSetting;
var previousBodyPaddingRight;

var setOverflowHidden = function setOverflowHidden() {
  setTimeout(function () {
    // If previousBodyPaddingRight is already set, don't set it again.
    if (previousBodyPaddingRight === undefined) {
      var scrollBarGap = getScrollWidth();
      hasScrollBar = scrollBarGap > 0;

      if (hasScrollBar) {
        previousBodyPaddingRight = scrollingElement.style.paddingRight;
        scrollingElement.style.paddingRight = scrollBarGap + "px";
      }
    } // If previousBodyOverflowSetting is already set, don't set it again.


    if (previousBodyOverflowSetting === undefined) {
      previousBodyOverflowSetting = scrollingElement.style.overflow;
      scrollingElement.style.overflow = 'hidden';
    }
  });
};

var restoreOverflowSetting = function restoreOverflowSetting() {
  // Setting overflow on body/documentElement synchronously in Desktop Safari slows down
  // the responsiveness for some reason. Setting within a setTimeout fixes this.
  setTimeout(function () {
    if (previousBodyPaddingRight !== undefined) {
      scrollingElement.style.paddingRight = previousBodyPaddingRight; // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it
      // can be set again.

      previousBodyPaddingRight = undefined;
    }

    if (previousBodyOverflowSetting !== undefined) {
      scrollingElement.style.overflow = previousBodyOverflowSetting; // Restore previousBodyOverflowSetting to undefined
      // so setOverflowHidden knows it can be set again.

      previousBodyOverflowSetting = undefined;
    }

    hasScrollBar = undefined;
  });
};
/**
 * @deprecated
 * Используйте disableBodyScroll из @platform-ui/body-scroll-lock
 */


var disableBodyScroll = function disableBodyScroll(targetElement, options) {
  setOverflowHidden(options);
  var lock = {
    targetElement: targetElement,
    options: options || {}
  };
  locks = [].concat(locks, [lock]);
};
/**
 * @deprecated
 * Используйте clearAllBodyScrollLocks из @platform-ui/body-scroll-lock
 */


exports.disableBodyScroll = disableBodyScroll;

var clearAllBodyScrollLocks = function clearAllBodyScrollLocks() {
  restoreOverflowSetting();
  locks = [];
};
/**
 * @deprecated
 * Используйте enableBodyScroll из @platform-ui/body-scroll-lock
 */


exports.clearAllBodyScrollLocks = clearAllBodyScrollLocks;

var enableBodyScroll = function enableBodyScroll(targetElement) {
  if (locks.length === 1 && locks[0].targetElement === targetElement) {
    restoreOverflowSetting();
    locks = [];
  } else {
    locks = locks.filter(function (lock) {
      return lock.targetElement !== targetElement;
    });
  }
};

exports.enableBodyScroll = enableBodyScroll;