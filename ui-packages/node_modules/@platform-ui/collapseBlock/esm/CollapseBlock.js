import React, { useRef, useState, useEffect, useCallback } from 'react';
import cn from 'classnames';
import dataQa from '@platform-ui/dataQa';
import s from './CollapseBlock.module.css';

const CollapseBlock = props => {
  const {
    dataQaType = 'uikit/CollapseBlock',
    dataQaData,
    collapsed,
    children,
    minHeight,
    duration = 250,
    delay,
    overflowHidden = true,
    childrenAlign = 'top',
    removeCollapsedContent = true,
    onTransitionEnd,
    fallbackRender = false
  } = props;
  const [height, setHeight] = useState(fallbackRender || !collapsed ? null : 0);
  const [animationState, setAnimationState] = useState(collapsed ? 'collapsed' : 'expanded');
  const initedRef = useRef(false);
  const childrenBlock = useRef(null);
  useEffect(() => {
    if (!initedRef.current) {
      initedRef.current = true;
      return;
    }

    if (!childrenBlock.current) {
      return;
    }

    if (animationState === 'collapsed') {
      setAnimationState('preparing');
    } else if (animationState === 'expanded') {
      setAnimationState('preparing');
      setHeight(childrenBlock.current.offsetHeight);
    } else {
      setHeight(collapsed ? 0 : childrenBlock.current.offsetHeight);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [collapsed]);
  useEffect(() => {
    if (!childrenBlock.current) {
      return;
    }

    if (animationState === 'preparing') {
      setHeight(collapsed ? 0 : childrenBlock.current.offsetHeight);
      setAnimationState('animating');
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [animationState]);
  const handleTransitionEnd = useCallback(e => {
    if (e.target !== e.currentTarget) {
      return;
    }

    if (collapsed) {
      setAnimationState('collapsed');
    } else {
      setAnimationState('expanded');
      setHeight(null);
    }

    onTransitionEnd && onTransitionEnd(e);
  }, [onTransitionEnd, collapsed]);
  const transitionDuration = animationState === 'animating' ? `${duration}ms` : undefined;
  const transitionDelay = delay && animationState === 'animating' ? `${delay}ms` : undefined;
  const overflow = overflowHidden || animationState !== 'expanded' ? 'hidden' : undefined;
  const hideChildren = removeCollapsedContent && animationState === 'collapsed';
  return /*#__PURE__*/React.createElement("div", Object.assign({}, dataQa({
    dataQaType,
    dataQaData
  }), {
    onTransitionEnd: handleTransitionEnd,
    className: s.container,
    style: {
      minHeight,
      height,
      overflow,
      WebkitTransitionDuration: transitionDuration,
      transitionDuration,
      WebkitTransitionDelay: transitionDelay,
      transitionDelay
    }
  }), /*#__PURE__*/React.createElement("div", {
    ref: childrenBlock,
    className: cn({
      [s.childrenBlock_animating]: animationState !== 'expanded' && typeof height === 'number',
      [s[`childrenBlock_align_${childrenAlign}`]]: childrenAlign
    })
  }, hideChildren ? null : children));
};
/* TODO: убрать в следующем мажорном обновлении */


CollapseBlock.defaultProps = {
  dataQaType: 'uikit/CollapseBlock',
  duration: 250,
  overflowHidden: true,
  childrenAlign: 'top',
  removeCollapsedContent: true
};
export default CollapseBlock;