import _extends from "@babel/runtime/helpers/extends";
import React, { PureComponent, createRef } from 'react';
import pt from 'prop-types';
import cn from 'classnames';
import keycode from 'keycode';
import isEmpty from '@tinkoff/utils/is/empty';
import isNil from '@tinkoff/utils/is/nil';
import noop from '@tinkoff/utils/function/noop';
import generateId from '@platform-ui/generateId';
import { getSelectedOptions, isOptionSelected, filterOption, filterOptions } from '@platform-ui/dropdown/utils';
import IconArrowDown from '@platform-ui/iconsPack/interface/24/ArrowDown';
import addEventOutsideListener from '@platform-ui/eventOutside';
import InputBox from '@platform-ui/inputBox';
import Dropdown from '@platform-ui/dropdown';
import ScrollBlock from '@platform-ui/scrollBlock';
import { InlineInput, FocusArea } from '@platform-ui/inputTools';
import overrideStyles from '@platform-ui/overrideStyles';
import { getOptionsLength } from './utils';
import baseStyles from './Select.module.css';

class Select extends PureComponent {
  constructor(props) {
    super(props);
    this.dropdownId = generateId(this);
    this.labelId = generateId(this);

    this.handleClose = () => {
      this.close();
    };

    this.handleKeyDown = event => {
      const {
        onKeyDown,
        name
      } = this.props;
      const key = keycode(event);

      if (['enter', 'up', 'down'].indexOf(key) !== -1 || !this.canBeFiltered() && key === 'space') {
        event.preventDefault();
        this.open();
      }

      onKeyDown(event, {
        name,
        key
      });
    };

    this.handleClean = event => {
      const {
        onChange,
        onClean,
        name,
        focusOnClean
      } = this.props;
      event.stopPropagation();

      if (focusOnClean) {
        this.open();
        this.focus();
      }

      this.setState({
        filterValue: ''
      });
      onChange(event, {
        value: this.constructor.defaultProps.value,
        name,
        source: 'clean'
      });
      onClean(event, {
        name
      });
    };

    this.handleControlFocus = event => {
      const {
        onFocus,
        name
      } = this.props;
      onFocus(event, {
        name
      });
      this.focus();
    };

    this.handleControlBlur = event => {
      const {
        name,
        options,
        onBlur,
        onChange,
        defaultOption,
        extractTextValue
      } = this.props;
      onBlur(event, {
        name
      });
      const selectedOption = getSelectedOptions(options, this.state.filterValue);

      if (defaultOption && isEmpty(selectedOption) && this.state.filterValue !== '') {
        onChange(event, {
          name,
          value: defaultOption.value,
          source: 'blur'
        });
        this.setState({
          filterValue: extractTextValue(defaultOption)
        });
      }

      this.blur();
    };

    this.handleControlClick = () => {
      if (this.state.opened) {
        this.close();
      } else {
        this.open();
      }
    };

    this.handleOptionSelect = (event, {
      value,
      option
    }) => {
      const {
        onChange,
        onFieldDone,
        closeOnSelect,
        name,
        extractTextValue,
        onOptionSelect
      } = this.props;

      if (value === undefined) {
        return;
      }

      onOptionSelect == null ? void 0 : onOptionSelect(event, {
        value,
        name,
        source: 'optionSelect'
      });
      onChange(event, {
        value,
        name,
        source: 'optionSelect'
      });
      this.setState({
        filterValue: extractTextValue(option)
      });

      if (closeOnSelect) {
        onFieldDone(event, {
          value,
          name
        });
      }
    };

    this.handleFilterChange = e => {
      const filterValue = e.target.value;
      const {
        name,
        onChange,
        onFilterChange,
        minDropdownShowLength
      } = this.props;
      this.setState({
        filterValue
      }, () => {
        if (filterValue.length >= minDropdownShowLength) {
          this.open();
        } else {
          this.close();
        }
      });
      onFilterChange(e, {
        name,
        filterValue
      });
      onChange(e, {
        value: this.constructor.defaultProps.value,
        name,
        source: 'filterChange'
      });
    };

    this.handleToggleClick = () => {
      if (!this.props.focused || this.state.preventFocusClick) {
        return;
      }

      if (this.state.opened) {
        this.close();
      } else {
        this.open();
      }
    };

    this.handleDocumentClick = () => {
      this.setState({
        preventFocusClick: false
      });
      document.removeEventListener('click', this.handleDocumentClick);
    };

    this.handleControlMouseDown = () => {
      if (this.props.focused) {
        return;
      }

      this.open();
      this.setState({
        preventFocusClick: true
      });
      document.addEventListener('click', this.handleDocumentClick);
    };

    this.renderArrow = onClick => {
      const {
        opened,
        arrowAriaLabelOpened,
        arrowAriaLabelClosed
      } = this.props;
      return /*#__PURE__*/React.createElement("span", {
        className: this.state.styles.arrow,
        onClick: onClick,
        role: "button",
        "aria-pressed": opened,
        "aria-label": opened ? arrowAriaLabelOpened : arrowAriaLabelClosed
      }, /*#__PURE__*/React.createElement(IconArrowDown, null));
    };

    const {
      opened: _opened,
      disabled,
      readOnly
    } = props;
    this.state = {
      selectedOption: getSelectedOptions(props.options, props.value) || {},
      opened: _opened && !disabled && !readOnly,
      filterValue: ''
    };
    this.filterCache = {};
    this.enrichCache = {};
    this.rootRef = /*#__PURE__*/createRef();
    this.controlRef = /*#__PURE__*/createRef();
    this.scrollBlockRef = /*#__PURE__*/createRef();
  }
  /* eslint-disable react/forbid-prop-types */


  static getDerivedStateFromProps(props, state) {
    var _props$__overrideStyl;

    return _extends({}, state, {
      selectedOption: getSelectedOptions(props.options, props.value) || {},
      styles: overrideStyles(baseStyles, props == null ? void 0 : (_props$__overrideStyl = props.__overrideStyles) == null ? void 0 : _props$__overrideStyl.Select)
    });
  }

  componentDidMount() {
    this.props.focused ? this.focus() : this.blur();
    this.updateListeningOutsideEvents();
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.props.focused && (this.props.value !== prevProps.value || this.state.filterValue !== prevState.filterValue)) {
      this.setScrollPosition('right');
    }

    if (this.props.opened !== prevProps.opened) {
      this.props.opened ? this.open() : this.close();
    }

    if (this.props.focused !== prevProps.focused && this.props.focused) {
      this.focus();
    }

    if (!this.props.focused && this.props.value !== prevProps.value) {
      this.resetFilterValue();
    }

    this.updateListeningOutsideEvents();
  }

  componentWillUnmount() {
    this.stopListeningOutsideEvents();
  }

  resetFilterValue() {
    const {
      selectedOption
    } = this.state;
    const {
      extractTextValue,
      defaultOption
    } = this.props;
    let filterValue;

    if (!isEmpty(selectedOption)) {
      filterValue = extractTextValue(selectedOption);
    } else if (defaultOption) {
      filterValue = extractTextValue(defaultOption);
    } else {
      filterValue = '';
    }

    this.setState({
      filterValue
    });
  }

  close() {
    const {
      name,
      onClose
    } = this.props;

    if (this.state.opened) {
      this.setState({
        opened: false
      });
      onClose(null, {
        name
      });
    }
  }

  open() {
    const {
      disabled,
      readOnly,
      onOpen,
      name,
      minDropdownShowLength
    } = this.props;
    const {
      opened,
      filterValue
    } = this.state;

    if (!opened && !disabled && !readOnly && (!this.canBeFiltered() || filterValue.length >= minDropdownShowLength)) {
      this.setState({
        opened: true
      });
      onOpen(null, {
        name
      });
    }
  }

  canBeFiltered() {
    const {
      options,
      searchThreshold
    } = this.props;
    return getOptionsLength(options) >= searchThreshold;
  }

  isControlFocused() {
    /**
     * Используем contains вместо === из-за особенностей работы activeElement в IE
     * https://stackoverflow.com/questions/30935637/wrong-activeelement-in-focus-in-ie11
     */
    return !!(this.controlRef.current && this.controlRef.current.contains(document.activeElement));
  }

  focus() {
    if (this.isControlFocused()) {
      return;
    }

    this.controlRef.current && this.controlRef.current.focus && this.controlRef.current.focus();
  }

  blur() {
    this.setScrollPosition('left');
    this.close();
    this.controlRef.current && this.controlRef.current.blur && this.controlRef.current.blur();
  }

  setScrollPosition(side) {
    this.scrollBlockRef.current && this.scrollBlockRef.current.setScrollPosition && this.scrollBlockRef.current.setScrollPosition(side);
  } // проставляет флаги selected и примешивает defaultOptionProps


  enrichOptions(options, value, defaultOptionProps) {
    if (this.enrichCache.options === options && this.enrichCache.value === value && this.enrichCache.defaultOptionProps === defaultOptionProps) {
      return this.enrichCache.enrichedOptions;
    }

    this.enrichCache = {
      value,
      options,
      defaultOptionProps,
      enrichedOptions: options && options.map(option => option.options ? _extends({}, option, {
        options: this.enrichOptions(option.options, value, defaultOptionProps)
      }) : _extends({}, option, defaultOptionProps, {
        selected: isOptionSelected(value, option)
      }))
    };
    return this.enrichCache.enrichedOptions;
  }

  shouldApplyFilter() {
    const {
      options,
      value
    } = this.props;
    return getSelectedOptions(options, value).length === 0;
  }

  getFilteredOptions() {
    const {
      options,
      filterFunc,
      transformOptions,
      defaultOption
    } = this.props;

    if (!this.canBeFiltered() || !this.shouldApplyFilter()) {
      return options;
    }

    const {
      filterValue
    } = this.state;

    if (this.filterCache.filterValue === filterValue && this.filterCache.options === options && this.filterCache.filterFunc === filterFunc && this.filterCache.transformOptions === transformOptions) {
      return this.filterCache.filteredOptions;
    }

    const filteredOptions = transformOptions(options, filterValue, filterFunc);

    if (defaultOption) {
      filteredOptions.push(defaultOption);
    }

    this.filterCache = {
      filterValue,
      options,
      filterFunc,
      transformOptions,
      filteredOptions
    };
    return filteredOptions;
  }

  startListeningOutsideEvents() {
    if (this.removeOutsideListeners) {
      return;
    }

    const outsideListeners = ['click', 'focusin'].map(eventType => addEventOutsideListener(this.rootRef.current, eventType, this.handleClose));

    this.removeOutsideListeners = () => {
      outsideListeners.forEach(removeListener => {
        removeListener();
      });
    };
  }

  stopListeningOutsideEvents() {
    if (!this.removeOutsideLiseners) {
      return;
    }

    this.removeOutsideListeners();
    this.removeOutsideListeners = null;
  }

  updateListeningOutsideEvents() {
    if (this.rootRef.current && this.state.selectedOption.controlComponent && this.state.opened) {
      this.startListeningOutsideEvents();
    } else {
      this.stopListeningOutsideEvents();
    }
  }

  renderInput() {
    const {
      autoComplete,
      value,
      options: originOptions,
      focused,
      disabled,
      readOnly,
      extractTextValue,
      defaultOption,
      cobrowsingSecure,
      dataQaType,
      renderFilter,
      name
    } = this.props;
    const {
      filterValue,
      styles
    } = this.state;
    const options = defaultOption ? originOptions.concat(defaultOption) : originOptions;
    const inputValue = !this.shouldApplyFilter() && extractTextValue(getSelectedOptions(options, value)) || filterValue;
    return /*#__PURE__*/React.createElement("div", {
      className: cn({
        [styles.inputContainer]: true,
        [styles.inputContainer_visible]: focused || inputValue
      })
    }, renderFilter({
      name,
      dataQaType,
      cobrowsingSecure,
      autoComplete,
      ref: this.controlRef,
      value: inputValue,
      disabled,
      readOnly,
      onBlur: this.handleControlBlur,
      onFocus: this.handleControlFocus,
      onChange: this.handleFilterChange
    }));
  }

  renderSideContent(side) {
    const sideName = `${side}Content`;
    const {
      selectedItemInfo,
      emptyOptionProps
    } = this.props;
    const {
      selectedOption,
      styles
    } = this.state;
    const sideContent = isEmpty(selectedOption) ? emptyOptionProps[sideName] : selectedOption[sideName];
    let computedSideContent = null;

    if (Array.isArray(selectedItemInfo) && selectedItemInfo.indexOf(sideName) !== -1) {
      const content = selectedItemInfo.indexOf(sideName) !== -1 && sideContent;
      computedSideContent = typeof content === 'function' ? content(_extends({}, this.props, this.state)) : content;
    }

    return !!computedSideContent && /*#__PURE__*/React.createElement("div", {
      className: styles.customContent
    }, computedSideContent);
  }

  renderSelectedOptionControl() {
    const {
      dataQaType,
      focused,
      error,
      flatCorners,
      disabled,
      readOnly,
      name,
      tabIndex,
      onClean
    } = this.props;
    /**
     * Временный проп для переопределения стилей, не предназначен для широкого использования.
     * Создан специально для задачи https://
     * TODO: удалить когда появится общий механизм темизации.
     */

    const {
      __overrideStyles
    } = this.props;
    const {
      selectedOption
    } = this.state;
    const {
      controlComponent,
      controlComponentProps
    } = selectedOption;
    return /*#__PURE__*/React.createElement(controlComponent, _extends({
      dataQaType: `${dataQaType}.value`,
      inputIcon: this.renderArrow(this.handleControlClick),
      focused,
      error,
      flatCorners,
      disabled,
      readOnly,
      name,
      tabIndex,
      onBlur: this.handleControlBlur,
      onFocus: this.handleControlFocus,
      onClean,
      __overrideStyles
    }, controlComponentProps));
  }

  renderFilterControl(childrenProps) {
    const {
      error,
      focused,
      tabIndex,
      disabled,
      readOnly,
      required,
      cleanable,
      hintBlock,
      placeholder,
      flatCorners,
      renderLabel,
      empty,
      filterValue,
      size,
      expandable,
      styles,
      dataQaType
    } = childrenProps;
    const label = renderLabel(childrenProps);
    const content = /*#__PURE__*/React.createElement(React.Fragment, null, empty && (!filterValue || !focused && !label) && /*#__PURE__*/React.createElement("div", {
      className: styles.placeholder,
      "data-qa-type": `${dataQaType}.placeholder`
    }, placeholder), this.renderInput(childrenProps));
    return /*#__PURE__*/React.createElement(FocusArea, {
      tagName: "label",
      role: "label",
      style: {
        cursor: 'text '
      }
    }, /*#__PURE__*/React.createElement(InputBox, {
      __overrideStyles: this.props.__overrideStyles,
      label: label,
      rightContent: this.renderSideContent('right'),
      leftContent: this.renderSideContent('left'),
      hintBlock: hintBlock,
      inputIcon: this.renderArrow(this.handleToggleClick),
      error: error,
      filled: !empty,
      focused: focused,
      tabIndex: disabled ? null : tabIndex,
      readOnly: readOnly,
      disabled: disabled,
      required: required,
      size: size,
      expandable: expandable,
      cleanable: cleanable && (!empty || !!filterValue),
      flatCorners: flatCorners,
      onClean: this.handleClean,
      onMouseDown: this.handleControlMouseDown,
      labelId: this.labelId,
      dataQaType: `${dataQaType}.wrapper`
    }, !expandable ? /*#__PURE__*/React.createElement(ScrollBlock, {
      ref: this.scrollBlockRef,
      noScroll: !focused
    }, content) : content));
  }

  renderDefaultControl(childrenProps) {
    const {
      error,
      expandable,
      focused,
      tabIndex,
      disabled,
      readOnly,
      required,
      cleanable,
      hintBlock,
      placeholder,
      flatCorners,
      renderLabel,
      renderValue,
      empty,
      size,
      styles,
      dataQaType
    } = childrenProps;
    const content = empty ? /*#__PURE__*/React.createElement("div", {
      className: styles.placeholder
    }, placeholder) : /*#__PURE__*/React.createElement("div", {
      className: cn({
        [styles.valueWrapper]: true,
        [styles.valueWrapper_expandable]: expandable
      })
    }, renderValue(childrenProps));
    return /*#__PURE__*/React.createElement(InputBox, {
      __overrideStyles: this.props.__overrideStyles,
      label: renderLabel(childrenProps),
      rightContent: this.renderSideContent('right'),
      leftContent: this.renderSideContent('left'),
      hintBlock: hintBlock,
      inputIcon: this.renderArrow(),
      error: error,
      expandable: expandable,
      filled: !empty,
      focused: focused,
      tabIndex: disabled ? null : tabIndex,
      readOnly: readOnly,
      disabled: disabled,
      required: required,
      cleanable: cleanable && !empty,
      flatCorners: flatCorners,
      size: size,
      ref: this.controlRef,
      onBlur: this.handleControlBlur,
      onFocus: this.handleControlFocus,
      onClick: this.handleToggleClick,
      onMouseDown: this.handleControlMouseDown,
      onClean: this.handleClean,
      labelId: this.labelId,
      dataQaType: `${dataQaType}.wrapper`
    }, !expandable ? /*#__PURE__*/React.createElement(ScrollBlock, {
      ref: this.scrollBlockRef,
      noScroll: !focused
    }, content) : content);
  }

  renderControl() {
    const {
      selectedOption
    } = this.state;
    const editable = this.canBeFiltered();
    const empty = isEmpty(selectedOption);

    const childrenProps = _extends({}, this.props, this.state, {
      editable,
      empty
    });

    if (this.state.selectedOption.controlComponent) {
      return this.renderSelectedOptionControl(selectedOption);
    }

    if (editable) {
      return this.renderFilterControl(childrenProps);
    }

    return this.renderDefaultControl(childrenProps);
  }

  render() {
    const {
      disabled,
      error,
      expandable,
      readOnly,
      listHeight,
      closeOnSelect,
      value,
      defaultOptionProps,
      highlightedOption,
      dataQaData,
      dataQaType,
      ariaErrorMessage,
      ariaDescribedBy,
      options,
      focused,
      loading,
      size,
      dropdownMinWidth,
      dropdownZIndex,
      defaultOption,
      cobrowsingSecure,
      smartDirection,
      noResultsContent
    } = this.props;
    const {
      dropdownId,
      labelId
    } = this;
    const {
      opened,
      styles
    } = this.state;
    const filteredOptions = this.getFilteredOptions();
    const noResults = filteredOptions && !filteredOptions.length && options && !options.length && !defaultOption;
    return /*#__PURE__*/React.createElement("div", {
      className: cn(styles.root, {
        [styles.root_focused]: focused,
        [styles.root_opened]: opened && !disabled && !readOnly,
        [styles.root_disabled]: disabled,
        [styles.root_expandable]: expandable,
        [styles[`root_size_${size}`]]: size
      }),
      ref: this.rootRef,
      "data-qa-data": typeof dataQaData === 'object' ? JSON.stringify(dataQaData) : dataQaData,
      "data-qa-type": dataQaType,
      role: "combobox",
      "aria-disabled": disabled,
      "aria-invalid": error,
      "aria-readonly": readOnly,
      "aria-expanded": opened,
      "aria-controls": dropdownId,
      "aria-labelledby": labelId,
      "aria-errormessage": ariaErrorMessage,
      "aria-describedby": ariaDescribedBy
    }, /*#__PURE__*/React.createElement("div", {
      className: cn({
        [styles.selectWrapper]: true,
        [styles.selectWrapper_expandable]: expandable
      })
    }, /*#__PURE__*/React.createElement(Dropdown, {
      __overrideStyles: this.props.__overrideStyles,
      cobrowsingSecure: cobrowsingSecure,
      id: dropdownId,
      highlightedOption: highlightedOption,
      listHeight: listHeight,
      loading: loading,
      opened: opened,
      options: this.enrichOptions(filteredOptions, value, defaultOptionProps),
      closeOnSelect: closeOnSelect,
      onOptionSelect: this.handleOptionSelect,
      onClose: this.handleClose,
      onKeyDown: readOnly ? undefined : this.handleKeyDown,
      noResults: noResults,
      noResultsContent: noResultsContent,
      listMinWidth: dropdownMinWidth,
      listZIndex: dropdownZIndex,
      dataQaType: `${dataQaType}.dropdown`,
      smartDirection: smartDirection
    }, this.renderControl())));
  }

}

Select.defaultProps = {
  name: null,
  value: null,
  label: null,
  placeholder: null,
  hintBlock: null,
  tabIndex: 0,
  error: false,
  expandable: false,
  focused: false,
  disabled: false,
  readOnly: false,
  opened: false,
  required: false,
  cleanable: false,
  loading: false,
  closeOnSelect: true,
  flatCorners: '',
  listHeight: Dropdown.defaultProps.maxHeight,
  selectedItemInfo: ['leftContent', 'rightContent'],
  size: 'l',
  searchThreshold: 9,
  filterFunc: filterOption,
  transformOptions: filterOptions,
  dropdownMinWidth: null,
  onBlur: noop,
  onFocus: noop,
  onChange: noop,
  onFilterChange: noop,
  onFieldDone: noop,
  onKeyDown: noop,
  onOpen: noop,
  onClose: noop,
  onClean: noop,
  defaultOptionProps: {
    checkboxed: true
  },
  emptyOptionProps: {},
  renderLabel: ({
    label,
    selectedOption
  }) => selectedOption.label || label,
  renderValue: ({
    extractTextValue,
    selectedOption,
    dataQaType,
    cobrowsingSecure,
    styles
  }) => /*#__PURE__*/React.createElement("div", {
    className: styles.value,
    "data-qa-type": `${dataQaType}.value`,
    "data-cobrowsing-secure": cobrowsingSecure ? 'text' : null
  }, extractTextValue(selectedOption)),
  renderFilter: filterProps => /*#__PURE__*/React.createElement(InlineInput, Object.assign({
    minWidth: 40
  }, filterProps)),
  extractTextValue: option => !isNil(option) ? option.title : null,
  dataQaType: 'uikit/select',
  ariaErrorMessage: null,
  ariaDescribedBy: null,
  autoComplete: false,
  arrowAriaLabelOpened: 'Закрыть',
  arrowAriaLabelClosed: 'Открыть',
  cobrowsingSecure: false,
  minDropdownShowLength: 0,
  focusOnClean: true
};
process.env.NODE_ENV !== "production" ? Select.propTypes = {
  /**
   * Атрибут data-qa-data
   */
  dataQaData: pt.oneOfType([pt.string, pt.array, pt.object, pt.number]),

  /**
   * Атрибут `data-qa-type`
   */
  dataQaType: pt.string,

  /**
   * Атрибут `name`
   */
  name: pt.string,

  /**
   * Текущее значение селекта
   */
  value: pt.oneOfType([pt.string, pt.number]),

  /**
   * Набор опций селекта
   */
  options: pt.arrayOf(pt.object).isRequired,

  /**
   * Опция по умолчанию
   */
  defaultOption: pt.object,

  /**
   * Лейбл
   */
  label: pt.node,

  /**
   * Плейсхолдер (показывается под лейблом когда селект открыт и ничего не выбрано)
   */
  placeholder: pt.node,

  /**
   * `html`-атрибут `tabindex`
   */
  tabIndex: pt.number,

  /**
   * Задизейбленное состояние
   */
  disabled: pt.bool,

  /**
   * Только для чтения
   */
  readOnly: pt.bool,

  /**
   * Открытое состояние
   */
  opened: pt.bool,

  /**
   * Фокусное состояние
   */
  focused: pt.bool,

  /**
   * Состояние ошибки
   */
  error: pt.bool,

  /**
   * Флаг динимаческой высоты
   */
  expandable: pt.bool,

  /**
   * Обязательное поле
   */
  required: pt.bool,

  /**
   * Отображать ли крестик для очистки
   */
  cleanable: pt.bool,

  /**
   * Максимальная высота выпадающего списка в px
   */
  listHeight: pt.oneOfType([pt.string, pt.number]),

  /**
   * Спрямление уголков
   */
  flatCorners: pt.string,

  /**
   * Блок с подсказкой
   */
  hintBlock: pt.node,

  /**
   * Общие пропы для всех итемов
   */
  defaultOptionProps: pt.object,

  /**
   * Пропсы для пустого итема - отображаются когда селект в невыбранном состоянии
   */
  emptyOptionProps: pt.shape({
    rightContent: pt.node,
    leftContent: pt.node
  }),

  /**
   * Должен ли селект закрываться после выбора нового значения
   */
  closeOnSelect: pt.bool,

  /**
   * Рендерит лейбл селекта
   */
  renderLabel: pt.func,

  /**
   * Рендерит текущее выбранное значение
   */
  renderValue: pt.func,

  /**
   * Обработчик изменения значения селекта
   */
  onChange: pt.func,

  /**
   * Обработчик выбора опции
   */
  onOptionSelect: pt.func,

  /**
   * Обработчик изменения фильтра в селекте
   */
  onFilterChange: pt.func,

  /**
   * Обработчик фокуса
   */
  onFocus: pt.func,

  /**
   * Обработчик потери фокуса
   */
  onBlur: pt.func,

  /**
   * Обработчик завершения редактирования поля
   */
  onFieldDone: pt.func,

  /**
   * Обработчик открытия селекта
   */
  onOpen: pt.func,

  /**
   * Обработчик нажатия клавиш
   */
  onKeyDown: pt.func,

  /**
   * Обработчик клика на крестик
   */
  onClean: pt.func,

  /**
   * Обработчик закрытия селекта
   */
  onClose: pt.func,

  /**
   *
   */
  highlightedOption: pt.oneOfType([pt.object, pt.string]),

  /**
   * Позволяет отображать указанные параметры выбранного элемента в поле
   */
  selectedItemInfo: pt.oneOfType([pt.bool, pt.arrayOf(pt.string)]),

  /**
   * Id элемента с ошибкой
   */
  ariaErrorMessage: pt.string,

  /**
   * Id с описанием элемента
   */
  ariaDescribedBy: pt.string,

  /**
   * Минимальное количество элементов, при котором появляется возможность фильтрации значений
   */
  searchThreshold: pt.number,

  /**
   * Функция фильтрации элементов в списке подсказок
   *
   * @param {string|object} option Текущий проверяемый элемент массива подсказок
   * @param {string} normalisedQuery Введенное в инпут значение (нормализованное)
   * @param {string} query Введенное в инпут значение (до нормализации)
   * @param {bool} highlightMatch Флаг, индицирующий, нужно ли выделять совпадающую часть
   * @return {bool|object} false - не совпадает, true - совпадает, Object - если опцию нужно модифицировать (добавить выделение текста)
   */
  filterFunc: pt.func,

  /**
   * Функция для преобразования массива опций на основе текущего значения поля. (sic!) Заменяет стандартную функцию фильтрации опций
   *
   * @param {array} options Массив из пропа suggestions
   * @param {string} query  Текущее значение поля
   * @param {func} filterFunc Функция-фильтрации 1 опции из пропа `filterFunc`
   * @param {bool} highlightMatch Флаг, индицирующий, нужно ли выделять совпадающую часть (если не используется дефолтный filterFunc, то реализровать самому)
   * @return {array}
   */
  transformOptions: pt.func,

  /**
   * Функция, возвращающая текстовое значение опции для заполнения инпута
   */
  extractTextValue: pt.func,

  /**
   * Размер инпута (default: l)
   * Доступные размеры: [l - 56px, m - 44px, s - 32px]
   */
  size: pt.oneOf(['l', 'm', 's']),

  /**
   * Добавляет loading в dropdown
   */
  loading: pt.bool,

  /**
   * Минимальная ширина выпадающего списка
   */
  dropdownMinWidth: pt.oneOfType([pt.string, pt.number]),

  /**
   * z-index выпадающего списка
   */
  dropdownZIndex: pt.number,

  /**
   * Включает autoComplete у нативномого инпута
   */
  autoComplete: pt.oneOfType([pt.bool, pt.string]),

  /**
   * Включает необходимые атрибуты для cobrowsing
   */
  cobrowsingSecure: pt.bool,

  /**
   * Минимальная длина значения, при котором будет открыт список подсказок
   */
  minDropdownShowLength: pt.number,

  /**
   * Содержимое айтема для состояния "Нет результатов"
   */
  noResultsContent: pt.node,

  /**
   * Флаг для умного выбора позиции выпадающего списка
   */
  smartDirection: pt.bool,

  /**
   * aria-label для элемента стрелки в открытом состоянии
   */
  arrowAriaLabelOpened: pt.string,

  /**
   * aria-label для элемента стрелки в закрытом состоянии
   */
  arrowAriaLabelClosed: pt.string,

  /**
   * фокус после очистки поля
   */
  focusOnClean: pt.bool
} : void 0;
export default Select;
