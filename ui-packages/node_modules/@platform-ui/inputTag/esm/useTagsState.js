import _extends from "@babel/runtime/helpers/extends";
import React from 'react';
import useTags from './useTags';

function relatedTargetOutside(container, event) {
  const focusEvent = event;
  return !container || !focusEvent.relatedTarget || !container.contains(focusEvent.relatedTarget);
}

function useTagsState(props) {
  const {
    name,
    value,
    disabled,
    readOnly,
    valueErrors,
    onChange,
    onFocus,
    onBlur,
    acceptTag,
    isEmptyTag,
    isEqualTags
  } = props;
  const [editing, setEditing] = React.useState(false);
  const [inputValue, setInputValue] = React.useState('');
  const [stateFocused, setStateFocused] = React.useState(false);
  const [focusedIndexState, setFocusedIndex] = React.useState(null);
  const focused = typeof props.focused === 'boolean' ? props.focused : stateFocused;
  const containerRef = React.useRef(null);
  const commonEventParams = name ? {
    name
  } : {};
  let focusedIndex = focusedIndexState;

  if (!focused) {
    focusedIndex = null;
  } else if (focusedIndex === null || focusedIndex >= value.length) {
    focusedIndex = 'input';
  }

  const {
    addTag,
    removeTag,
    replaceTag
  } = useTags(value, {
    empty: isEmptyTag,
    equals: isEqualTags
  });
  const context = {
    value,
    focused,
    disabled,
    readOnly,
    valueErrors,
    editing,
    setEditing,
    inputValue,
    setInputValue,
    focusedIndex,
    setFocusedIndex,
    onChange: (event, params) => {
      if (params.value !== value) {
        onChange(event, _extends({}, commonEventParams, params));
      }
    },
    onAdd: (event, params) => {
      if (!params.tag) {
        event.preventDefault();
      }

      setInputValue('');
      context.onChange(event, {
        value: addTag(params.tag)
      });
    },
    onRemove: (event, params) => {
      context.onChange(event, {
        value: removeTag(params.index)
      });
    },
    onReplace: (event, params) => {
      setEditing(false);
      setInputValue('');
      context.onChange(event, {
        value: replaceTag(params.index, params.tag)
      });
    },
    onFocus: event => {
      if (!focused && relatedTargetOutside(containerRef.current, event)) {
        setStateFocused(true);
        onFocus && onFocus(event, commonEventParams);
      }
    },
    onBlur: event => {
      if (focused && relatedTargetOutside(containerRef.current, event)) {
        setFocusedIndex(null);
        setStateFocused(false);
        setInputValue('');
        onBlur && onBlur(event, commonEventParams);
      }
    },
    container: {
      ref: containerRef,
      onMouseDown: event => {
        event.preventDefault();
        setFocusedIndex('input');
        setInputValue('');
        context.onFocus(event);
      }
    },
    acceptTag
  };
  return context;
}

export default useTagsState;