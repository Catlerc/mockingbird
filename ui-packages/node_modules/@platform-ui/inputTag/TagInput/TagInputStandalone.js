"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _inputTools = require("@platform-ui/inputTools");

function isFocused(element) {
  return document.activeElement === element;
}

var TagInputStandalone = /*#__PURE__*/_react.default.forwardRef(function (props, forwardedRef) {
  var value = props.value,
      focused = props.focused,
      onFocus = props.onFocus,
      onBlur = props.onBlur,
      onApply = props.onApply,
      onCancel = props.onCancel,
      onChange = props.onChange,
      onExitForward = props.onExitForward,
      onExitBackward = props.onExitBackward,
      onOptionPrev = props.onOptionPrev,
      onOptionNext = props.onOptionNext,
      disabled = props.disabled,
      readOnly = props.readOnly,
      dataQaType = props.dataQaType;

  var inputRef = _react.default.useRef(null);

  var handleKeyUp = function handleKeyUp(event) {
    var input = event.target;

    switch (event.key) {
      case 'Enter':
        {
          if (onApply) {
            event.preventDefault();
            onApply(event);
          }

          break;
        }

      case 'Escape':
        {
          if (onCancel) {
            onCancel(event);
          }

          break;
        }

      case 'ArrowLeft':
      case 'Backspace':
        {
          if (input.selectionStart === 0 && input.selectionEnd === 0 && onExitBackward) {
            onExitBackward(event);
          }

          break;
        }

      case 'ArrowRight':
        {
          var length = input.value.length;

          if (input.selectionStart === length && input.selectionEnd === length && onExitForward) {
            onExitForward(event);
          }

          break;
        }

      case 'ArrowUp':
        {
          if (onOptionPrev) {
            onOptionPrev(event);
          }

          break;
        }

      case 'ArrowDown':
        {
          if (onOptionNext) {
            onOptionNext(event);
          }

          break;
        }

      default:
        break;
    }
  };

  _react.default.useLayoutEffect(function () {
    var input = inputRef.current;

    if (!input) {
      return;
    }

    if (focused) {
      if (!isFocused(input)) {
        input.focus();
      }
    } else if (isFocused(input)) {
      input.blur();
    }
  }, [focused, inputRef]);

  var handleFocus = function handleFocus(event) {
    if (!focused && onFocus) {
      onFocus(event);
    }
  };

  var handleBlur = function handleBlur(event) {
    if (focused && onBlur) {
      onBlur(event);
    }
  };

  var handleChange = function handleChange(event) {
    onChange(event, {
      value: event.target.value
    });
  };

  return /*#__PURE__*/_react.default.createElement(_inputTools.InlineInput, {
    dataQaType: dataQaType,
    minWidth: 40,
    ref: inputRef,
    value: value,
    disabled: disabled,
    readOnly: readOnly,
    onBlur: handleBlur,
    onFocus: handleFocus,
    onChange: handleChange,
    onKeyDown: handleKeyUp
  });
});

var _default = /*#__PURE__*/_react.default.memo(TagInputStandalone);

exports.default = _default;