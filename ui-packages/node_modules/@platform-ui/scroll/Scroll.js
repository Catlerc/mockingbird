"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

exports.__esModule = true;
exports.default = exports.SCROLLBAR_VISIBILITY = void 0;

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _dataQa = _interopRequireDefault(require("@platform-ui/dataQa"));

var _deviceInfo = require("@platform-ui/device-info");

var _portal = require("@platform-ui/portal");

var _ScrollBar = _interopRequireDefault(require("./ScrollBar"));

var _OffsetWrapper = _interopRequireDefault(require("./OffsetWrapper"));

var _ScrollContent = require("./ScrollContent");

var _utils = require("./utils");

var _ScrollModule = _interopRequireDefault(require("./Scroll.module.css"));

var BAR_OFFSET = 15;
var MIN_BAR_HEIGHT = 17;
var FADE_TIMEOUT = 300;
var touchMoveOptions = {
  passive: false
};
/* eslint-disable no-param-reassign */

var setTransform = function setTransform(_ref) {
  var el = _ref.el,
      v = _ref.v,
      offset = _ref.offset;
  var value = "translate" + v + "(" + offset + "px)";
  el.style.transform = value;
  el.style['MozTransform'] = value;
  el.style['OTransform'] = value;
  el.style['MsTransform'] = value;
  el.style['WebkitTransform'] = value;
};
/* eslint-enable no-param-reassign */


var setBarMinHeight = function setBarMinHeight(barMinHeight) {
  return barMinHeight > MIN_BAR_HEIGHT ? barMinHeight : MIN_BAR_HEIGHT;
};

var SCROLLBAR_VISIBILITY = {
  ALWAYS: 'always',
  ONLY_ACTIVE: 'onlyActive',
  HIDDEN: 'hidden'
};
exports.SCROLLBAR_VISIBILITY = SCROLLBAR_VISIBILITY;

var Scroll = /*#__PURE__*/function (_PureComponent) {
  (0, _inheritsLoose2.default)(Scroll, _PureComponent);

  function Scroll(props) {
    var _this;

    _this = _PureComponent.call(this, props) || this;
    _this.content = void 0;
    _this.container = void 0;
    _this.verticalBar = void 0;
    _this.horizontalBar = void 0;
    _this.vTimeoutId = void 0;
    _this.hTimeoutId = void 0;
    _this.scrollingId = void 0;
    _this.startOffset = void 0;
    _this.isUnmounting = void 0;
    _this.resizeObserver = void 0;
    _this.direction = void 0;
    _this.deviceType = (0, _deviceInfo.getDeviceType)();
    _this.barMinHeight = setBarMinHeight(_this.props.barMinHeight);
    _this.horizontalProportion = 1;
    _this.verticalProportion = 1;
    _this.currentY = 0;
    _this.horizontalOffset = 0;
    _this.verticalOffset = 0;

    _this.getScrollBarVisibility = function (direction) {
      switch (_this.props.scrollbarVisibility) {
        case SCROLLBAR_VISIBILITY.ONLY_ACTIVE:
          return _this.state.hovered || _this.state.scrolling || (direction === 'vertical' ? _this.state.isVScrolling || _this.state.isVDragging : _this.state.isHScrolling || _this.state.isHDragging);

        case SCROLLBAR_VISIBILITY.HIDDEN:
          return false;

        default:
          return true;
      }
    };

    _this.setRef = function (ref) {
      return function (element) {
        _this[ref] = element;
      };
    };

    _this.contentRef = function (node) {
      _this.props.setContainer == null ? void 0 : _this.props.setContainer(node);
      _this.content = node;
    };

    _this.setCurrentY = function (event) {
      _this.currentY = event.touches[0].clientY;
    };

    _this.stopOuterScrollDecorator = function (event) {
      (0, _utils.stopOuterScroll)(event, _this.currentY);
    };

    _this.setListeners = function () {
      if (_this.content) {
        _this.content.addEventListener('wheel', _this.stopOuterScrollDecorator);

        _this.content.addEventListener('touchstart', _this.setCurrentY);

        _this.content.addEventListener('touchmove', _this.stopOuterScrollDecorator, touchMoveOptions);
      }
    };

    _this.removeListeners = function () {
      if (_this.content) {
        _this.content.removeEventListener('wheel', _this.stopOuterScrollDecorator);

        _this.content.removeEventListener('touchstart', _this.setCurrentY);

        _this.content.removeEventListener('touchmove', _this.stopOuterScrollDecorator, touchMoveOptions);
      }
    };

    _this.onDragStart = function () {
      if (!_this.content) {
        return;
      }

      switch (_this.direction) {
        case 'horizontal':
          _this.startOffset = _this.content.scrollLeft * _this.horizontalProportion;
          break;

        case 'vertical':
          _this.startOffset = _this.content.scrollTop * _this.verticalProportion;
          break;
      }
    };

    _this.onDragProcess = function (current, prev, start) {
      if (!_this.content) {
        return;
      }

      switch (_this.direction) {
        case 'horizontal':
          _this.content.scrollLeft = ((_this.startOffset || 0) + current.x - start.x) / _this.horizontalProportion;
          break;

        case 'vertical':
          _this.content.scrollTop = ((_this.startOffset || 0) + current.y - start.y) / _this.verticalProportion;
          break;
      }
    };

    _this.onDragEnd = function () {
      _this.direction = undefined;

      _this.setDraggingDirection();
    };

    _this.handleScroll = function (event) {
      var _this$props = _this.props,
          verticalBarRef = _this$props.verticalBarRef,
          horizontalBarRef = _this$props.horizontalBarRef,
          contentInnerOffsetTop = _this$props.contentInnerOffsetTop,
          contentInnerOffsetBottom = _this$props.contentInnerOffsetBottom,
          onScroll = _this$props.onScroll,
          barMaxHeight = _this$props.barMaxHeight;

      if (!_this.content || !_this.container) {
        return;
      }

      var _this$content = _this.content,
          scrollTop = _this$content.scrollTop,
          scrollLeft = _this$content.scrollLeft,
          scrollWidth = _this$content.scrollWidth,
          scrollHeight = _this$content.scrollHeight,
          clientWidth = _this$content.clientWidth,
          clientHeight = _this$content.clientHeight;
      var verticalBar = verticalBarRef || _this.verticalBar;
      var horizontalBar = horizontalBarRef || _this.horizontalBar;
      _this.horizontalOffset = scrollLeft * _this.horizontalProportion;
      var verticalBarProportion = verticalBar && verticalBar.parentElement ? verticalBar.parentElement.clientHeight / clientHeight : 1;
      var horizontalBarProportion = horizontalBar && horizontalBar.parentElement ? horizontalBar.parentElement.clientWidth / clientWidth : 1;
      var offsetScaleRatio = (clientHeight + contentInnerOffsetTop + contentInnerOffsetBottom) / clientHeight;
      var baseVerticalSize = (clientHeight / scrollHeight * _this.container.clientHeight - BAR_OFFSET * +(_this.horizontalProportion < 1)) * verticalBarProportion;
      var scrollPosition = scrollTop * _this.verticalProportion * offsetScaleRatio * verticalBarProportion;
      var verticalSize = baseVerticalSize;

      if (_this.barMinHeight) {
        verticalSize = Math.max(baseVerticalSize, _this.barMinHeight);
      }

      if (barMaxHeight) {
        verticalSize = Math.min(verticalSize, barMaxHeight);
      }

      if (verticalSize !== baseVerticalSize) {
        var diffHeight = -verticalSize + baseVerticalSize;
        var scrollPositionToAvailableScrollRatio = scrollTop / (scrollHeight - _this.container.clientHeight);
        _this.verticalOffset = scrollPosition + diffHeight * scrollPositionToAvailableScrollRatio;
      } else {
        _this.verticalOffset = scrollPosition;
      }

      if (_this.horizontalOffset !== _this.state.horizontalOffset && horizontalBar) {
        _this.setState({
          isHScrolling: true,
          horizontalOffset: _this.horizontalOffset
        }, _this.onStateUpdate);

        _this.setScrollingTimeout('horizontal');

        setTransform({
          el: horizontalBar,
          v: 'X',
          offset: _this.horizontalOffset
        });
      }

      if (_this.verticalOffset !== _this.state.verticalOffset && verticalBar) {
        _this.setState({
          isVScrolling: true,
          verticalOffset: _this.verticalOffset
        }, _this.onStateUpdate);

        _this.setScrollingTimeout('vertical');

        setTransform({
          el: verticalBar,
          v: 'Y',
          offset: _this.verticalOffset
        });
      }

      var horizontalSize = (clientWidth / scrollWidth * _this.container.clientWidth - BAR_OFFSET * +(_this.verticalProportion < 1)) * horizontalBarProportion;

      _this.setState({
        // при большом кол-ве эл-тов каретка может стать слишком маленькой,
        // поэтому у нее есть минимальный размер (PFP-548)
        horizontalSize: Math.max(horizontalSize, _this.barMinHeight),
        verticalSize: verticalSize,
        horizontalShow: _this.horizontalProportion < 1,
        verticalShow: _this.verticalProportion < 1
      }, _this.onStateUpdate);

      onScroll == null ? void 0 : onScroll(event, {
        scrollTop: scrollTop,
        scrollLeft: scrollLeft,
        scrollWidth: scrollWidth,
        scrollHeight: scrollHeight,
        clientWidth: clientWidth,
        clientHeight: clientHeight
      });
    };

    _this.handleMouseOver = function () {
      if (!_this.state.hovered) {
        _this.setState({
          hovered: true
        });
      }
    };

    _this.handleMouseLeave = function () {
      if (_this.state.hovered) {
        _this.setState({
          hovered: false
        });
      }
    };

    _this.handleMouseDown = function (event, direction) {
      _this.direction = direction;

      _this.setDraggingDirection();
    };

    _this.handleWheel = function () {
      if (!_this.state.scrolling) {
        _this.setState({
          scrolling: true
        });
      }

      clearTimeout(_this.scrollingId);
      _this.scrollingId = window.setTimeout(function () {
        _this.setState({
          scrolling: false
        });
      }, FADE_TIMEOUT);
    };

    _this.handleNativeContainerScroll = function (event) {
      var _event$currentTarget = event.currentTarget,
          scrollTop = _event$currentTarget.scrollTop,
          scrollLeft = _event$currentTarget.scrollLeft,
          scrollWidth = _event$currentTarget.scrollWidth,
          scrollHeight = _event$currentTarget.scrollHeight,
          clientWidth = _event$currentTarget.clientWidth,
          clientHeight = _event$currentTarget.clientHeight;
      _this.props.onScroll == null ? void 0 : _this.props.onScroll(event, {
        scrollTop: scrollTop,
        scrollLeft: scrollLeft,
        scrollWidth: scrollWidth,
        scrollHeight: scrollHeight,
        clientWidth: clientWidth,
        clientHeight: clientHeight
      });
    };

    _this.renderScrollBar = function (direction) {
      return _this.state[direction + "Show"] && /*#__PURE__*/_react.default.createElement(_ScrollBar.default, {
        direction: direction,
        visible: _this.getScrollBarVisibility(direction),
        dragging: _this.state[direction === 'vertical' ? 'isVDragging' : 'isHDragging'],
        size: _this.state[direction + "Size"],
        theme: _this.props.theme,
        barRef: _this.setRef(direction + "Bar"),
        onMouseDown: _this.handleMouseDown,
        handleDragStart: _this.onDragStart,
        handleDragProcess: _this.onDragProcess,
        handleDragEnd: _this.onDragEnd
      });
    };

    _this.state = {
      horizontalShow: false,
      horizontalSize: 0,
      hovered: false,
      isVScrolling: false,
      mounted: false,
      verticalOffset: 0,
      verticalShow: false,
      verticalSize: 0
    };
    props.getUpdateFunc == null ? void 0 : props.getUpdateFunc(_this.updateWithProportions);
    props.getMouseDownFunc == null ? void 0 : props.getMouseDownFunc(_this.handleMouseDown);
    props.getDragStartFunc == null ? void 0 : props.getDragStartFunc(_this.onDragStart);
    props.getDragProcessFunc == null ? void 0 : props.getDragProcessFunc(_this.onDragProcess);
    props.getDragEndFunc == null ? void 0 : props.getDragEndFunc(_this.onDragEnd);
    return _this;
  }

  var _proto = Scroll.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    this.updateWithProportions();
    this.setState({
      mounted: true
    }, function () {
      var _this2$content;

      if (_this2.props.preventOuterScroll) {
        _this2.setListeners();
      }

      if (typeof ResizeObserver !== 'undefined' && _this2.container && (_this2$content = _this2.content) != null && _this2$content.firstChild) {
        _this2.resizeObserver = new ResizeObserver(function () {
          _this2.updateWithProportions();
        });

        _this2.resizeObserver.observe(_this2.container);

        _this2.resizeObserver.observe(_this2.content.firstChild);
      }
    });
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.barMinHeight !== this.props.barMinHeight) {
      this.barMinHeight = setBarMinHeight(this.props.barMinHeight);
    }

    if (this.props.preventOuterScroll && !prevProps.preventOuterScroll) {
      this.setListeners();
    } else if (!this.props.preventOuterScroll && prevProps.preventOuterScroll) {
      this.removeListeners();
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.isUnmounting = true;

    if (this.props.preventOuterScroll) {
      this.removeListeners();
    }

    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
  };

  _proto.onStateUpdate = function onStateUpdate() {
    var _this$props$onUpdate, _this$props2;

    var _this$state = this.state,
        verticalSize = _this$state.verticalSize,
        horizontalSize = _this$state.horizontalSize,
        verticalShow = _this$state.verticalShow,
        horizontalShow = _this$state.horizontalShow,
        isVScrolling = _this$state.isVScrolling,
        isHScrolling = _this$state.isHScrolling,
        isVDragging = _this$state.isVDragging,
        isHDragging = _this$state.isHDragging;
    (_this$props$onUpdate = (_this$props2 = this.props).onUpdate) == null ? void 0 : _this$props$onUpdate.call(_this$props2, {
      verticalSize: verticalSize,
      horizontalSize: horizontalSize,
      verticalShow: verticalShow,
      horizontalShow: horizontalShow,
      isVScrolling: isVScrolling,
      isHScrolling: isHScrolling,
      isVDragging: isVDragging,
      isHDragging: isHDragging
    });
  };

  _proto.setScrollingTimeout = function setScrollingTimeout(direction) {
    var _this3 = this;

    var isVertical = direction === 'vertical';
    var timeoutId = isVertical ? 'vTimeoutId' : 'hTimeoutId';
    clearTimeout(this[timeoutId]);
    this[timeoutId] = window.setTimeout(function () {
      if (!_this3.isUnmounting) {
        var _this3$setState;

        _this3.setState((_this3$setState = {}, _this3$setState[isVertical ? 'isVScrolling' : 'isHScrolling'] = false, _this3$setState), _this3.onStateUpdate);
      }
    }, FADE_TIMEOUT);
  };

  _proto.updateWithProportions = function updateWithProportions(props, prevProps) {
    var _this4 = this;

    var _ref2 = props || this.props,
        scrollTop = _ref2.scrollTop,
        scrollLeft = _ref2.scrollLeft;

    var _ref3 = prevProps || {},
        prevScrollTop = _ref3.scrollTop,
        prevScrollLeft = _ref3.scrollLeft;

    requestAnimationFrame(function () {
      if (!_this4.content) {
        return;
      } // Плюс 20 пикселей, потому что после рендера будет добавлено padding-right: 20px,
      // что сделает посчитанные пропорции неактуальными


      _this4.horizontalProportion = (_this4.content.clientWidth + _utils.SCROLLBAR_OFFSET) / _this4.content.scrollWidth;
      _this4.verticalProportion = _this4.content.clientHeight / _this4.content.scrollHeight;

      if (scrollTop && scrollTop !== prevScrollTop) {
        _this4.content.scrollTop = scrollTop;
      }

      if (scrollLeft && scrollLeft !== prevScrollLeft) {
        _this4.content.scrollLeft = scrollLeft;
      }

      _this4.handleScroll();
    });
  };

  _proto.setDraggingDirection = function setDraggingDirection() {
    this.setState({
      isHDragging: /horizontal/.test(this.direction || ''),
      isVDragging: /vertical/.test(this.direction || '')
    }, this.onStateUpdate);
  };

  _proto.renderContent = function renderContent() {
    var _this$props3 = this.props,
        dataQaType = _this$props3.dataQaType,
        id = _this$props3.id,
        children = _this$props3.children,
        contentInnerOffsetTop = _this$props3.contentInnerOffsetTop,
        contentInnerOffsetBottom = _this$props3.contentInnerOffsetBottom,
        disabled = _this$props3.disabled;
    return /*#__PURE__*/_react.default.createElement(_OffsetWrapper.default, {
      offsetBottom: contentInnerOffsetBottom,
      offsetTop: contentInnerOffsetTop
    }, /*#__PURE__*/_react.default.createElement(_ScrollContent.ScrollContent, {
      dataQaType: dataQaType,
      scrollY: !disabled && this.verticalProportion < 1,
      scrollX: !disabled && this.horizontalProportion < 1,
      ref: this.contentRef,
      onScroll: this.handleScroll,
      id: id,
      onWheel: this.handleWheel
    }, /*#__PURE__*/_react.default.createElement(_portal.PortalWrapper, null, children)));
  };

  _proto.renderNativeContainer = function renderNativeContainer() {
    var _cn;

    var _this$props4 = this.props,
        id = _this$props4.id,
        contentInnerOffsetTop = _this$props4.contentInnerOffsetTop,
        contentInnerOffsetBottom = _this$props4.contentInnerOffsetBottom,
        children = _this$props4.children;
    var mounted = this.state.mounted;
    return /*#__PURE__*/_react.default.createElement("div", Object.assign({}, (0, _dataQa.default)(this.props), {
      ref: this.setRef('container'),
      style: {
        width: '100%',
        height: '100%'
      }
    }), /*#__PURE__*/_react.default.createElement(_OffsetWrapper.default, {
      offsetBottom: contentInnerOffsetBottom,
      offsetTop: contentInnerOffsetTop
    }, /*#__PURE__*/_react.default.createElement("div", {
      id: id,
      ref: this.contentRef,
      onMouseOver: this.handleMouseOver,
      onMouseLeave: this.handleMouseLeave,
      className: (0, _classnames.default)((_cn = {}, _cn[_ScrollModule.default.nativeScrollContainer] = true, _cn[_ScrollModule.default.nativeScrollContainer_hidden] = !mounted, _cn)),
      onScroll: this.handleNativeContainerScroll,
      onWheel: this.handleWheel
    }, /*#__PURE__*/_react.default.createElement(_portal.PortalWrapper, null, children))));
  };

  _proto.render = function render() {
    var _cn2;

    var mounted = this.state.mounted; // на сервере и на клиенте в мобилах рисуем нативный скролл

    return !mounted || (this.deviceType === 'tablet' || this.deviceType === 'mobile') && !this.props.fallback ? this.renderNativeContainer() : /*#__PURE__*/_react.default.createElement("div", Object.assign({}, (0, _dataQa.default)(this.props), {
      ref: this.setRef('container'),
      className: (0, _classnames.default)((_cn2 = {}, _cn2[_ScrollModule.default.scroll] = true, _cn2[_ScrollModule.default.scroll_preventStackContext] = this.props.preventStackContext, _cn2)),
      onMouseOver: this.handleMouseOver,
      onMouseLeave: this.handleMouseLeave
    }), this.renderContent(), this.renderScrollBar('horizontal'), this.renderScrollBar('vertical'));
  };

  return Scroll;
}(_react.PureComponent);

Scroll.defaultProps = {
  theme: 'default',
  preventOuterScroll: false,
  scrollbarVisibility: SCROLLBAR_VISIBILITY.ONLY_ACTIVE,
  fallback: false,
  preventStackContext: false,
  dataQaType: 'uikit/scroll',
  contentInnerOffsetBottom: 0,
  contentInnerOffsetTop: 0,
  barMinHeight: 0
};
var _default = Scroll;
exports.default = _default;