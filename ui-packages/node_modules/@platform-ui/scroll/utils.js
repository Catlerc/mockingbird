"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

exports.__esModule = true;
exports.windowStyles = exports.stopOuterScroll = exports.SCROLLBAR_OFFSET = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _number = _interopRequireDefault(require("@tinkoff/utils/is/number"));

var stopOuterScroll = function stopOuterScroll(event, startY) {
  if (startY === void 0) {
    startY = 0;
  }

  var _ref = event,
      target = _ref.currentTarget; // eslint-disable-next-line compat/compat

  var touches = window.TouchEvent && event instanceof TouchEvent ? event.touches : undefined;
  var deltaY = event instanceof WheelEvent ? event.deltaY : 0;

  if (touches) {
    var currentY = touches[0].clientY;
    deltaY = startY - currentY;
  } // если происходит скролл на величину большую расстояния на границы блока,
  // то явно скроллим к границе, чтобы предотвратить скролл внешнего контейнера


  if (deltaY < 0) {
    if (target.scrollTop < -deltaY) {
      target.scrollTop = 0;
      event.preventDefault();
    }
  } else {
    var maxScroll = target.scrollHeight - target.offsetHeight;

    if (maxScroll - target.scrollTop < deltaY) {
      target.scrollTop = maxScroll;
      event.preventDefault();
    }
  }
}; // на маке scrollbarWidth = 0, но чтобы визуально скрыть скроллбар нужен дополнительный отступ


exports.stopOuterScroll = stopOuterScroll;
var SCROLLBAR_OFFSET = 20;
exports.SCROLLBAR_OFFSET = SCROLLBAR_OFFSET;

var windowStyles = function windowStyles(vertical, horizontal, scrollbarWidth) {
  return (0, _number.default)(scrollbarWidth) ? (0, _extends2.default)({}, vertical ? {
    width: "calc(100% + " + scrollbarWidth + "px)",
    paddingRight: SCROLLBAR_OFFSET,
    marginRight: -scrollbarWidth
  } : {}, horizontal ? {
    height: "calc(100% + " + scrollbarWidth + "px)",
    paddingBottom: SCROLLBAR_OFFSET,
    marginBottom: -scrollbarWidth
  } : {}) : undefined;
};

exports.windowStyles = windowStyles;