import React, { PureComponent } from 'react';
import cn from 'classnames';
import dataQa from '@platform-ui/dataQa';
import { getDeviceType } from '@platform-ui/device-info';
import { PortalWrapper } from '@platform-ui/portal';
import ScrollBar from './ScrollBar';
import OffsetWrapper from './OffsetWrapper';
import { ScrollContent } from './ScrollContent';
import { stopOuterScroll, SCROLLBAR_OFFSET } from './utils';
import styles from './Scroll.module.css';
const BAR_OFFSET = 15;
const MIN_BAR_HEIGHT = 17;
const FADE_TIMEOUT = 300;
const touchMoveOptions = {
  passive: false
};
/* eslint-disable no-param-reassign */

const setTransform = ({
  el,
  v,
  offset
}) => {
  const value = `translate${v}(${offset}px)`;
  el.style.transform = value;
  el.style['MozTransform'] = value;
  el.style['OTransform'] = value;
  el.style['MsTransform'] = value;
  el.style['WebkitTransform'] = value;
};
/* eslint-enable no-param-reassign */


const setBarMinHeight = barMinHeight => barMinHeight > MIN_BAR_HEIGHT ? barMinHeight : MIN_BAR_HEIGHT;

export const SCROLLBAR_VISIBILITY = {
  ALWAYS: 'always',
  ONLY_ACTIVE: 'onlyActive',
  HIDDEN: 'hidden'
};

class Scroll extends PureComponent {
  constructor(props) {
    super(props);
    this.content = void 0;
    this.container = void 0;
    this.verticalBar = void 0;
    this.horizontalBar = void 0;
    this.vTimeoutId = void 0;
    this.hTimeoutId = void 0;
    this.scrollingId = void 0;
    this.startOffset = void 0;
    this.isUnmounting = void 0;
    this.resizeObserver = void 0;
    this.direction = void 0;
    this.deviceType = getDeviceType();
    this.barMinHeight = setBarMinHeight(this.props.barMinHeight);
    this.horizontalProportion = 1;
    this.verticalProportion = 1;
    this.currentY = 0;
    this.horizontalOffset = 0;
    this.verticalOffset = 0;

    this.getScrollBarVisibility = direction => {
      switch (this.props.scrollbarVisibility) {
        case SCROLLBAR_VISIBILITY.ONLY_ACTIVE:
          return this.state.hovered || this.state.scrolling || (direction === 'vertical' ? this.state.isVScrolling || this.state.isVDragging : this.state.isHScrolling || this.state.isHDragging);

        case SCROLLBAR_VISIBILITY.HIDDEN:
          return false;

        default:
          return true;
      }
    };

    this.setRef = ref => element => {
      this[ref] = element;
    };

    this.contentRef = node => {
      var _this$props$setContai, _this$props;

      (_this$props$setContai = (_this$props = this.props).setContainer) == null ? void 0 : _this$props$setContai.call(_this$props, node);
      this.content = node;
    };

    this.setCurrentY = event => {
      this.currentY = event.touches[0].clientY;
    };

    this.stopOuterScrollDecorator = event => {
      stopOuterScroll(event, this.currentY);
    };

    this.setListeners = () => {
      if (this.content) {
        this.content.addEventListener('wheel', this.stopOuterScrollDecorator);
        this.content.addEventListener('touchstart', this.setCurrentY);
        this.content.addEventListener('touchmove', this.stopOuterScrollDecorator, touchMoveOptions);
      }
    };

    this.removeListeners = () => {
      if (this.content) {
        this.content.removeEventListener('wheel', this.stopOuterScrollDecorator);
        this.content.removeEventListener('touchstart', this.setCurrentY);
        this.content.removeEventListener('touchmove', this.stopOuterScrollDecorator, touchMoveOptions);
      }
    };

    this.onDragStart = () => {
      if (!this.content) {
        return;
      }

      switch (this.direction) {
        case 'horizontal':
          this.startOffset = this.content.scrollLeft * this.horizontalProportion;
          break;

        case 'vertical':
          this.startOffset = this.content.scrollTop * this.verticalProportion;
          break;
      }
    };

    this.onDragProcess = (current, prev, start) => {
      if (!this.content) {
        return;
      }

      switch (this.direction) {
        case 'horizontal':
          this.content.scrollLeft = ((this.startOffset || 0) + current.x - start.x) / this.horizontalProportion;
          break;

        case 'vertical':
          this.content.scrollTop = ((this.startOffset || 0) + current.y - start.y) / this.verticalProportion;
          break;
      }
    };

    this.onDragEnd = () => {
      this.direction = undefined;
      this.setDraggingDirection();
    };

    this.handleScroll = event => {
      const {
        verticalBarRef,
        horizontalBarRef,
        contentInnerOffsetTop,
        contentInnerOffsetBottom,
        onScroll,
        barMaxHeight
      } = this.props;

      if (!this.content || !this.container) {
        return;
      }

      const {
        scrollTop,
        scrollLeft,
        scrollWidth,
        scrollHeight,
        clientWidth,
        clientHeight
      } = this.content;
      const verticalBar = verticalBarRef || this.verticalBar;
      const horizontalBar = horizontalBarRef || this.horizontalBar;
      this.horizontalOffset = scrollLeft * this.horizontalProportion;
      const verticalBarProportion = verticalBar && verticalBar.parentElement ? verticalBar.parentElement.clientHeight / clientHeight : 1;
      const horizontalBarProportion = horizontalBar && horizontalBar.parentElement ? horizontalBar.parentElement.clientWidth / clientWidth : 1;
      const offsetScaleRatio = (clientHeight + contentInnerOffsetTop + contentInnerOffsetBottom) / clientHeight;
      const baseVerticalSize = (clientHeight / scrollHeight * this.container.clientHeight - BAR_OFFSET * +(this.horizontalProportion < 1)) * verticalBarProportion;
      const scrollPosition = scrollTop * this.verticalProportion * offsetScaleRatio * verticalBarProportion;
      let verticalSize = baseVerticalSize;

      if (this.barMinHeight) {
        verticalSize = Math.max(baseVerticalSize, this.barMinHeight);
      }

      if (barMaxHeight) {
        verticalSize = Math.min(verticalSize, barMaxHeight);
      }

      if (verticalSize !== baseVerticalSize) {
        const diffHeight = -verticalSize + baseVerticalSize;
        const scrollPositionToAvailableScrollRatio = scrollTop / (scrollHeight - this.container.clientHeight);
        this.verticalOffset = scrollPosition + diffHeight * scrollPositionToAvailableScrollRatio;
      } else {
        this.verticalOffset = scrollPosition;
      }

      if (this.horizontalOffset !== this.state.horizontalOffset && horizontalBar) {
        this.setState({
          isHScrolling: true,
          horizontalOffset: this.horizontalOffset
        }, this.onStateUpdate);
        this.setScrollingTimeout('horizontal');
        setTransform({
          el: horizontalBar,
          v: 'X',
          offset: this.horizontalOffset
        });
      }

      if (this.verticalOffset !== this.state.verticalOffset && verticalBar) {
        this.setState({
          isVScrolling: true,
          verticalOffset: this.verticalOffset
        }, this.onStateUpdate);
        this.setScrollingTimeout('vertical');
        setTransform({
          el: verticalBar,
          v: 'Y',
          offset: this.verticalOffset
        });
      }

      const horizontalSize = (clientWidth / scrollWidth * this.container.clientWidth - BAR_OFFSET * +(this.verticalProportion < 1)) * horizontalBarProportion;
      this.setState({
        // при большом кол-ве эл-тов каретка может стать слишком маленькой,
        // поэтому у нее есть минимальный размер (PFP-548)
        horizontalSize: Math.max(horizontalSize, this.barMinHeight),
        verticalSize,
        horizontalShow: this.horizontalProportion < 1,
        verticalShow: this.verticalProportion < 1
      }, this.onStateUpdate);
      onScroll == null ? void 0 : onScroll(event, {
        scrollTop,
        scrollLeft,
        scrollWidth,
        scrollHeight,
        clientWidth,
        clientHeight
      });
    };

    this.handleMouseOver = () => {
      if (!this.state.hovered) {
        this.setState({
          hovered: true
        });
      }
    };

    this.handleMouseLeave = () => {
      if (this.state.hovered) {
        this.setState({
          hovered: false
        });
      }
    };

    this.handleMouseDown = (event, direction) => {
      this.direction = direction;
      this.setDraggingDirection();
    };

    this.handleWheel = () => {
      if (!this.state.scrolling) {
        this.setState({
          scrolling: true
        });
      }

      clearTimeout(this.scrollingId);
      this.scrollingId = window.setTimeout(() => {
        this.setState({
          scrolling: false
        });
      }, FADE_TIMEOUT);
    };

    this.handleNativeContainerScroll = event => {
      var _this$props$onScroll, _this$props2;

      const {
        scrollTop,
        scrollLeft,
        scrollWidth,
        scrollHeight,
        clientWidth,
        clientHeight
      } = event.currentTarget;
      (_this$props$onScroll = (_this$props2 = this.props).onScroll) == null ? void 0 : _this$props$onScroll.call(_this$props2, event, {
        scrollTop,
        scrollLeft,
        scrollWidth,
        scrollHeight,
        clientWidth,
        clientHeight
      });
    };

    this.renderScrollBar = direction => {
      return this.state[`${direction}Show`] && /*#__PURE__*/React.createElement(ScrollBar, {
        direction: direction,
        visible: this.getScrollBarVisibility(direction),
        dragging: this.state[direction === 'vertical' ? 'isVDragging' : 'isHDragging'],
        size: this.state[`${direction}Size`],
        theme: this.props.theme,
        barRef: this.setRef(`${direction}Bar`),
        onMouseDown: this.handleMouseDown,
        handleDragStart: this.onDragStart,
        handleDragProcess: this.onDragProcess,
        handleDragEnd: this.onDragEnd
      });
    };

    this.state = {
      horizontalShow: false,
      horizontalSize: 0,
      hovered: false,
      isVScrolling: false,
      mounted: false,
      verticalOffset: 0,
      verticalShow: false,
      verticalSize: 0
    };
    props.getUpdateFunc == null ? void 0 : props.getUpdateFunc(this.updateWithProportions);
    props.getMouseDownFunc == null ? void 0 : props.getMouseDownFunc(this.handleMouseDown);
    props.getDragStartFunc == null ? void 0 : props.getDragStartFunc(this.onDragStart);
    props.getDragProcessFunc == null ? void 0 : props.getDragProcessFunc(this.onDragProcess);
    props.getDragEndFunc == null ? void 0 : props.getDragEndFunc(this.onDragEnd);
  }

  componentDidMount() {
    this.updateWithProportions();
    this.setState({
      mounted: true
    }, () => {
      var _this$content;

      if (this.props.preventOuterScroll) {
        this.setListeners();
      }

      if (typeof ResizeObserver !== 'undefined' && this.container && (_this$content = this.content) != null && _this$content.firstChild) {
        this.resizeObserver = new ResizeObserver(() => {
          this.updateWithProportions();
        });
        this.resizeObserver.observe(this.container);
        this.resizeObserver.observe(this.content.firstChild);
      }
    });
  }

  componentDidUpdate(prevProps) {
    if (this.barMinHeight !== this.props.barMinHeight) {
      this.barMinHeight = setBarMinHeight(this.props.barMinHeight);
    }

    if (this.props.preventOuterScroll && !prevProps.preventOuterScroll) {
      this.setListeners();
    } else if (!this.props.preventOuterScroll && prevProps.preventOuterScroll) {
      this.removeListeners();
    }
  }

  componentWillUnmount() {
    this.isUnmounting = true;

    if (this.props.preventOuterScroll) {
      this.removeListeners();
    }

    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
  }

  onStateUpdate() {
    var _this$props$onUpdate, _this$props3;

    const {
      verticalSize,
      horizontalSize,
      verticalShow,
      horizontalShow,
      isVScrolling,
      isHScrolling,
      isVDragging,
      isHDragging
    } = this.state;
    (_this$props$onUpdate = (_this$props3 = this.props).onUpdate) == null ? void 0 : _this$props$onUpdate.call(_this$props3, {
      verticalSize,
      horizontalSize,
      verticalShow,
      horizontalShow,
      isVScrolling,
      isHScrolling,
      isVDragging,
      isHDragging
    });
  }

  setScrollingTimeout(direction) {
    const isVertical = direction === 'vertical';
    const timeoutId = isVertical ? 'vTimeoutId' : 'hTimeoutId';
    clearTimeout(this[timeoutId]);
    this[timeoutId] = window.setTimeout(() => {
      if (!this.isUnmounting) {
        this.setState({
          [isVertical ? 'isVScrolling' : 'isHScrolling']: false
        }, this.onStateUpdate);
      }
    }, FADE_TIMEOUT);
  }

  updateWithProportions(props, prevProps) {
    const {
      scrollTop,
      scrollLeft
    } = props || this.props;
    const {
      scrollTop: prevScrollTop,
      scrollLeft: prevScrollLeft
    } = prevProps || {};
    requestAnimationFrame(() => {
      if (!this.content) {
        return;
      } // Плюс 20 пикселей, потому что после рендера будет добавлено padding-right: 20px,
      // что сделает посчитанные пропорции неактуальными


      this.horizontalProportion = (this.content.clientWidth + SCROLLBAR_OFFSET) / this.content.scrollWidth;
      this.verticalProportion = this.content.clientHeight / this.content.scrollHeight;

      if (scrollTop && scrollTop !== prevScrollTop) {
        this.content.scrollTop = scrollTop;
      }

      if (scrollLeft && scrollLeft !== prevScrollLeft) {
        this.content.scrollLeft = scrollLeft;
      }

      this.handleScroll();
    });
  }

  setDraggingDirection() {
    this.setState({
      isHDragging: /horizontal/.test(this.direction || ''),
      isVDragging: /vertical/.test(this.direction || '')
    }, this.onStateUpdate);
  }

  renderContent() {
    const {
      dataQaType,
      id,
      children,
      contentInnerOffsetTop,
      contentInnerOffsetBottom,
      disabled
    } = this.props;
    return /*#__PURE__*/React.createElement(OffsetWrapper, {
      offsetBottom: contentInnerOffsetBottom,
      offsetTop: contentInnerOffsetTop
    }, /*#__PURE__*/React.createElement(ScrollContent, {
      dataQaType: dataQaType,
      scrollY: !disabled && this.verticalProportion < 1,
      scrollX: !disabled && this.horizontalProportion < 1,
      ref: this.contentRef,
      onScroll: this.handleScroll,
      id: id,
      onWheel: this.handleWheel
    }, /*#__PURE__*/React.createElement(PortalWrapper, null, children)));
  }

  renderNativeContainer() {
    const {
      id,
      contentInnerOffsetTop,
      contentInnerOffsetBottom,
      children
    } = this.props;
    const {
      mounted
    } = this.state;
    return /*#__PURE__*/React.createElement("div", Object.assign({}, dataQa(this.props), {
      ref: this.setRef('container'),
      style: {
        width: '100%',
        height: '100%'
      }
    }), /*#__PURE__*/React.createElement(OffsetWrapper, {
      offsetBottom: contentInnerOffsetBottom,
      offsetTop: contentInnerOffsetTop
    }, /*#__PURE__*/React.createElement("div", {
      id: id,
      ref: this.contentRef,
      onMouseOver: this.handleMouseOver,
      onMouseLeave: this.handleMouseLeave,
      className: cn({
        [styles.nativeScrollContainer]: true,
        [styles.nativeScrollContainer_hidden]: !mounted
      }),
      onScroll: this.handleNativeContainerScroll,
      onWheel: this.handleWheel
    }, /*#__PURE__*/React.createElement(PortalWrapper, null, children))));
  }

  render() {
    const {
      mounted
    } = this.state; // на сервере и на клиенте в мобилах рисуем нативный скролл

    return !mounted || (this.deviceType === 'tablet' || this.deviceType === 'mobile') && !this.props.fallback ? this.renderNativeContainer() : /*#__PURE__*/React.createElement("div", Object.assign({}, dataQa(this.props), {
      ref: this.setRef('container'),
      className: cn({
        [styles.scroll]: true,
        [styles.scroll_preventStackContext]: this.props.preventStackContext
      }),
      onMouseOver: this.handleMouseOver,
      onMouseLeave: this.handleMouseLeave
    }), this.renderContent(), this.renderScrollBar('horizontal'), this.renderScrollBar('vertical'));
  }

}

Scroll.defaultProps = {
  theme: 'default',
  preventOuterScroll: false,
  scrollbarVisibility: SCROLLBAR_VISIBILITY.ONLY_ACTIVE,
  fallback: false,
  preventStackContext: false,
  dataQaType: 'uikit/scroll',
  contentInnerOffsetBottom: 0,
  contentInnerOffsetTop: 0,
  barMinHeight: 0
};
export default Scroll;