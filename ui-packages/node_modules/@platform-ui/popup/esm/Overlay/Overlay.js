import React, { useState, useEffect, useRef, forwardRef } from 'react';
import cn from 'classnames';
import keycode from 'keycode';
import { useCallbackRef, useMergeRefs } from 'use-callback-ref';
import dataQa from '@platform-ui/dataQa';
import Portal from '@platform-ui/portal';
import { useAnimationDisabled } from '@platform-ui/dom-utils';
import { disableBodyScroll, enableBodyScroll } from '@platform-ui/body-scroll-lock';
import animationStyles from '../Animations.module.css';
import styles from './Overlay.module.css';
const Overlay = /*#__PURE__*/forwardRef((props, forwardedRef) => {
  /* TODO: после релиза задачи UIKIT-5370 значение необходимо взять из css-переменной --tds-color-overlay */
  const defaultBackdropColor = 'rgba(0, 0, 0, .75)';
  const {
    dataQaType = 'uikit/popup.overlay',
    dataQaData,
    opened,
    onClose,
    onKeyDown,
    onKeyUp,
    popupOpenedClass = animationStyles.fade_open,
    popupClosedClass = animationStyles.fade_close,
    disableAnimation,
    disableScroll,
    zIndex,
    minWidth,
    height,
    focusOnClose,
    transparent,
    gapFillColor = defaultBackdropColor,
    children,
    onCloseEnd
  } = props;
  /**
   * Флаг mounted предназначен для показа/скрытия компонента.
   * Проп opened не используется напрямую, чтобы была возможность
   * скрывать компонент после завершения анимации.
   */

  const [mounted, setMounted] = useState(opened);
  /**
   * lastActiveElRef предназначена для хранения элемента,
   * на котором был фокус до открытия Overlay, чтобы вернуть туда фокус после закрытия.
   */

  const lastActiveElRef = useRef(null);
  /**
   * clickedElRef используется для хранения элемента,
   * на котором была нажата кнопка мыши. UIKIT-3700
   */

  const clickedElRef = useRef(null);
  const scrollableWrapperRef = useRef(null);
  const popupWrapperRef = useRef(null);
  const [backdropRef, animationDisabled] = useAnimationDisabled({
    property: 'animation',
    disabled: disableAnimation
  });
  const rootRef = useMergeRefs([forwardedRef, useCallbackRef(null, (root, prevRoot) => {
    if (root) {
      if (!root.querySelector('*:focus')) {
        var _scrollableWrapperRef;

        lastActiveElRef.current = focusOnClose || document.activeElement;
        children && ((_scrollableWrapperRef = scrollableWrapperRef.current) == null ? void 0 : _scrollableWrapperRef.focus());
      }

      disableBodyScroll(root, {
        allowTouchMove: true
      });
    } else if (prevRoot) {
      if (lastActiveElRef.current) {
        lastActiveElRef.current.focus();
        lastActiveElRef.current = null;
      }

      enableBodyScroll(prevRoot);
    }
  })], null);
  const handleKeyDown = React.useCallback(event => {
    if (keycode(event.nativeEvent) === 'esc') {
      onClose(event);
    }

    onKeyDown && onKeyDown(event);
  }, [onClose, onKeyDown]);
  const handleMouseDown = React.useCallback(event => {
    clickedElRef.current = event.target;
  }, []);
  const handleMouseUp = React.useCallback(event => {
    if (clickedElRef.current && clickedElRef.current === popupWrapperRef.current) {
      onClose(event);
      clickedElRef.current = null;
    }
  }, [onClose]);
  const handleAnimationEnd = React.useCallback(() => {
    setMounted(false);
    onCloseEnd && onCloseEnd();
  }, [onCloseEnd]);
  const handleFocusOnBeforeElement = React.useCallback(event => {
    event.preventDefault();

    if (popupWrapperRef.current) {
      const focusable = popupWrapperRef.current.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
      const lastFocusable = focusable[focusable.length - 1];
      lastFocusable && lastFocusable.focus();
    }
  }, []);
  const handleFocusOnAfterElement = React.useCallback(event => {
    var _scrollableWrapperRef2;

    event.preventDefault();
    (_scrollableWrapperRef2 = scrollableWrapperRef.current) == null ? void 0 : _scrollableWrapperRef2.focus();
  }, []);
  useEffect(() => {
    if (opened) {
      setMounted(true);
    }

    if (!opened && animationDisabled) {
      handleAnimationEnd();
    }
  }, [animationDisabled, handleAnimationEnd, opened]);
  const backdropStyle = transparent ? undefined : {
    background: defaultBackdropColor,
    boxShadow: `0 100vh 0 100vh ${gapFillColor}`
  };
  return mounted ? /*#__PURE__*/React.createElement(Portal, {
    to: "body"
  }, /*#__PURE__*/React.createElement("div", Object.assign({
    ref: rootRef,
    role: "dialog",
    className: cn({
      [styles.root]: true,
      [styles.root_closed]: !opened,
      [styles.root_opened]: opened,
      [styles.root_disabledScroll]: disableScroll,
      [styles.root_disabledAnimation]: disableAnimation,
      [styles.root_transparent]: transparent
    }),
    onKeyDown: handleKeyDown,
    onKeyUp: onKeyUp,
    style: {
      zIndex,
      height
    }
  }, dataQa({
    dataQaType,
    dataQaData
  })), /*#__PURE__*/React.createElement("div", {
    className: cn({
      [styles.backdrop]: true,
      [styles.backdrop_transparent]: transparent
    }),
    ref: backdropRef,
    style: backdropStyle,
    onAnimationEnd: !opened && !animationDisabled ? handleAnimationEnd : undefined
  }), /*#__PURE__*/React.createElement("div", {
    tabIndex: 0,
    onFocus: handleFocusOnBeforeElement
  }), /*#__PURE__*/React.createElement("div", {
    tabIndex: 0,
    className: styles.popupScrollableWrapper,
    ref: scrollableWrapperRef
  }, /*#__PURE__*/React.createElement("div", {
    ref: popupWrapperRef,
    className: cn({
      [styles.popupWrapper]: true,
      [popupOpenedClass]: !disableAnimation && opened,
      [popupClosedClass]: !disableAnimation && !opened
    }),
    onMouseDown: handleMouseDown,
    onMouseUp: handleMouseUp,
    style: {
      minWidth
    },
    "data-qa-type": "uikit/popup.wrapper"
  }, children)), /*#__PURE__*/React.createElement("div", {
    tabIndex: 0,
    onFocus: handleFocusOnAfterElement
  }))) : null;
});
export default Overlay;