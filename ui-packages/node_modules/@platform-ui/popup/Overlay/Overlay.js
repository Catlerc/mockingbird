"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _keycode = _interopRequireDefault(require("keycode"));

var _useCallbackRef = require("use-callback-ref");

var _dataQa = _interopRequireDefault(require("@platform-ui/dataQa"));

var _portal = _interopRequireDefault(require("@platform-ui/portal"));

var _domUtils = require("@platform-ui/dom-utils");

var _bodyScrollLock = require("@platform-ui/body-scroll-lock");

var _AnimationsModule = _interopRequireDefault(require("../Animations.module.css"));

var _OverlayModule = _interopRequireDefault(require("./Overlay.module.css"));

var Overlay = /*#__PURE__*/(0, _react.forwardRef)(function (props, forwardedRef) {
  var _cn, _cn2, _cn3;

  /* TODO: после релиза задачи UIKIT-5370 значение необходимо взять из css-переменной --tds-color-overlay */
  var defaultBackdropColor = 'rgba(0, 0, 0, .75)';
  var _props$dataQaType = props.dataQaType,
      dataQaType = _props$dataQaType === void 0 ? 'uikit/popup.overlay' : _props$dataQaType,
      dataQaData = props.dataQaData,
      opened = props.opened,
      onClose = props.onClose,
      onKeyDown = props.onKeyDown,
      onKeyUp = props.onKeyUp,
      _props$popupOpenedCla = props.popupOpenedClass,
      popupOpenedClass = _props$popupOpenedCla === void 0 ? _AnimationsModule.default.fade_open : _props$popupOpenedCla,
      _props$popupClosedCla = props.popupClosedClass,
      popupClosedClass = _props$popupClosedCla === void 0 ? _AnimationsModule.default.fade_close : _props$popupClosedCla,
      disableAnimation = props.disableAnimation,
      disableScroll = props.disableScroll,
      zIndex = props.zIndex,
      minWidth = props.minWidth,
      height = props.height,
      focusOnClose = props.focusOnClose,
      transparent = props.transparent,
      _props$gapFillColor = props.gapFillColor,
      gapFillColor = _props$gapFillColor === void 0 ? defaultBackdropColor : _props$gapFillColor,
      children = props.children,
      onCloseEnd = props.onCloseEnd;
  /**
   * Флаг mounted предназначен для показа/скрытия компонента.
   * Проп opened не используется напрямую, чтобы была возможность
   * скрывать компонент после завершения анимации.
   */

  var _useState = (0, _react.useState)(opened),
      mounted = _useState[0],
      setMounted = _useState[1];
  /**
   * lastActiveElRef предназначена для хранения элемента,
   * на котором был фокус до открытия Overlay, чтобы вернуть туда фокус после закрытия.
   */


  var lastActiveElRef = (0, _react.useRef)(null);
  /**
   * clickedElRef используется для хранения элемента,
   * на котором была нажата кнопка мыши. UIKIT-3700
   */

  var clickedElRef = (0, _react.useRef)(null);
  var scrollableWrapperRef = (0, _react.useRef)(null);
  var popupWrapperRef = (0, _react.useRef)(null);

  var _useAnimationDisabled = (0, _domUtils.useAnimationDisabled)({
    property: 'animation',
    disabled: disableAnimation
  }),
      backdropRef = _useAnimationDisabled[0],
      animationDisabled = _useAnimationDisabled[1];

  var rootRef = (0, _useCallbackRef.useMergeRefs)([forwardedRef, (0, _useCallbackRef.useCallbackRef)(null, function (root, prevRoot) {
    if (root) {
      if (!root.querySelector('*:focus')) {
        var _scrollableWrapperRef;

        lastActiveElRef.current = focusOnClose || document.activeElement;
        children && ((_scrollableWrapperRef = scrollableWrapperRef.current) == null ? void 0 : _scrollableWrapperRef.focus());
      }

      (0, _bodyScrollLock.disableBodyScroll)(root, {
        allowTouchMove: true
      });
    } else if (prevRoot) {
      if (lastActiveElRef.current) {
        lastActiveElRef.current.focus();
        lastActiveElRef.current = null;
      }

      (0, _bodyScrollLock.enableBodyScroll)(prevRoot);
    }
  })], null);

  var handleKeyDown = _react.default.useCallback(function (event) {
    if ((0, _keycode.default)(event.nativeEvent) === 'esc') {
      onClose(event);
    }

    onKeyDown && onKeyDown(event);
  }, [onClose, onKeyDown]);

  var handleMouseDown = _react.default.useCallback(function (event) {
    clickedElRef.current = event.target;
  }, []);

  var handleMouseUp = _react.default.useCallback(function (event) {
    if (clickedElRef.current && clickedElRef.current === popupWrapperRef.current) {
      onClose(event);
      clickedElRef.current = null;
    }
  }, [onClose]);

  var handleAnimationEnd = _react.default.useCallback(function () {
    setMounted(false);
    onCloseEnd && onCloseEnd();
  }, [onCloseEnd]);

  var handleFocusOnBeforeElement = _react.default.useCallback(function (event) {
    event.preventDefault();

    if (popupWrapperRef.current) {
      var focusable = popupWrapperRef.current.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
      var lastFocusable = focusable[focusable.length - 1];
      lastFocusable && lastFocusable.focus();
    }
  }, []);

  var handleFocusOnAfterElement = _react.default.useCallback(function (event) {
    var _scrollableWrapperRef2;

    event.preventDefault();
    (_scrollableWrapperRef2 = scrollableWrapperRef.current) == null ? void 0 : _scrollableWrapperRef2.focus();
  }, []);

  (0, _react.useEffect)(function () {
    if (opened) {
      setMounted(true);
    }

    if (!opened && animationDisabled) {
      handleAnimationEnd();
    }
  }, [animationDisabled, handleAnimationEnd, opened]);
  var backdropStyle = transparent ? undefined : {
    background: defaultBackdropColor,
    boxShadow: "0 100vh 0 100vh " + gapFillColor
  };
  return mounted ? /*#__PURE__*/_react.default.createElement(_portal.default, {
    to: "body"
  }, /*#__PURE__*/_react.default.createElement("div", Object.assign({
    ref: rootRef,
    role: "dialog",
    className: (0, _classnames.default)((_cn = {}, _cn[_OverlayModule.default.root] = true, _cn[_OverlayModule.default.root_closed] = !opened, _cn[_OverlayModule.default.root_opened] = opened, _cn[_OverlayModule.default.root_disabledScroll] = disableScroll, _cn[_OverlayModule.default.root_disabledAnimation] = disableAnimation, _cn[_OverlayModule.default.root_transparent] = transparent, _cn)),
    onKeyDown: handleKeyDown,
    onKeyUp: onKeyUp,
    style: {
      zIndex: zIndex,
      height: height
    }
  }, (0, _dataQa.default)({
    dataQaType: dataQaType,
    dataQaData: dataQaData
  })), /*#__PURE__*/_react.default.createElement("div", {
    className: (0, _classnames.default)((_cn2 = {}, _cn2[_OverlayModule.default.backdrop] = true, _cn2[_OverlayModule.default.backdrop_transparent] = transparent, _cn2)),
    ref: backdropRef,
    style: backdropStyle,
    onAnimationEnd: !opened && !animationDisabled ? handleAnimationEnd : undefined
  }), /*#__PURE__*/_react.default.createElement("div", {
    tabIndex: 0,
    onFocus: handleFocusOnBeforeElement
  }), /*#__PURE__*/_react.default.createElement("div", {
    tabIndex: 0,
    className: _OverlayModule.default.popupScrollableWrapper,
    ref: scrollableWrapperRef
  }, /*#__PURE__*/_react.default.createElement("div", {
    ref: popupWrapperRef,
    className: (0, _classnames.default)((_cn3 = {}, _cn3[_OverlayModule.default.popupWrapper] = true, _cn3[popupOpenedClass] = !disableAnimation && opened, _cn3[popupClosedClass] = !disableAnimation && !opened, _cn3)),
    onMouseDown: handleMouseDown,
    onMouseUp: handleMouseUp,
    style: {
      minWidth: minWidth
    },
    "data-qa-type": "uikit/popup.wrapper"
  }, children)), /*#__PURE__*/_react.default.createElement("div", {
    tabIndex: 0,
    onFocus: handleFocusOnAfterElement
  }))) : null;
});
var _default = Overlay;
exports.default = _default;